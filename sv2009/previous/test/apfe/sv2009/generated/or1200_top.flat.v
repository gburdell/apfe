`line 1 "../../rtl/verilog/or1200_alu.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's ALU                                                ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  ALU                                                         ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_alu.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, flags are corrected. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 50 "../../rtl/verilog/or1200_alu.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 51 "../../rtl/verilog/or1200_alu.v" 2

module or1200_alu(
	a, b, mult_mac_result, macrc_op,
	alu_op, alu_op2, comp_op,
	cust5_op, cust5_limm,
	result, flagforw, flag_we,
	ovforw, ov_we,
	cyforw, cy_we, carry, flag
);

parameter width =   32;

//
// I/O
//
input	[width-1:0]		a;
input	[width-1:0]		b;
input	[width-1:0]		mult_mac_result;
input				macrc_op;
input	[ 5-1:0]	alu_op;
input	[ 4-1:0]	alu_op2;
input	[ 4-1:0]	comp_op;
input	[4:0]			cust5_op;
input	[5:0]			cust5_limm;
output	[width-1:0]		result;
output				flagforw;
output				flag_we;
output				cyforw;
output				cy_we;
output				ovforw;
output				ov_we;
input				carry;
input         flag;

//
// Internal wires and regs
//
reg	[width-1:0]		result;
reg	[width-1:0]		shifted_rotated;
reg	[width-1:0]		extended;   
                            
                              
      
reg				flagforw;
reg				flagcomp;
reg				flag_we;
reg				cyforw;
reg				cy_we;
reg				ovforw;
reg				ov_we;   
wire	[width-1:0]		comp_a;
wire	[width-1:0]		comp_b;
wire				a_eq_b;
wire				a_lt_b;
wire	[width-1:0]		result_sum;
wire	[width-1:0]		result_and;
wire				cy_sum;
                      
wire				cy_sub;
      
wire    			ov_sum;
wire    [width-1:0] 		carry_in;

wire    [width-1:0]		b_mux;
   
   

//
// Combinatorial logic
//

assign comp_a = {a[width-1] ^ comp_op[3] , a[width-2:0]};
assign comp_b = {b[width-1] ^ comp_op[3] , b[width-2:0]};
                            
                                   
                                  
      
                            
assign a_eq_b = !(|result_sum);
// signed compare when comp_op[3] is set
assign a_lt_b = comp_op[3] ? ((a[width-1] & !b[width-1]) |  
			      (!a[width-1] & !b[width-1] & result_sum[width-1])|
			      (a[width-1] & b[width-1] & result_sum[width-1])):
		(a < b);

      
   
                      
                             
assign cy_sub =	a_lt_b;
               
                                  
       			      
      
   
                          
assign carry_in = (alu_op== 5'b0_0001 ) ? 
		  {{width-1{1'b0}},carry} : {width{1'b0}};
     
                                  
      

                            
                      
assign b_mux = ((alu_op== 5'b0_0010 ) | (alu_op==       5'b1_0000 )) ? 
		(~b)+1 : b;
     
                                                         
      
                                       
                      
                                                        
     
                 
      
      			      
assign {cy_sum, result_sum} = (a + b_mux) + carry_in;
// Numbers either both +ve and bit 31 of result set
assign ov_sum = ((!a[width-1] & !b_mux[width-1]) & result_sum[width-1]) |
                      
		// Subtract larger negative from smaller positive
		((!a[width-1] & b_mux[width-1]) & result_sum[width-1] &
		 alu_op== 5'b0_0010 ) |
      
// or both -ve and bit 31 of result clear
		((a[width-1] & b_mux[width-1]) & !result_sum[width-1]);  
assign result_and = a & b;

//
// Simulation check for bad ALU behavior
//
                      
                         
                      
                      
                                                                                   
   
                        
      

//
// Central part of the ALU
//
always @(alu_op or alu_op2 or a or b or result_sum or result_and or macrc_op
	 or shifted_rotated or mult_mac_result or flag or carry
                          
         or extended
      	 
                            
                 
      
) begin
                          
	casez (alu_op)		// synopsys parallel_case
     
                                                    
      
                           	  
		 5'b0_1111 : begin
                          
		   casez (alu_op2) // synopsys parallel_case
     
                                                        
      
		     0: begin // FF1
			result = a[0] ? 1 : a[1] ? 2 : a[2] ? 3 : a[3] ? 4 : a[4] ? 5 : a[5] ? 6 : a[6] ? 7 : a[7] ? 8 : a[8] ? 9 : a[9] ? 10 : a[10] ? 11 : a[11] ? 12 : a[12] ? 13 : a[13] ? 14 : a[14] ? 15 : a[15] ? 16 : a[16] ? 17 : a[17] ? 18 : a[18] ? 19 : a[19] ? 20 : a[20] ? 21 : a[21] ? 22 : a[22] ? 23 : a[23] ? 24 : a[24] ? 25 : a[25] ? 26 : a[26] ? 27 : a[27] ? 28 : a[28] ? 29 : a[29] ? 30 : a[30] ? 31 : a[31] ? 32 : 0;
		     end
		     default: begin // FL1
			result = a[31] ? 32 : a[30] ? 31 : a[29] ? 30 : a[28] ? 29 : a[27] ? 28 : a[26] ? 27 : a[25] ? 26 : a[24] ? 25 : a[23] ? 24 : a[22] ? 23 : a[21] ? 22 : a[20] ? 21 : a[19] ? 20 : a[18] ? 19 : a[17] ? 18 : a[16] ? 17 : a[15] ? 16 : a[14] ? 15 : a[13] ? 14 : a[12] ? 13 : a[11] ? 12 : a[10] ? 11 : a[9] ? 10 : a[8] ? 9 : a[7] ? 8 : a[6] ? 7 : a[5] ? 6 : a[4] ? 5 : a[3] ? 4 : a[2] ? 3 : a[1] ? 2 : a[0] ? 1 : 0 ;
		     end
		   endcase // casez (alu_op2)
		end // case: `OR1200_ALUOP_FFL1
       //  `ifdef OR1200_IMPL_ALU_FFL1
                            
   
                              
                          
     
      		     
		 5'b0_1000  : begin 
				result = shifted_rotated;
		end
                       
		 5'b0_0001 ,
      
                      
		 5'b0_0010 ,
      	 
		 5'b0_0000  : begin
				result = result_sum;
		end
		 5'b0_0101  : begin
				result = a ^ b;
		end
		  5'b0_0100   : begin
				result = a | b;
		end
                          		     
		 5'b0_1100   : begin
		                result = extended;
		end
		 5'b0_1101   : begin
		                result = a;
		end		
           
		      5'b1_0001  : begin
				if (macrc_op) begin
					result = mult_mac_result;
				end
				else begin
					result = b << 16;
				end
		end
                              
                             
		 5'b0_1001 ,
		 5'b0_1010 ,
      
		 5'b0_0110 ,
		 5'b0_1011  : begin
				result = mult_mac_result;
		end
      
		 5'b0_1110 : begin
			result = flag ? a : b;
		end

                          
		default: begin
     
                                              
      
			result=result_and;
		end 
	endcase
end

//
// Generate flag and flag write enable
//
always @(alu_op or result_sum or result_and or flagcomp
) begin
	casez (alu_op)		// synopsys parallel_case
                                       
                       
                     
        
                           
                                            
                  
     
                          
                                            
                  
     
      
		       5'b1_0000 : begin
			flagforw = flagcomp;
			flag_we = 1'b1;
		end
		default: begin
			flagforw = flagcomp;
			flag_we = 1'b0;
		end
	endcase
end

//
// Generate SR[CY] write enable
//
always @(alu_op or cy_sum
                     
                      
	or cy_sub
      
      
) begin
	casez (alu_op)		// synopsys parallel_case
                     
                       
		 5'b0_0001 ,
      	  
		 5'b0_0000  : begin
			cyforw = cy_sum;
			cy_we = 1'b1;
		end
                      
		 5'b0_0010 : begin
			cyforw = cy_sub;
			cy_we = 1'b1;
		end
      
      
		default: begin
			cyforw = 1'b0;
			cy_we = 1'b0;
		end
	endcase
end


//
// Generate SR[OV] write enable
//
always @(alu_op or ov_sum) begin
	casez (alu_op)		// synopsys parallel_case
                     
                       
		 5'b0_0001 ,
      
                      
		 5'b0_0010 ,
      	 
		 5'b0_0000  : begin
			ovforw = ov_sum;
			ov_we = 1'b1;
		end
      	  
		default: begin
			ovforw = 1'b0;
			ov_we = 1'b0;
		end
	endcase
end
   
//
// Shifts and rotation
//
always @(alu_op2 or a or b) begin
	case (alu_op2)		// synopsys parallel_case
	   4'd0 :
				shifted_rotated = (a << b[4:0]);
	   4'd1 :
				shifted_rotated = (a >> b[4:0]);

                             
                        
                                                                         
                      
      
	  default:
	                        shifted_rotated = ({32{a[31]}} << 
						   (6'd32-{1'b0, b[4:0]})) | 
						  a >> b[4:0];
	endcase
end

//
// First type of compare implementation
//
                            
                                           
                                             
                   
                     
                   
                      
                   
                                 
                   
                      
                   
                     
                   
                              
          
                   
        
   
      

//
// Second type of compare implementation
//
                            
                                           
                                             
                   
                                 
                   
                                 
                   
                                
                   
                                 
                   
                                
                   
                                 
          
                   
        
   
       //  `ifdef OR1200_IMPL_ALU_COMP2

                            
always @(comp_op or a_eq_b or a_lt_b) begin
	case(comp_op[2:0])	// synopsys parallel_case
		       3'b000:
			flagcomp = a_eq_b;
		       3'b001:
			flagcomp = ~a_eq_b;
		       3'b010:
			flagcomp = ~(a_eq_b | a_lt_b);
		       3'b011:
			flagcomp = ~a_lt_b;
		       3'b100:
			flagcomp = a_lt_b;
		       3'b101:
			flagcomp = a_eq_b | a_lt_b;
		default:
			flagcomp = 1'b0;
	endcase
end
      
   

                          
   always @(alu_op or alu_op2 or a) begin
      casez (alu_op2)
	         4'h0 : extended = {{16{a[15]}},a[15:0]};
	         4'h1 : extended = {{24{a[7]}},a[7:0]};
	         4'h2 : extended = {16'd0,a[15:0]};
	         4'h3 : extended = {24'd0,a[7:0]};
	default: extended = a; // Used for l.extw instructions
      endcase // casez (alu_op2)
   end
       
	     

//
// l.cust5 custom instructions
//
                            
                                                
  
                                                
                                            
               
                          
                                            
                                                     
                                                      
                                            
          
     
        
                                        
        
                                                         
  
                                                   
  
                
                    
     
        
                                                  
         

endmodule

`line 1 "../../rtl/verilog/or1200_amultp2_32x32.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's 32x32 multiply for ASIC                            ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  32x32 multiply for ASIC                                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_amultp2_32x32.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 49 "../../rtl/verilog/or1200_amultp2_32x32.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 50 "../../rtl/verilog/or1200_amultp2_32x32.v" 2

                               

                                                          
              
              
              
           
           
             
                                                           
         


                                                                               
              
              
              
              
           
           
           
           
             
                                                                                                             
         


                                                                   
              
              
              
              
           
           
             
                                                                                         
         


                                       
           
           
           
             
                                         
         


                                                                 
           
           
           
              
              
              
              
                                                  
                                                       
                                                                             
                                                                   
         


                                              
                  
                  
                       
                                
                              
                              
                        
                         
                                                                                                                                                                                              
                                          
                                                                                                                                                                              
                                                                                             
                                          
                                                                                                                                                                                                                                                            
                                          
                                                                                                                                                                                                                                                            
                                          
                                                                                                                                                                                                                                                            
                                          
                                                                                                                                                                                                                                                            
                                          
                                                                                                                                                                                                                                                             
                                          
                                                                                                                                                                                                                                                             
                                          
                                                                                                                                                                                                                                                             
                                          
                                                                                                                                                                                                                                                             
                                          
                                                                                                                                                                                                                                                             
                                            
                                                                                                                                                                                                                                                               
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                  
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                            
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                 
                           
                                                                                                                                                                                          
                                                                                                                                                                              
                                                                                         
                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                   
                                                                                                                                                                                                                 
                                                                                                                                                                                            
                                                                                                                                                                                 
                                                                                          
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                     
                                   
                                                                                                                                                                                                                   
                                                                                                                                                                                              
                                                                                                                                                                                  
                                                                                          
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                     
                                                                                                                                                                                              
                                                                                                                                                                                  
                                                                                          
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                     
                                                                                                                                                                                                
                                                                                                                                                                                  
                                                                                            
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                     
                                                                                                                                                                                                 
                                                                                                                                                                                  
                                                                                             
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                     
                                                                                                                                                                                                 
                                                                                                                                                                                  
                                                                                             
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                     
                                                                                                                                                                                                 
                                                                                                                                                                                  
                                                                                             
                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                     
                                                                                                                                                                                                 
                                                                                                                                                                                   
                                                                                              
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                     
                                                                                                                                                                                                  
                                                                                                                                                                                    
                                                                                               
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                      
                                                                                                                                                                                                  
                                                                                                                                                                                    
                                                                                               
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                      
                                                                                                                                                                                                  
                                                                                                                                                                                    
                                                                                               
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                      
                                                                                                                                                                                                  
                                                                                                                                                                                    
                                                                                               
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                      
                                                                                                                                                                                                  
                                                                                                                                                                                    
                                                                                               
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                      
                                                                                                                                                                                                  
                                                                                                                                                                                    
                                                                                               
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                        
                                   
                                                                                                                                                                                                                      
         


                                                          
              
              
              
            
             
            
                                
                              
                                                                    
         


                                                  
              
              
            
             
                                 
                                  
         


                                        
           
           
           
            
                
                                                          
                                   
                         
          
                         
      
                          
         


                                                       
                       
           
           
                    
                  
                         
                          
                        
                                                                                                               
                                                                               
                                                                                   
                                  
                       
                                                                               
                                                                                                                                      
                                                                               
                                                                                   
                                                                                                               
                                                                               
                                                                                   
                                                                                                                                       
                                   
                                                                                                               
                                                                               
                                                                                   
                                                                                                                                         
                                                                                                                 
                                                                               
                                                                                    
                                                                                                                                         
                                                                                                                  
                                                                                                                                          
                                                                                 
                                                                                    
                                                                                                                                           
                                    
                                                                                                                                            
                                     
                                                                                                                   
                                                                                 
                                                                                     
                                                                                                                                           
                                                                                                                                           
                                                                                                                                             
                                                                                                                     
                                                                                 
                                                                                     
                                                                                                                                            
                                                                                                                   
                                                                                                                                              
                                      
                                                                                                                                              
                                                                                 
                                                                                     
                                                                                                                                            
                                                                                                                                            
                                    
                                                                                                                                            
                                                                                                                       
                                                                                                                                              
                                                                                  
                                                                                      
                                                                                                                                            
                                                                                                                                            
                                                                                                                                              
                                      
                                                                                                                                              
                                      
                                                                                                                   
                                                                                  
                                                                                      
                                                                                                                                            
                                                                                                                                            
                                    
                                    
                                                                                                                                            
                                                                                                                                                
                                                                                                                                              
                                                                                                                      
                                                                                  
                                                                                      
                                                                                                                                            
                                                                                                                                            
                                    
                                                                                                                                            
                                                                                                                        
                                                                                                                                              
                                      
                                                                                                                                              
                                                                                  
                                                                                      
                                                                                                                                            
                                                                                                                                            
                                                                                                                                            
                                                                                                                                            
                                                                                                                        
                                                                                                                                              
                                      
                                                                                                                                              
                                                                                  
                                                                                      
                                                                                                                                            
                                                                                                                                            
                                                                                                                    
                                                                                                                                            
                                                                                                                                                  
                                                                                                                                              
                                      
                                                                                                                                              
                                                                                  
                                                                                      
                                                                                                                                            
                                                                                                                                            
                                                                                                                                            
                                    
                                                                                                                                            
                                                                                                                                                
                                      
                                                                                                                                            
                                                                                                                        
                                                                                                                                              
                                                                                  
                                                                                      
                                                                                                                                            
                                                                                                                                            
                                                                                                                                            
                                                                                                                                            
                                                                                                                                                  
                                                                                                                                              
                                      
                                                                                                                                              
                                      
                                                                                      
                                                                                      
                                                                                                            
                                                                                                                                              
                                                                                                                                               
                                                                                                                                               
                                     
                                     
                                                                                                                                            
                                                                                                                                              
                                      
                                       
                                                                                                                                             
                                                                                                                                                  
                                                                                                                                                 
                                                                                        
                                                                                          
                                                                                                               
                                                                                                                                                
                                                                                                                                                
                                                                                                                                                
                                      
                                                                                                                                                
                                                                                                                                                  
                                       
                                                                                                                                                
                                                                                                                         
                                                                                                                                                 
                                       
                                                                                        
                                                                                        
                                                                                          
                                                                                                                                        
                                                                                                                                                
                                                                                                                                                
                                                                                                                                                
                                                                                                                                                
                                                                                                                                                
                                                                                                                                                  
                                       
                                                                                                                                                
                                                                                                                         
                                                                                                                                                 
                                       
                                                                                        
                                                                                        
                                                                                          
                                                                                                                                        
                                                                                                                                                 
                                                                                                                                                 
                                                                                                                                                 
                                      
                                      
                                                                                                                                                 
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                 
                                                                                                                          
                                                                                                                                                  
                                       
                                                                                        
                                                                                        
                                                                                           
                                                                                                                                         
                                                                                                                                                 
                                                                                                                                                 
                                                                                                                                                 
                                                                                                                                                 
                                      
                                                                                                                                                 
                                                                                                                                                   
                                                                                                                            
                                                                                                                                                 
                                                                                                                                                       
                                                                                                                                                   
                                        
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                                                                                                            
                                                                                                                                                  
                                                                                                                                                        
                                                                                                                                                    
                                        
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                        
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                                                        
                                                                                                                                                    
                                        
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                                                        
                                                                                                                                                    
                                        
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                              
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                        
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                        
                                        
                                                                                        
                                                                                        
                                                                                        
                                                                                                                                                  
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                        
                                        
                                        
                                                                                                                                                  
                                                                                                                                                    
                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                      
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                        
                                        
                                        
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                            
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                        
                                                                                                                            
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                                                        
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                      
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                        
                                        
                                        
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                            
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                                                        
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                            
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                        
                                                                                        
                                                                                            
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                        
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                        
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                        
                                        
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                                                      
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                                                                                                            
                                                                                                                                                  
                                                                                                                                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                      
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                                                        
                                                                                                                                                  
                                                                                                                                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                        
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                      
                                        
                                        
                                                                                                                                                  
                                                                                                                                                      
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                      
                                        
                                                                                                                                                  
                                                                                                                            
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                        
                                                                                                                                                    
                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                        
                                                                                                                                                    
                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                    
                                                                                                                            
                                                                                                                                                  
                                                                                                                                                      
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                                                                                                                                  
                                      
                                      
                                                                                                                                                  
                                      
                                                                                                                                                    
                                                                                                                                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                      
                                                                                                                                                  
                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                      
                                                                                                                                                  
                                                                                                                                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                    
                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                                                                                  
                                                                                                                                                    
                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                                                                                                        
                                                                                                                                                    
                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                                                                                                        
                                                                                                                                                    
                                        
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                                                                                                                                      
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                                                
                                                                                                                                                  
                                      
                                                                                         
                                                                                         
                                                                                             
                                                                                                                                                    
                                                                                             
                                        
                                                                                                                                          
                                                                                                                                                  
                                                                                         
                                      
                                                                                             
                                        
                                                                                                                                          
                                                                                          
                                                                                          
                                                                                          
                                                                                                                                                     
                                                                                             
                                        
                                                                                                              
                                                                                          
                                       
                                                                                          
                                       
                                                                                                                                          
                                                                                          
                                                                                          
                                                                                                                
                                                                                          
                                  
         


                                   
           
           
            
                        
         


                                     
         
         
           
           
           
                                   
         


                                        
         
         
           
            
            
                            
                            
         


                                                          
            
            
            
            
           
            
            
                                  
                                           
         


                                                          
            
            
            
            
           
            
            
                                  
                                           
         


                                               
            
            
            
           
            
                                           
         


                                               
            
            
            
           
            
                                           
         


                                                  
                
                
           
           
                   
                   
                                                       
                                                       
                                                       
                                                       
                                                       
                                                       
                                                       
                                                       
                                                       
                                                        
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
                                      
         


                                               
                  
                  
           
                   
                   
                                          
                                                           
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                
                                                                                  
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
         


                                               
                  
                  
           
                   
                   
                                          
                                          
                                                           
                                                           
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                
                                                                                
                                                                                  
                                                                                  
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
         


                                               
                  
                  
           
                   
                   
                                          
                                          
                                          
                                          
                                                           
                                                           
                                                           
                                                           
                                                                             
                                                                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
         


                                               
                  
                  
           
                   
                   
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                                           
                                                           
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                                                
                                                                                
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
         


                                               
                  
                  
           
                   
                   
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                             
                                             
                                             
                                             
                                             
                                             
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                  
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
                                                                                    
         


                                               
                  
                  
           
                  
                   
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                              
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                                  
         


                                                         
                
                
            
           
                    
                  
            
                                                      
                                                      
                                                      
                                                      
                                                      
                                                      
                                                      
                                                      
                                                      
                                                      
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                          
         


                                                 
                  
                  
           
                   
                  
                         
                        
                         
                        
                         
                        
                         
                        
                         
                        
                                                                                           
                                                                                                      
                                                                                                      
                                                                                                      
                                                                                                      
                                                                                             
         


                                                         
                  
                  
           
           
                  
            
                       
                      
                   
                     
                                                              
                                                           
                                                                                      
         


                                                                            
                           
                         
           
           
           
                     
                      
                         
                       
                   
                       
                     
                         
                                                                                                    
                                                                                                                     
                                    
                                                                                                                                    
                                                 
                                  
                                    
         
                   
         


                                              
                                                            
                                    

                                                  
                
                
           
           
                
                 
                 
                 
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                                                                                             
         

      

`line 1 "../../rtl/verilog/or1200_cfgr.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's VR, UPR and Configuration Registers                ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  According to OR1K architectural and OR1200 specifications.  ////
////                                                              ////
////  To Do:                                                      ////
////   - done                                                     ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_cfgr.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 50 "../../rtl/verilog/or1200_cfgr.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 51 "../../rtl/verilog/or1200_cfgr.v" 2

module or1200_cfgr(
		   // RISC Internal Interface
		   spr_addr, spr_dat_o
		   );

   //
   // RISC Internal Interface
   //
   input	[31:0]	spr_addr;	// SPR Address
   output [31:0] 	spr_dat_o;	// SPR Read Data

   //
   // Internal wires & registers
   //
   reg [31:0] 		spr_dat_o;	// SPR Read Data

                              

   //
   // Implementation of VR, UPR and configuration registers
   //
   always @(spr_addr)
                              
     if (~|spr_addr[31:4])
       
       case(spr_addr[3:0])		// synopsys parallel_case
	   4'h0: begin
	    spr_dat_o[  5:0] =    6'h08;
	    spr_dat_o[  15:6] =    10'h000;
	    spr_dat_o[  23:16] =    8'h00;
	    spr_dat_o[  31:24] =    8'h13;
	 end
	   4'h1: begin
	    spr_dat_o[  0] =    1'b1;
	    spr_dat_o[  1] =    1'b1;
	    spr_dat_o[  2] =    1'b1;
	    spr_dat_o[  3] =    1'b1;
	    spr_dat_o[  4] =    1'b1;
	    spr_dat_o[  5] =    1'b0;
	    spr_dat_o[  6] =    1'b1;
	    spr_dat_o[  7] =    1'b0 ;
	    spr_dat_o[  8] =    1'b0;
	    spr_dat_o[  9] =    1'b1;
	    spr_dat_o[  10] =    1'b1;
	    spr_dat_o[  11] =    1'b0;
	    spr_dat_o[  23:12] =    12'h000;
	    spr_dat_o[  31:24] =    8'h00;
	 end
	  4'h2: begin
	    spr_dat_o[ 3:0] =       4'h0;
	    spr_dat_o[     4] =     1'b0;
	    spr_dat_o[ 5] =   1'b1;
	    spr_dat_o[ 6] =   1'b0;
	    spr_dat_o[ 7] =   1'b0;
	    spr_dat_o[ 8] =   1'b0;
	    spr_dat_o[ 9] =   1'b0;
	    spr_dat_o[ 31:10] =   22'h000000;
	 end
	  4'h3: begin
	    spr_dat_o[ 1:0] =   2'h0 ;
	    spr_dat_o[ 4:2] =  3'h 6      ;
	    spr_dat_o[ 7:5] =   3'h0 ;
	    spr_dat_o[ 8] =   1'b0 ;
	    spr_dat_o[ 9] =   1'b0 ;
	    spr_dat_o[ 10] =   1'b0 ;
	    spr_dat_o[ 11] =   1'b0 ;
	    spr_dat_o[ 31:12] =   20'h00000;
	 end
	  4'h4: begin
	    spr_dat_o[ 1:0] =   2'h0 ;
	    spr_dat_o[ 4:2] =  3'h 6      ;
	    spr_dat_o[ 7:5] =   3'h0 ;
	    spr_dat_o[ 8] =   1'b0 ;
	    spr_dat_o[ 9] =   1'b0 ;
	    spr_dat_o[ 10] =   1'b0 ;
	    spr_dat_o[ 11] =   1'b0 ;
	    spr_dat_o[ 31:12] =   20'h00000;
	 end
	  4'h5: begin
	    spr_dat_o[  2:0] =   3'h0 ;
	    spr_dat_o[  6:3] =  (      13   -  4 ) ;
	    spr_dat_o[  7] =    4==4 ? 1'b0 : 1'b1 ;
	    spr_dat_o[  8] =   1'b0 ;
	    spr_dat_o[  9] =   1'b1 ;
	    spr_dat_o[ 10] =   1'b1 ;
	    spr_dat_o[ 11] =   1'b0 ;
	    spr_dat_o[ 12] =   1'b0 ;
	    spr_dat_o[ 13] =   1'b1 ;
	    spr_dat_o[ 14] =   1'b0 ;
	    spr_dat_o[ 31:15] =   17'h00000;
	 end
	  4'h6: begin
	    spr_dat_o[  2:0] =   3'h0 ;
	    spr_dat_o[  6:3] =  (      13   -  4 ) ;
	    spr_dat_o[  7] =    4==4 ? 1'b0: 1'b1 ;
	    spr_dat_o[  8] =   1'b0 ;
	    spr_dat_o[  9] =   1'b1 ;
	    spr_dat_o[ 10] =   1'b1 ;
	    spr_dat_o[ 11] =   1'b0 ;
	    spr_dat_o[ 12] =   1'b0 ;
	    spr_dat_o[ 13] =   1'b1 ;
	    spr_dat_o[ 14] =   1'b0 ;
	    spr_dat_o[ 31:15] =   17'h00000;
	 end
	  4'h7: begin
	    spr_dat_o[  3:0] =   4'h0 ;
	    spr_dat_o[  4] =   1'b0 ;
	    spr_dat_o[  31:5] =   27'd0;
	 end
	 default: spr_dat_o = 32'h0000_0000;
       endcase
                              
     else
       spr_dat_o = 32'h0000_0000;
       

     

     
                                                            
                          
     
                     
                              
                                 
       
                          
                              
                                                     
                                                       
                                                     
                                                     
     
                               
                                                     
                                                       
                                                       
                                                       
                                                       
                                                     
                                                       
                                                         
                                                       
                                                         
                                                       
                                                         
                                                       
     
                                     
              
                              
         
                                 
       

      

endmodule

`line 1 "../../rtl/verilog/or1200_cpu.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's CPU                                                ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of internal CPU blocks. IFETCH, SPRS, FRZ,    ////
////  ALU, EXCEPT, ID, WBMUX, OPERANDMUX, RF etc.                 ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_cpu.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_cpu.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_cpu.v" 2

module or1200_cpu(
	// Clk & Rst
	clk, rst,

	// Insn interface
	ic_en,
	icpu_adr_o, icpu_cycstb_o, icpu_sel_o, icpu_tag_o,
	icpu_dat_i, icpu_ack_i, icpu_rty_i, icpu_err_i, icpu_adr_i, icpu_tag_i,
	immu_en,

	// Debug unit
	id_void, id_insn, ex_void, 
	ex_insn, ex_freeze, wb_insn, wb_freeze, id_pc, ex_pc, wb_pc, branch_op,
	spr_dat_npc, rf_dataw, ex_flushpipe, 
	du_stall, du_addr, du_dat_du, du_read, du_write, du_except_stop, du_flush_pipe,
	du_except_trig, du_dsr, du_dmr1, du_hwbkpt, du_hwbkpt_ls_r, du_dat_cpu,
	du_lsu_store_dat, du_lsu_load_dat, 
	abort_mvspr, abort_ex,
	
	// Data interface
	dc_en,
	dcpu_adr_o, dcpu_cycstb_o, dcpu_we_o, dcpu_sel_o, dcpu_tag_o, 
        dcpu_dat_o, dcpu_dat_i, dcpu_ack_i, dcpu_rty_i, dcpu_err_i, dcpu_tag_i,
	sb_en, dmmu_en, dc_no_writethrough,

	// SR Interface
	boot_adr_sel_i,

	// Interrupt & tick exceptions
	sig_int, sig_tick,

	// SPR interface
	supv, spr_addr, spr_dat_cpu, spr_dat_pic, spr_dat_tt, spr_dat_pm,
	spr_dat_dmmu, spr_dat_immu, spr_dat_du, spr_cs, spr_we, mtspr_dc_done
);

parameter dw =   32;
parameter aw =  5;
parameter boot_adr =  32'h00000100;

//
// I/O ports
//

//
// Clk & Rst
//
input 				clk;
input 				rst;

//
// Insn (IC) interface
//
output				ic_en;
output	[31:0]			icpu_adr_o;
output				icpu_cycstb_o;
output	[3:0]			icpu_sel_o;
output	[3:0]			icpu_tag_o;
input	[31:0]			icpu_dat_i;
input				icpu_ack_i;
input				icpu_rty_i;
input				icpu_err_i;
input	[31:0]			icpu_adr_i;
input	[3:0]			icpu_tag_i;

//
// Insn (IMMU) interface
//
output				immu_en;

//
// Debug interface
//
output                          id_void;
output	[31:0]			id_insn;
output                          ex_void;
output	[31:0]			ex_insn;
output				ex_freeze;
output	[31:0]			wb_insn;
output				wb_freeze;
output	[31:0]			id_pc;
output	[31:0]			ex_pc;
output	[31:0]			wb_pc;
output                          ex_flushpipe;
output	[  3-1:0]	branch_op;

input				du_stall;
input	[dw-1:0]		du_addr;
input	[dw-1:0]		du_dat_du;
input				du_read;
input				du_write;
input	[ 14-1:0]	du_dsr;
input	[24:0]			du_dmr1;
input				du_hwbkpt;
input				du_hwbkpt_ls_r;
output	[13:0]			du_except_trig;
output	[13:0]			du_except_stop;
output	[dw-1:0]		du_dat_cpu;
output	[dw-1:0]		rf_dataw;
output	[dw-1:0]		du_lsu_store_dat;
output	[dw-1:0]		du_lsu_load_dat;
input				du_flush_pipe;

//
// Data (DC) interface
//
output	[31:0]			dcpu_adr_o;
output				dcpu_cycstb_o;
output				dcpu_we_o;
output	[3:0]			dcpu_sel_o;
output	[3:0]			dcpu_tag_o;
output	[31:0]			dcpu_dat_o;
input	[31:0]			dcpu_dat_i;
input				dcpu_ack_i;
input				dcpu_rty_i;
input				dcpu_err_i;
input	[3:0]			dcpu_tag_i;
output				dc_en;
output  			dc_no_writethrough;
   
//
// Data (DMMU) interface
//
output				sb_en;
output				dmmu_en;
output				abort_ex;
output				abort_mvspr;

//
// SR Interface 
//
input				boot_adr_sel_i;

//
// SPR interface
//
output				supv;
input	[dw-1:0]		spr_dat_pic;
input	[dw-1:0]		spr_dat_tt;
input	[dw-1:0]		spr_dat_pm;
input	[dw-1:0]		spr_dat_dmmu;
input	[dw-1:0]		spr_dat_immu;
input	[dw-1:0]		spr_dat_du;
output	[dw-1:0]		spr_addr;
output	[dw-1:0]		spr_dat_cpu;
output	[dw-1:0]		spr_dat_npc;
output	[31:0]			spr_cs;
output				spr_we;
input   			mtspr_dc_done;
   
//
// Interrupt exceptions
//
input				sig_int;
input				sig_tick;

//
// Internal wires
//
wire	[31:0]			if_insn;
wire				saving_if_insn;
wire	[31:0]			if_pc;
wire	[aw-1:0]		rf_addrw;
wire	[aw-1:0] 		rf_addra;
wire	[aw-1:0] 		rf_addrb;
wire				rf_rda;
wire				rf_rdb;
wire	[dw-1:0]		id_simm;
wire	[dw-1:2]		id_branch_addrtarget;
wire	[dw-1:2]		ex_branch_addrtarget;
wire	[ 5-1:0]	alu_op;
wire	[ 4-1:0]	alu_op2;
wire	[ 4-1:0]	comp_op;
wire	[  3-1:0]	pre_branch_op;
wire	[  3-1:0]	branch_op;
wire	[  4-1:0]	id_lsu_op;
wire				genpc_freeze;
wire				if_freeze;
wire				id_freeze;
wire				ex_freeze;
wire				wb_freeze;
wire	[  2-1:0]	sel_a;
wire	[  2-1:0]	sel_b;
wire	[  4-1:0]	rfwb_op;
wire    [ 8-1:0]       fpu_op;
wire	[dw-1:0]		rf_dataw;
wire	[dw-1:0]		rf_dataa;
wire	[dw-1:0]		rf_datab;
wire	[dw-1:0]		muxed_a;
wire	[dw-1:0]		muxed_b;
wire	[dw-1:0]		wb_forw;
wire				wbforw_valid;
wire	[dw-1:0]		operand_a;
wire	[dw-1:0]		operand_b;
wire	[dw-1:0]		alu_dataout;
wire	[dw-1:0]		lsu_dataout;
wire	[dw-1:0]		sprs_dataout;
wire	[dw-1:0]		fpu_dataout;
wire     			fpu_done;
wire	[31:0]			ex_simm;
wire	[ 3-1:0]	multicycle;
wire    [ 2-1:0]	wait_on;      
wire	[ 4-1:0]	except_type;
wire	[4:0]			cust5_op;
wire	[5:0]			cust5_limm;
wire				if_flushpipe;
wire				id_flushpipe;
wire				ex_flushpipe;
wire				wb_flushpipe;
wire				extend_flush;
wire				ex_branch_taken;
wire				flag;
wire				flagforw;
wire				flag_we;
wire				flagforw_alu;   
wire				flag_we_alu;
wire				flagforw_fpu;
wire				flag_we_fpu;
wire				carry;
wire				cyforw;
wire				cy_we_alu;
wire				ovforw;
wire				ov_we_alu;
wire				ovforw_mult_mac;
wire				ov_we_mult_mac;   
wire				cy_we_rf;
wire				lsu_stall;
wire				epcr_we;
wire				eear_we;
wire				esr_we;
wire				pc_we;
wire	[31:0]			epcr;
wire	[31:0]			eear;
wire	[ 17-1:0]	esr;
wire 	[ 12-1:0]       fpcsr;
wire 				fpcsr_we;   
wire				sr_we;
wire	[ 17-1:0]	to_sr;
wire	[ 17-1:0]	sr;
wire    			dsx;
wire				except_flushpipe;
wire				except_start;
wire				except_started;
wire    			fpu_except_started;   
wire	[31:0]			wb_insn;
wire				sig_syscall;
wire				sig_trap;
wire    			sig_range;
wire				sig_fp;
wire	[31:0]			spr_dat_cfgr;
wire	[31:0]			spr_dat_rf;
wire    [31:0]                  spr_dat_npc;
wire	[31:0]			spr_dat_ppc;
wire	[31:0]			spr_dat_mac;
wire [31:0] 			spr_dat_fpu;
wire     			mtspr_done;
wire				force_dslot_fetch;
wire				no_more_dslot;
wire				ex_void;
wire				ex_spr_read;
wire				ex_spr_write;
wire				if_stall;
wire				id_macrc_op;
wire				ex_macrc_op;
wire	[ 3-1:0] id_mac_op;
wire	[ 3-1:0] mac_op;
wire	[31:0]			mult_mac_result;
wire				mult_mac_stall;
wire	[13:0]			except_trig;
wire	[13:0]			except_stop;
wire				genpc_refetch;
wire				rfe;
wire				lsu_unstall;
wire				except_align;
wire				except_dtlbmiss;
wire				except_dmmufault;
wire				except_illegal;
wire				except_itlbmiss;
wire				except_immufault;
wire				except_ibuserr;
wire				except_dbuserr;
wire				abort_ex;
wire				abort_mvspr;

//
// Send exceptions to Debug Unit
//
assign du_except_trig = except_trig;
assign du_except_stop = except_stop;
assign du_lsu_store_dat = operand_b;
assign du_lsu_load_dat  = lsu_dataout;

//
// Data cache enable
//
                   
                    
     
   assign dc_en = sr[  3];
      

//
// Instruction cache enable
//
                   
                    
     
assign ic_en = sr[  4];
      

//
// SB enable
//
                            
                                                              
     
assign sb_en = 1'b0;
      

//
// DMMU enable
//
                     
                      
     
assign dmmu_en = sr[  5];
      

//
// IMMU enable
//
                     
                      
     
assign immu_en = sr[  6] & ~except_started;
      

//
// SUPV bit
//
assign supv = sr[   0];

//
// FLAG write enable
//
assign flagforw = (flag_we_alu & flagforw_alu) | (flagforw_fpu & flag_we_fpu);
assign flag_we = (flag_we_alu | flag_we_fpu) & ~abort_mvspr;

//
// Flag for any MTSPR instructions, that must block execution, to indicate done
//
assign mtspr_done = mtspr_dc_done;

//
// Range exception
//
assign sig_range = sr[   11 ];
   
   
   
//
// Instantiation of instruction fetch block
//
or1200_genpc #(.boot_adr(boot_adr)) or1200_genpc(
	.clk(clk),
	.rst(rst),
	.icpu_adr_o(icpu_adr_o),
	.icpu_cycstb_o(icpu_cycstb_o),
	.icpu_sel_o(icpu_sel_o),
	.icpu_tag_o(icpu_tag_o),
	.icpu_rty_i(icpu_rty_i),
	.icpu_adr_i(icpu_adr_i),

	.pre_branch_op(pre_branch_op),
	.branch_op(branch_op),
	.except_type(except_type),
	.except_start(except_start),
	.except_prefix(sr[  14]),
	.id_branch_addrtarget(id_branch_addrtarget),
	.ex_branch_addrtarget(ex_branch_addrtarget),
	.muxed_b(muxed_b),
	.operand_b(operand_b),
	.flag(flag),
	.flagforw(flagforw),
	.ex_branch_taken(ex_branch_taken),
	.epcr(epcr),
	.spr_dat_i(spr_dat_cpu),
	.spr_pc_we(pc_we),
	.genpc_refetch(genpc_refetch),
	.genpc_freeze(genpc_freeze),
	.no_more_dslot(no_more_dslot),
	.lsu_stall(lsu_stall),
	.du_flush_pipe(du_flush_pipe),
	.spr_dat_npc(spr_dat_npc)
);

//
// Instantiation of instruction fetch block
//
or1200_if or1200_if(
	.clk(clk),
	.rst(rst),
	.icpu_dat_i(icpu_dat_i),
	.icpu_ack_i(icpu_ack_i),
	.icpu_err_i(icpu_err_i),
	.icpu_adr_i(icpu_adr_i),
	.icpu_tag_i(icpu_tag_i),

	.if_freeze(if_freeze),
	.if_insn(if_insn),
	.if_pc(if_pc),
	.saving_if_insn(saving_if_insn),
	.if_flushpipe(if_flushpipe),
	.if_stall(if_stall),
	.no_more_dslot(no_more_dslot),
	.genpc_refetch(genpc_refetch),
	.rfe(rfe),
	.except_itlbmiss(except_itlbmiss),
	.except_immufault(except_immufault),
	.except_ibuserr(except_ibuserr)
);

//
// Instantiation of instruction decode/control logic
//
or1200_ctrl or1200_ctrl(
	.clk(clk),
	.rst(rst),
	.id_freeze(id_freeze),
	.ex_freeze(ex_freeze),
	.wb_freeze(wb_freeze),
	.if_flushpipe(if_flushpipe),
	.id_flushpipe(id_flushpipe),
	.ex_flushpipe(ex_flushpipe),
	.wb_flushpipe(wb_flushpipe),
	.extend_flush(extend_flush),
	.except_flushpipe(except_flushpipe),
	.abort_mvspr(abort_mvspr),
	.if_insn(if_insn),
	.id_insn(id_insn),
	.ex_insn(ex_insn),
	.id_branch_op(pre_branch_op),
	.ex_branch_op(branch_op),
	.ex_branch_taken(ex_branch_taken),
	.rf_addra(rf_addra),
	.rf_addrb(rf_addrb),
	.rf_rda(rf_rda),
	.rf_rdb(rf_rdb),
	.alu_op(alu_op),
	.alu_op2(alu_op2),			
	.mac_op(mac_op),
	.comp_op(comp_op),
	.rf_addrw(rf_addrw),
	.rfwb_op(rfwb_op),
	.fpu_op(fpu_op),			
	.pc_we(pc_we),
	.wb_insn(wb_insn),
	.id_simm(id_simm),
	.id_branch_addrtarget(id_branch_addrtarget),
	.ex_branch_addrtarget(ex_branch_addrtarget),
	.ex_simm(ex_simm),
	.sel_a(sel_a),
	.sel_b(sel_b),
	.id_lsu_op(id_lsu_op),
	.cust5_op(cust5_op),
	.cust5_limm(cust5_limm),
	.id_pc(id_pc),
	.ex_pc(ex_pc),
	.multicycle(multicycle),
        .wait_on(wait_on),			
	.wbforw_valid(wbforw_valid),
	.sig_syscall(sig_syscall),
	.sig_trap(sig_trap),
	.force_dslot_fetch(force_dslot_fetch),
	.no_more_dslot(no_more_dslot),
	.id_void(id_void),
	.ex_void(ex_void),
	.ex_spr_read(ex_spr_read),
	.ex_spr_write(ex_spr_write),
	.id_mac_op(id_mac_op),
	.id_macrc_op(id_macrc_op),
	.ex_macrc_op(ex_macrc_op),
	.rfe(rfe),
	.du_hwbkpt(du_hwbkpt),
	.except_illegal(except_illegal),
	.dc_no_writethrough(dc_no_writethrough),
	.du_flush_pipe(du_flush_pipe)
);

//
// Instantiation of register file
//
or1200_rf or1200_rf(
	.clk(clk),
	.rst(rst),
	.cy_we_i(cy_we_alu),
	.cy_we_o(cy_we_rf),
	.supv(sr[   0]),
	.wb_freeze(wb_freeze),
	.addrw(rf_addrw),
	.dataw(rf_dataw),
	.id_freeze(id_freeze),
	.we(rfwb_op[0]),
	.flushpipe(wb_flushpipe),
	.addra(rf_addra),
	.rda(rf_rda),
	.dataa(rf_dataa),
	.addrb(rf_addrb),
	.rdb(rf_rdb),
	.datab(rf_datab),
	.spr_cs(spr_cs[ 5'd00]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_rf),
	.du_read(du_read)
);

//
// Instantiation of operand muxes
//
or1200_operandmuxes or1200_operandmuxes(
	.clk(clk),
	.rst(rst),
	.id_freeze(id_freeze),
	.ex_freeze(ex_freeze),
	.rf_dataa(rf_dataa),
	.rf_datab(rf_datab),
	.ex_forw(rf_dataw),
	.wb_forw(wb_forw),
	.simm(id_simm),
	.sel_a(sel_a),
	.sel_b(sel_b),
	.operand_a(operand_a),
	.operand_b(operand_b),
	.muxed_a(muxed_a),
	.muxed_b(muxed_b)
);

//
// Instantiation of CPU's ALU
//
or1200_alu or1200_alu(
	.a(operand_a),
	.b(operand_b),
	.mult_mac_result(mult_mac_result),
	.macrc_op(ex_macrc_op),
	.alu_op(alu_op),
	.alu_op2(alu_op2),		      
	.comp_op(comp_op),
	.cust5_op(cust5_op),
	.cust5_limm(cust5_limm),
	.result(alu_dataout),
	.flagforw(flagforw_alu),
	.flag_we(flag_we_alu),
	.cyforw(cyforw),
	.cy_we(cy_we_alu),
	.ovforw(ovforw),
	.ov_we(ov_we_alu),		      
	.flag(flag),
	.carry(carry)
);

   
//
// FPU's exception is being dealt with
//    
assign fpu_except_started = except_started && (except_type ==    4'hd);
   
//
// Instantiation of FPU
//
or1200_fpu or1200_fpu(
	.clk(clk),
	.rst(rst),
	.ex_freeze(ex_freeze),
	.a(operand_a),
	.b(operand_b),
	.fpu_op(fpu_op),
	.result(fpu_dataout),
	.done(fpu_done),
	.flagforw(flagforw_fpu),
	.flag_we(flag_we_fpu),
        .sig_fp(sig_fp),
	.except_started(fpu_except_started),
	.fpcsr_we(fpcsr_we),
	.fpcsr(fpcsr),		      
	.spr_cs(spr_cs[    5'd11]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_fpu)
);

   
//
// Instantiation of CPU's multiply unit
//
or1200_mult_mac or1200_mult_mac(
	.clk(clk),
	.rst(rst),
	.ex_freeze(ex_freeze),
	.id_macrc_op(id_macrc_op),
	.macrc_op(ex_macrc_op),
	.a(operand_a),
	.b(operand_b),
	.mac_op(mac_op),
	.alu_op(alu_op),
	.result(mult_mac_result),
	.ovforw(ovforw_mult_mac), 
	.ov_we(ov_we_mult_mac),
	.mult_mac_stall(mult_mac_stall),
	.spr_cs(spr_cs[ 5'd05]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_mac)
);

//
// Instantiation of CPU's SPRS block
//
or1200_sprs or1200_sprs(
	.clk(clk),
	.rst(rst),
	.addrbase(operand_a),
	.addrofs(ex_simm[15:0]),
	.dat_i(operand_b),
	.ex_spr_read(ex_spr_read),
	.ex_spr_write(ex_spr_write),
	.flagforw(flagforw),
	.flag_we(flag_we),
	.flag(flag),
	.cyforw(cyforw),
	.cy_we(cy_we_rf),
	.carry(carry),
	.ovforw(ovforw | ovforw_mult_mac),
	.ov_we(ov_we_alu | ov_we_mult_mac),
	.to_wbmux(sprs_dataout),

	.du_addr(du_addr),
	.du_dat_du(du_dat_du),
	.du_read(du_read),
	.du_write(du_write),
	.du_dat_cpu(du_dat_cpu),
	.boot_adr_sel_i(boot_adr_sel_i),
	.spr_addr(spr_addr),
	.spr_dat_pic(spr_dat_pic),
	.spr_dat_tt(spr_dat_tt),
	.spr_dat_pm(spr_dat_pm),
	.spr_dat_cfgr(spr_dat_cfgr),
	.spr_dat_rf(spr_dat_rf),
	.spr_dat_npc(spr_dat_npc),
        .spr_dat_ppc(spr_dat_ppc),
	.spr_dat_mac(spr_dat_mac),
	.spr_dat_dmmu(spr_dat_dmmu),
	.spr_dat_immu(spr_dat_immu),
	.spr_dat_du(spr_dat_du),
	.spr_dat_o(spr_dat_cpu),
	.spr_cs(spr_cs),
	.spr_we(spr_we),

	.epcr_we(epcr_we),
	.eear_we(eear_we),
	.esr_we(esr_we),
	.pc_we(pc_we),
	.epcr(epcr),
	.eear(eear),
	.esr(esr),
	.except_started(except_started),

	.fpcsr(fpcsr),
	.fpcsr_we(fpcsr_we),			
	.spr_dat_fpu(spr_dat_fpu),
			
	.sr_we(sr_we),
	.to_sr(to_sr),
	.sr(sr),
	.branch_op(branch_op),
	.dsx(dsx)
);

//
// Instantiation of load/store unit
//
or1200_lsu or1200_lsu(
	.clk(clk),
	.rst(rst),
	.id_addrbase(muxed_a),
	.id_addrofs(id_simm),
	.ex_addrbase(operand_a),
	.ex_addrofs(ex_simm),
	.id_lsu_op(id_lsu_op),
	.lsu_datain(operand_b),
	.lsu_dataout(lsu_dataout),
	.lsu_stall(lsu_stall),
	.lsu_unstall(lsu_unstall),
	.du_stall(du_stall),
	.except_align(except_align),
	.except_dtlbmiss(except_dtlbmiss),
	.except_dmmufault(except_dmmufault),
	.except_dbuserr(except_dbuserr),
	.id_freeze(id_freeze),
	.ex_freeze(ex_freeze),
	.flushpipe(ex_flushpipe),

	.dcpu_adr_o(dcpu_adr_o),
	.dcpu_cycstb_o(dcpu_cycstb_o),
	.dcpu_we_o(dcpu_we_o),
	.dcpu_sel_o(dcpu_sel_o),
	.dcpu_tag_o(dcpu_tag_o),
	.dcpu_dat_o(dcpu_dat_o),
	.dcpu_dat_i(dcpu_dat_i),
	.dcpu_ack_i(dcpu_ack_i),
	.dcpu_rty_i(dcpu_rty_i),
	.dcpu_err_i(dcpu_err_i),
	.dcpu_tag_i(dcpu_tag_i)
);

//
// Instantiation of write-back muxes
//
or1200_wbmux or1200_wbmux(
	.clk(clk),
	.rst(rst),
	.wb_freeze(wb_freeze),
	.rfwb_op(rfwb_op),
	.muxin_a(alu_dataout),
	.muxin_b(lsu_dataout),
	.muxin_c(sprs_dataout),
	.muxin_d(ex_pc),
        .muxin_e(fpu_dataout),
	.muxout(rf_dataw),
	.muxreg(wb_forw),
	.muxreg_valid(wbforw_valid)
);

//
// Instantiation of freeze logic
//
or1200_freeze or1200_freeze(
	.clk(clk),
	.rst(rst),
	.multicycle(multicycle),
        .wait_on(wait_on),
	.fpu_done(fpu_done),
	.mtspr_done(mtspr_done),
	.flushpipe(wb_flushpipe),
	.extend_flush(extend_flush),
	.lsu_stall(lsu_stall),
	.if_stall(if_stall),
	.lsu_unstall(lsu_unstall),
	.force_dslot_fetch(force_dslot_fetch),
	.abort_ex(abort_ex),
	.du_stall(du_stall),
	.mac_stall(mult_mac_stall),
	.saving_if_insn(saving_if_insn),
	.genpc_freeze(genpc_freeze),
	.if_freeze(if_freeze),
	.id_freeze(id_freeze),
	.ex_freeze(ex_freeze),
	.wb_freeze(wb_freeze),
	.icpu_ack_i(icpu_ack_i),
	.icpu_err_i(icpu_err_i)
);

//
// Instantiation of exception block
//
or1200_except or1200_except(
	.clk(clk),
	.rst(rst),
	.sig_ibuserr(except_ibuserr),
	.sig_dbuserr(except_dbuserr),
	.sig_illegal(except_illegal),
	.sig_align(except_align),
	.sig_range(sig_range),
	.sig_dtlbmiss(except_dtlbmiss),
	.sig_dmmufault(except_dmmufault),
	.sig_int(sig_int),
	.sig_syscall(sig_syscall),
	.sig_trap(sig_trap),
	.sig_itlbmiss(except_itlbmiss),
	.sig_immufault(except_immufault),
	.sig_tick(sig_tick),
	.sig_fp(sig_fp),
	.fpcsr_fpee(fpcsr[  0]),
	.ex_branch_taken(ex_branch_taken),
	.icpu_ack_i(icpu_ack_i),
	.icpu_err_i(icpu_err_i),
	.dcpu_ack_i(dcpu_ack_i),
	.dcpu_err_i(dcpu_err_i),
	.genpc_freeze(genpc_freeze),
        .id_freeze(id_freeze),
        .ex_freeze(ex_freeze),
        .wb_freeze(wb_freeze),
	.if_stall(if_stall),
	.if_pc(if_pc),
	.id_pc(id_pc),
	.ex_pc(ex_pc),
	.wb_pc(wb_pc),
	.id_flushpipe(id_flushpipe),
	.ex_flushpipe(ex_flushpipe),
	.extend_flush(extend_flush),
	.except_flushpipe(except_flushpipe),
	.abort_mvspr(abort_mvspr),
	.except_type(except_type),
	.except_start(except_start),
	.except_started(except_started),
	.except_stop(except_stop),
	.except_trig(except_trig),
	.ex_void(ex_void),
	.spr_dat_ppc(spr_dat_ppc),
	.spr_dat_npc(spr_dat_npc),

	.datain(spr_dat_cpu),
	.branch_op(branch_op),
	.du_dsr(du_dsr),
	.du_dmr1(du_dmr1),
	.du_hwbkpt(du_hwbkpt),
	.du_hwbkpt_ls_r(du_hwbkpt_ls_r),
	.epcr_we(epcr_we),
	.eear_we(eear_we),
	.esr_we(esr_we),
	.pc_we(pc_we),
        .epcr(epcr),
	.eear(eear),
	.esr(esr),

	.lsu_addr(dcpu_adr_o),
	.sr_we(sr_we),
	.to_sr(to_sr),
	.sr(sr),
	.abort_ex(abort_ex),
	.dsx(dsx)
);

//
// Instantiation of configuration registers
//
or1200_cfgr or1200_cfgr(
	.spr_addr(spr_addr),
	.spr_dat_o(spr_dat_cfgr)
);

endmodule

`line 1 "../../rtl/verilog/or1200_ctrl.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Instruction decode                                 ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Majority of instruction decoding is performed here.         ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_ctrl.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_ctrl.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_ctrl.v" 2

module or1200_ctrl
  (
   // Clock and reset
   clk, rst,
   
   // Internal i/f
   except_flushpipe, extend_flush, if_flushpipe, id_flushpipe, ex_flushpipe, 
   wb_flushpipe,
   id_freeze, ex_freeze, wb_freeze, if_insn, id_insn, ex_insn, abort_mvspr, 
   id_branch_op, ex_branch_op, ex_branch_taken, pc_we, 
   rf_addra, rf_addrb, rf_rda, rf_rdb, alu_op, alu_op2, mac_op,
   comp_op, rf_addrw, rfwb_op, fpu_op,
   wb_insn, id_simm, ex_simm, id_branch_addrtarget, ex_branch_addrtarget, sel_a,
   sel_b, id_lsu_op,
   cust5_op, cust5_limm, id_pc, ex_pc, du_hwbkpt, 
   multicycle, wait_on, wbforw_valid, sig_syscall, sig_trap,
   force_dslot_fetch, no_more_dslot, id_void, ex_void, ex_spr_read, 
   ex_spr_write, du_flush_pipe,
   id_mac_op, id_macrc_op, ex_macrc_op, rfe, except_illegal, dc_no_writethrough
   );

//
// I/O
//
input					clk;
input					rst;
input					id_freeze;
input					ex_freeze /* verilator public */;
input					wb_freeze /* verilator public */;
output					if_flushpipe;
output					id_flushpipe;
output					ex_flushpipe;
output					wb_flushpipe;
input					extend_flush;
input					except_flushpipe;
input                           abort_mvspr ;
input	[31:0]			if_insn;
output	[31:0]			id_insn;
output	[31:0]			ex_insn /* verilator public */;
output	[  3-1:0]		ex_branch_op;
output	[  3-1:0]		id_branch_op;
input						ex_branch_taken;
output	[ 5-1:0]	rf_addrw;
output	[ 5-1:0]	rf_addra;
output	[ 5-1:0]	rf_addrb;
output					rf_rda;
output					rf_rdb;
output	[ 5-1:0]		alu_op;
output [ 4-1:0] 		alu_op2;
output	[ 3-1:0]		mac_op;
output	[  4-1:0]		rfwb_op;
output  [ 8-1:0] 		fpu_op;      
input					pc_we;
output	[31:0]				wb_insn;
output	[31:2]				id_branch_addrtarget;
output	[31:2]				ex_branch_addrtarget;
output	[  2-1:0]		sel_a;
output	[  2-1:0]		sel_b;
output	[  4-1:0]		id_lsu_op;
output	[ 4-1:0]		comp_op;
output	[ 3-1:0]		multicycle;
output  [ 2-1:0] 		wait_on;   
output	[4:0]				cust5_op;
output	[5:0]				cust5_limm;
input   [31:0]                          id_pc;
input   [31:0]                          ex_pc;
output	[31:0]				id_simm;
output	[31:0]				ex_simm;
input					wbforw_valid;
input					du_hwbkpt;
output					sig_syscall;
output					sig_trap;
output					force_dslot_fetch;
output					no_more_dslot;
output					id_void;
output					ex_void;
output					ex_spr_read;
output					ex_spr_write;
output	[ 3-1:0]	id_mac_op;
output					id_macrc_op;
output					ex_macrc_op;
output					rfe;
output					except_illegal;
output  				dc_no_writethrough;
input					du_flush_pipe;

//
// Internal wires and regs
//
reg	[  3-1:0]		id_branch_op;
reg	[  3-1:0]		ex_branch_op;
reg	[ 5-1:0]		alu_op;
reg [ 4-1:0]      		alu_op2;
wire					if_maci_op;
                             
                                         
                                         
                                       
                    
     
wire	[ 3-1:0]		mac_op;
wire					ex_macrc_op;
      
reg	[31:0]				id_insn /* verilator public */;
reg	[31:0]				ex_insn /* verilator public */;
reg	[31:0]				wb_insn /* verilator public */;
reg	[ 5-1:0]	rf_addrw;
reg	[ 5-1:0]	wb_rfaddrw;
reg	[  4-1:0]		rfwb_op;
reg	[  2-1:0]		sel_a;
reg	[  2-1:0]		sel_b;
reg					sel_imm;
reg	[  4-1:0]		id_lsu_op;
reg	[ 4-1:0]		comp_op;
reg	[ 3-1:0]		multicycle;
reg     [ 2-1:0] 		wait_on;      
reg 	[31:0]				id_simm;
reg 	[31:0]				ex_simm;
reg					sig_syscall;
reg					sig_trap;
reg					except_illegal;
wire					id_void;
wire					ex_void;
wire                                    wb_void;
reg                                     ex_delayslot_dsi;
reg                                     ex_delayslot_nop;
reg					spr_read;
reg					spr_write;
reg     [31:2]				ex_branch_addrtarget;
                                    
                            
      
   
//
// Register file read addresses
//
assign rf_addra = if_insn[20:16];
assign rf_addrb = if_insn[15:11];
assign rf_rda = if_insn[31] || if_maci_op;
assign rf_rdb = if_insn[30];

//
// Force fetch of delay slot instruction when jump/branch is preceeded by 
// load/store instructions
//
assign force_dslot_fetch = 1'b0;
assign no_more_dslot = (|ex_branch_op & !id_void & ex_branch_taken) | 
		       (ex_branch_op ==   3'd6);

assign id_void = (id_insn[31:26] ==                6'b000101) & id_insn[16];
assign ex_void = (ex_insn[31:26] ==                6'b000101) & ex_insn[16];
assign wb_void = (wb_insn[31:26] ==                6'b000101) & wb_insn[16];

assign ex_spr_write = spr_write && !abort_mvspr;
assign ex_spr_read = spr_read && !abort_mvspr;

//
// ex_delayslot_dsi: delay slot insn is in EX stage
// ex_delayslot_nop: (filler) nop insn is in EX stage (before nops 
//                   jump/branch was executed)
//
//  ex_delayslot_dsi & !ex_delayslot_nop - DS insn in EX stage
//  !ex_delayslot_dsi & ex_delayslot_nop - NOP insn in EX stage, 
//       next different is DS insn, previous different was Jump/Branch
//  !ex_delayslot_dsi & !ex_delayslot_nop - normal insn in EX stage
//
always @(posedge clk or       posedge rst) begin
        if (rst ==       (1'b1)) begin
		ex_delayslot_nop <=  1'b0;
		ex_delayslot_dsi <=  1'b0;
	end
	else if (!ex_freeze & !ex_delayslot_dsi & ex_delayslot_nop) begin
		ex_delayslot_nop <=  id_void;
		ex_delayslot_dsi <=  !id_void;
	end
	else if (!ex_freeze & ex_delayslot_dsi & !ex_delayslot_nop) begin
		ex_delayslot_nop <=  1'b0;
		ex_delayslot_dsi <=  1'b0;
	end
	else if (!ex_freeze) begin
		ex_delayslot_nop <=  id_void && ex_branch_taken && 
				     (ex_branch_op !=   3'd0) && 
				     (ex_branch_op !=   3'd6);
	        ex_delayslot_dsi <=  !id_void && ex_branch_taken && 
				     (ex_branch_op !=   3'd0) && 
				     (ex_branch_op !=   3'd6);
	end
end

//
// Flush pipeline
//
assign if_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign id_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign ex_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;
assign wb_flushpipe = except_flushpipe | pc_we | extend_flush | du_flush_pipe;

//
// EX Sign/Zero extension of immediates
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		ex_simm <=  32'h0000_0000;
	else if (!ex_freeze) begin
		ex_simm <=  id_simm;
	end
end

//
// ID Sign/Zero extension of immediate
//
always @(id_insn) begin
	case (id_insn[31:26])     // synopsys parallel_case

	// l.addi
	              6'b100111:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.addic
	             6'b101000:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.lxx (load instructions)
	               6'b100001,                6'b100010,
                  6'b100011,                6'b100100,
	               6'b100101,                6'b100110:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.muli
	                              
	              6'b101100:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};
	      

	// l.maci
	                             
                   
                                               
       

	// l.mtspr
	             6'b110000:
		id_simm = {16'b0, id_insn[25:21], id_insn[10:0]};

	// l.sxx (store instructions)
	                6'b110101,                 6'b110111,                 6'b110110:
		id_simm = {{16{id_insn[25]}}, id_insn[25:21], id_insn[10:0]};

	// l.xori
	              6'b101011:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// l.sfxxi (SFXX with immediate)
	             6'b101111:
		id_simm = {{16{id_insn[15]}}, id_insn[15:0]};

	// Instructions with no or zero extended immediate
	default:
		id_simm = {{16'b0}, id_insn[15:0]};

	endcase
end

//
// ID Sign extension of branch offset
//
assign id_branch_addrtarget = {{4{id_insn[25]}}, id_insn[25:0]} + id_pc[31:2];

//
// EX Sign extension of branch offset
//

// pipeline ID and EX branch target address 
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		ex_branch_addrtarget <=  0;
	else if (!ex_freeze) 
		ex_branch_addrtarget <=  id_branch_addrtarget;
end
// not pipelined
//assign ex_branch_addrtarget = {{4{ex_insn[25]}}, ex_insn[25:0]} + ex_pc[31:2];

//
// l.maci in IF stage
//
                             
                                                          
     
assign if_maci_op = 1'b0;
      

//
// l.macrc in ID stage
//
                             
                                                                          
     
assign id_macrc_op = 1'b0;
      

//
// l.macrc in EX stage
//
                             
                                                    
                              
                       
                                                
                       
                     
                              
   
     
assign ex_macrc_op = 1'b0;
      

//
// cust5_op, cust5_limm (L immediate)
//
assign cust5_op = ex_insn[4:0];
assign cust5_limm = ex_insn[10:5];

//
//
//
assign rfe = (id_branch_op ==   3'd6) | 
	     (ex_branch_op ==   3'd6);

   
                
                                                                        
                                                                       
                
                               
                         
                            
                             

                                                                        
                                                                       
                
                               
                         
                            
                             

                                                                        
                                                                       
                
                               
                         
                            
                             
   
      

   
//
// Generation of sel_a
//
always @(rf_addrw or id_insn or rfwb_op or wbforw_valid or wb_rfaddrw)
	if ((id_insn[20:16] == rf_addrw) && rfwb_op[0])
		sel_a =   2'd2;
	else if ((id_insn[20:16] == wb_rfaddrw) && wbforw_valid)
		sel_a =   2'd3;
	else
		sel_a =    2'd0;

//
// Generation of sel_b
//
always @(rf_addrw or sel_imm or id_insn or rfwb_op or wbforw_valid or 
	 wb_rfaddrw)
	if (sel_imm)
		sel_b =    2'd1;
	else if ((id_insn[15:11] == rf_addrw) && rfwb_op[0])
		sel_b =   2'd2;
	else if ((id_insn[15:11] == wb_rfaddrw) && wbforw_valid)
		sel_b =   2'd3;
	else
		sel_b =    2'd0;

//
// Decode of multicycle
//
always @(id_insn) begin
  case (id_insn[31:26])		// synopsys parallel_case
    // l.rfe
                   6'b001001,
    // l.mfspr
                 6'b101101:
      multicycle =   3'd1;	// to read from ITLB/DTLB (sync RAMs)
    // Single cycle instructions
    default: begin
      multicycle =   3'd0;
    end    
  endcase
end // always @ (id_insn)

//
// Encode wait_on signal
//    
always @(id_insn) begin
   case (id_insn[31:26])		// synopsys parallel_case
                    6'b111000: 
       wait_on =  ( 1'b0
                             
                     | (id_insn[4:0] ==  5'b0_1001 )
		     | (id_insn[4:0] ==  5'b0_1010 )
      
                              
		     | (id_insn[4:0] ==  5'b0_0110 )
		     | (id_insn[4:0] ==  5'b0_1011 )
      
		    ) ?      2'd1 :      2'd0;
                              
                             
                         
                       
      
                   6'b101100:       
	 wait_on =      2'd1;
      
                             
                        
                                                           
                                           
      		   
                             
                                
                                                                        
          
      
                             
     // l.mtspr
                  6'b110000: begin
	wait_on =        2'd3;
     end
      
     default: begin
	wait_on =      2'd0;
     end
   endcase // case (id_insn[31:26])
end // always @ (id_insn)
   
   
   
   
//
// Register file write address
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		rf_addrw <=  5'd0;
	else if (!ex_freeze & id_freeze)
		rf_addrw <=  5'd00;
	else if (!ex_freeze)
		case (id_insn[31:26])	// synopsys parallel_case
			               6'b000001,               6'b010010:
				rf_addrw <=  5'd09;	// link register r9
			default:
				rf_addrw <=  id_insn[25:21];
		endcase
end

//
// rf_addrw in wb stage (used in forwarding logic)
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		wb_rfaddrw <=  5'd0;
	else if (!wb_freeze)
		wb_rfaddrw <=  rf_addrw;
end

//
// Instruction latch in id_insn
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		id_insn <=  {               6'b000101, 26'h041_0000};
        else if (id_flushpipe)
                id_insn <=  {               6'b000101, 26'h041_0000};        // NOP -> id_insn[16] must be 1
	else if (!id_freeze) begin
		id_insn <=  if_insn;
                     
                         
                                                
                        
      
	end
end

//
// Instruction latch in ex_insn
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		ex_insn <=  {               6'b000101, 26'h041_0000};
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_insn <=  {               6'b000101, 26'h041_0000};	// NOP -> ex_insn[16] must be 1
	else if (!ex_freeze) begin
		ex_insn <=  id_insn;
                     
                         
                                                
                        
      
	end
end
   
//
// Instruction latch in wb_insn
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		wb_insn <=  {               6'b000101, 26'h041_0000};
	// wb_insn should not be changed by exceptions due to correct 
	// recording of display_arch_state in the or1200_monitor! 
	// wb_insn changed by exception is not used elsewhere! 
	else if (!wb_freeze) begin
		wb_insn <=  ex_insn;
	end
end

//
// Decode of sel_imm
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		sel_imm <=  1'b0;
	else if (!id_freeze) begin
	  case (if_insn[31:26])		// synopsys parallel_case

	    // j.jalr
	                  6'b010010:
	      sel_imm <=  1'b0;
	    
	    // l.jr
	                    6'b010001:
	      sel_imm <=  1'b0;
	    
	    // l.rfe
	                   6'b001001:
	      sel_imm <=  1'b0;
	    
	    // l.mfspr
	                 6'b101101:
	      sel_imm <=  1'b0;
	    
	    // l.mtspr
	                 6'b110000:
	      sel_imm <=  1'b0;
	    
	    // l.sys, l.brk and all three sync insns
	                 6'b001000:
	      sel_imm <=  1'b0;
	    
	    // l.mac/l.msb
                             
                         
                        
      

	    // l.sw
	                    6'b110101:
	      sel_imm <=  1'b0;
	    
	    // l.sb
	                    6'b110110:
	      sel_imm <=  1'b0;
	    
	    // l.sh
	                    6'b110111:
	      sel_imm <=  1'b0;
	    
	    // ALU instructions except the one with immediate
	                   6'b111000:
	      sel_imm <=  1'b0;
	    
	    // SFXX instructions
	                  6'b111001:
	      sel_imm <=  1'b0;

                            
                            
                        
                        
      
                             
                        
                        
                        
      
	    // l.nop
	                   6'b000101:
	      sel_imm <=  1'b0;

	    // All instructions with immediates
	    default: begin
	      sel_imm <=  1'b1;
	    end
	    
	  endcase
	  
	end
end

//
// Decode of except_illegal
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		except_illegal <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		except_illegal <=  1'b0;
	else if (!ex_freeze) begin
		case (id_insn[31:26])		// synopsys parallel_case

		                 6'b000000,
		               6'b000001,
		              6'b010010,
		                6'b010001,
		               6'b000011,
		                6'b000100,
		               6'b001001,
		             6'b000110,
		             6'b101101,
		             6'b001000,
                             
                    
      
		               6'b100001,
		               6'b100010,
		               6'b100011,
		               6'b100100,
		               6'b100101,
		               6'b100110,
		              6'b100111,
		             6'b101000,
		              6'b101001,
		               6'b101010,
		              6'b101011,
                              
		              6'b101100,
      
                                 
                       
      
		             6'b101111,
		             6'b110000,
                             
                      
      
		                6'b110101,
		                6'b110110,
		                6'b110111,
		              6'b111001,
                            
                     
      
	               6'b000101:
		except_illegal <=  1'b0;
                             
                        
                                                                
                                                                     
      	      

	               6'b111000:
		except_illegal <=  1'b0 

                              
                             
      
                                       
                                        
      
     
                                       
                                        
                                       
      

                       
     
                                        
      

                           
     
                                        
      

                             
     
		| ((id_insn[4:0] ==  5'b0_1000 ) &
		   (id_insn[9:6] ==  4'd3))
      

                      
     
                                       
      
                          
     
                                         
                                        
      
		;

		// Illegal and OR1200 unsupported instructions
	default:
		except_illegal <=  1'b1;

	endcase
	end // if (!ex_freeze)
end
   

//
// Decode of alu_op
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		alu_op <=   5'b0_0100;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		alu_op <=   5'b0_0100;
	else if (!ex_freeze) begin
	  case (id_insn[31:26])		// synopsys parallel_case
	    
	    // l.movhi
	                 6'b000110:
	      alu_op <=        5'b1_0001 ;
	    
	    // l.addi
	                  6'b100111:
	      alu_op <=   5'b0_0000 ;
	    
	    // l.addic
	                 6'b101000:
	      alu_op <=   5'b0_0001 ;
	    
	    // l.andi
	                  6'b101001:
	      alu_op <=   5'b0_0011 ;
	    
	    // l.ori
	                   6'b101010:
	      alu_op <=    5'b0_0100 ;
	    
	    // l.xori
	                  6'b101011:
	      alu_op <=   5'b0_0101 ;
	    
	    // l.muli
                              
	                  6'b101100:
	      alu_op <=   5'b0_0110 ;
      
                                  
                                             
                          
                                      
        
	    // SFXX insns with immediate
	                 6'b101111:
	      alu_op <=         5'b1_0000 ;
	    
	    // ALU instructions except the one with immediate
	                   6'b111000:
	      alu_op <=  {1'b0,id_insn[3:0]};
	    
	    // SFXX instructions
	                  6'b111001:
	      alu_op <=         5'b1_0000 ;
                                 
               
                        
                                      
      	    
	    // Default
	    default: begin
	      alu_op <=   5'b0_0100;
	    end
	      
	  endcase
	  
	end
end


//
// Decode of second ALU operation field [9:6]
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		alu_op2 <=  0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
	        alu_op2 <= 0;
   	else if (!ex_freeze) begin
		alu_op2 <=  id_insn[ 9:6];
	end
end

//
// Decode of spr_read, spr_write
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		spr_read <=  1'b0;
		spr_write <=  1'b0;
	end
	else if (!ex_freeze & id_freeze | ex_flushpipe) begin
		spr_read <=  1'b0;
		spr_write <=  1'b0;
	end
	else if (!ex_freeze) begin
		case (id_insn[31:26])     // synopsys parallel_case

		// l.mfspr
		             6'b101101: begin
			spr_read <=  1'b1;
			spr_write <=  1'b0;
		end

		// l.mtspr
		             6'b110000: begin
			spr_read <=  1'b0;
			spr_write <=  1'b1;
		end

		// Default
		default: begin
			spr_read <=  1'b0;
			spr_write <=  1'b0;
		end

		endcase
	end
end

//
// Decode of mac_op
//
                             
                       
                                                 

          
                   
                                 

                
                     
                            

                                               
         
                                 

        
   

                                                    
                              
                                  
                                                
                                  
                     
                          
   

                                                            
     
assign id_mac_op =  3'b000;
assign mac_op =  3'b000;
      


//
// Decode of rfwb_op
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		rfwb_op <=    4'b0000;
	else  if (!ex_freeze & id_freeze | ex_flushpipe)
		rfwb_op <=    4'b0000;
	else  if (!ex_freeze) begin
		case (id_insn[31:26])		// synopsys parallel_case

		// j.jal
		               6'b000001:
			rfwb_op <=  {  3'b011, 1'b1};
		  
		// j.jalr
		              6'b010010:
			rfwb_op <=  {  3'b011, 1'b1};
		  
		// l.movhi
		             6'b000110:
			rfwb_op <=  {  3'b000, 1'b1};
		  
		// l.mfspr
		             6'b101101:
			rfwb_op <=  {  3'b010, 1'b1};
		  
		// l.lwz
		               6'b100001:
			rfwb_op <=  {  3'b001, 1'b1};

		// l.lws
		               6'b100010:
			rfwb_op <=  {  3'b001, 1'b1};

		// l.lbz
		               6'b100011:
			rfwb_op <=  {  3'b001, 1'b1};
		  
		// l.lbs
		               6'b100100:
			rfwb_op <=  {  3'b001, 1'b1};
		  
		// l.lhz
		               6'b100101:
			rfwb_op <=  {  3'b001, 1'b1};
		  
		// l.lhs
		               6'b100110:
			rfwb_op <=  {  3'b001, 1'b1};
		  
		// l.addi
		              6'b100111:
			rfwb_op <=  {  3'b000, 1'b1};
		  
		// l.addic
		             6'b101000:
			rfwb_op <=  {  3'b000, 1'b1};
		  
		// l.andi
		              6'b101001:
			rfwb_op <=  {  3'b000, 1'b1};
		  
		// l.ori
		               6'b101010:
			rfwb_op <=  {  3'b000, 1'b1};
		  
		// l.xori
		              6'b101011:
			rfwb_op <=  {  3'b000, 1'b1};
		  
		// l.muli
                              
		              6'b101100:
			rfwb_op <=  {  3'b000, 1'b1};
      
		  
		// Shift and rotate insns with immediate
                             
                       
                                          
      
		// ALU instructions except the one with immediate
		               6'b111000:
			rfwb_op <=  {  3'b000, 1'b1};

                            
                         
                     
                                          
      
                             
                                              
                       
                                                   
      
		// Instructions w/o register-file write-back
		default: 
			rfwb_op <=    4'b0000;


		endcase
	end
end

//
// Decode of id_branch_op
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		id_branch_op <=    3'd0;
	else if (id_flushpipe)
		id_branch_op <=    3'd0;
	else if (!id_freeze) begin
		case (if_insn[31:26])		// synopsys parallel_case

		// l.j
		                 6'b000000:
			id_branch_op <=    3'd1;
		  
		// j.jal
		               6'b000001:
			id_branch_op <=    3'd1;
		  
		// j.jalr
		              6'b010010:
			id_branch_op <=    3'd2;
		  
		// l.jr
		                6'b010001:
			id_branch_op <=    3'd2;
		  
		// l.bnf
		               6'b000011:
			id_branch_op <=    3'd5;
		  
		// l.bf
		                6'b000100:
			id_branch_op <=    3'd4;
		  
		// l.rfe
		               6'b001001:
			id_branch_op <=    3'd6;
		  
		// Non branch instructions
		default:
			id_branch_op <=    3'd0;

		endcase
	end
end

//
// Generation of ex_branch_op
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		ex_branch_op <=    3'd0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		ex_branch_op <=    3'd0;		
	else if (!ex_freeze)
		ex_branch_op <=  id_branch_op;

//
// Decode of id_lsu_op
//
always @(id_insn) begin
	case (id_insn[31:26])		// synopsys parallel_case

	// l.lwz
	               6'b100001:
		id_lsu_op =    4'b0110;

	// l.lws
	               6'b100010:
		id_lsu_op =    4'b0111;

	// l.lbz
	               6'b100011:
		id_lsu_op =    4'b0010;

	// l.lbs
	               6'b100100:
		id_lsu_op =    4'b0011;

	// l.lhz
	               6'b100101:
		id_lsu_op =    4'b0100;

	// l.lhs
	               6'b100110:
		id_lsu_op =    4'b0101;

	// l.sw
	                6'b110101:
		id_lsu_op =     4'b1110;

	// l.sb
	                6'b110110:
		id_lsu_op =     4'b1010;

	// l.sh
	                6'b110111:
		id_lsu_op =     4'b1100;

	// Non load/store instructions
	default:
		id_lsu_op =    4'b0000;

	endcase
end

//
// Decode of comp_op
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		comp_op <=  4'd0;
	end else if (!ex_freeze & id_freeze | ex_flushpipe)
		comp_op <=  4'd0;
	else if (!ex_freeze)
		comp_op <=  id_insn[24:21];
end

                             
  
                    
  
                                                            
                                        
     
   assign fpu_op = { 8{1'b0}};
      

   
//
// Decode of l.sys
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		sig_syscall <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		sig_syscall <=  1'b0;
	else if (!ex_freeze) begin
                     
                         
                                                     
                                      
                        
      
		sig_syscall <=  (id_insn[31:23] == {             6'b001000, 3'b000});
	end
end

//
// Decode of l.trap
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1))
		sig_trap <=  1'b0;
	else if (!ex_freeze & id_freeze | ex_flushpipe)
		sig_trap <=  1'b0;
	else if (!ex_freeze) begin
                     
                         
                                                     
                                   
                        
      
		sig_trap <=  (id_insn[31:23] == {             6'b001000, 3'b010})
			| du_hwbkpt;
	end
end

// Decode destination register address for data cache to check if store ops
// are being done from the stack register (r1) or frame pointer register (r2)
                                       
                                                    
                                
                             
                       
                                                                               
   
     
   
   assign dc_no_writethrough = 0;
  
            
   
endmodule

`line 1 "../../rtl/verilog/or1200_dc_fsm.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's DC FSM                                             ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Data cache state machine                                    ////
////                                                              ////
////  To Do:                                                      ////
////   - Test error during line read or write                     ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////      - Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000, 2010 Authors and OPENCORES.ORG           ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_dc_fsm.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 52 "../../rtl/verilog/or1200_dc_fsm.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 53 "../../rtl/verilog/or1200_dc_fsm.v" 2

                              
                                    
                               
                               
                               
                                
                              
                                    



//
// Data cache FSM for cache line of 16 bytes (4x singleword)
//

module or1200_dc_fsm
  (
   // Clock and reset
   clk, rst,
   
   // Internal i/f to top level DC
   dc_en, dcqmem_cycstb_i, dcqmem_ci_i, dcqmem_we_i, dcqmem_sel_i,
   tagcomp_miss, biudata_valid, biudata_error, lsu_addr,
   dcram_we, biu_read, biu_write, biu_do_sel, dcram_di_sel, first_hit_ack, 
   first_miss_ack, first_miss_err, burst, tag_we, tag_valid, dc_addr, 
   dc_no_writethrough, tag_dirty, dirty, tag, tag_v, dc_block_flush, 
   dc_block_writeback, spr_dat_i, mtspr_dc_done, spr_cswe
   );

   //
   // I/O
   //
   input				clk;
   input				rst;
   input				dc_en;
   input				dcqmem_cycstb_i;
   input				dcqmem_ci_i;
   input				dcqmem_we_i;
   input [3:0] 				dcqmem_sel_i;
   input				tagcomp_miss;
   input				biudata_valid;
   input				biudata_error;
   input [31:0] 			lsu_addr;
   output [3:0] 			dcram_we;
   output				biu_read;
   output				biu_write;
   output 				dcram_di_sel;
   output 				biu_do_sel;
   output				first_hit_ack;
   output				first_miss_ack;
   output				first_miss_err;
   output				burst;
   output				tag_we;
   output 				tag_valid;
   output [31:0] 			dc_addr;
   input 				dc_no_writethrough;
   output 				tag_dirty;
   input 				dirty;
   input [   20-2:0] 		tag;
   input 				tag_v;   
   input 				dc_block_flush;
   input 				dc_block_writeback;
   input [31:0] 			spr_dat_i;
   output 				mtspr_dc_done;
   input 				spr_cswe;
   
   
   //
   // Internal wires and regs
   //
   reg [31:0] 				addr_r;
   reg [2:0] 				state;
   reg [  4-1:0] 		cnt;
   reg 					hitmiss_eval;
   reg 					store;
   reg 					load;
   reg 					cache_inhibit;
   reg 					cache_miss;
   reg 					cache_dirty_needs_writeback;
   reg                                  did_early_load_ack;
   reg 					cache_spr_block_flush;
   reg 					cache_spr_block_writeback;
   reg 					cache_wb;   
   wire 				load_hit_ack;
   wire 				load_miss_ack;
   wire 				load_inhibit_ack;   
   wire 				store_hit_ack;
   wire 				store_hit_writethrough_ack;   
   wire 				store_miss_writethrough_ack;   
   wire 				store_inhibit_ack;
   wire 				store_miss_ack;
   wire 				dcram_we_after_line_load;
   wire 				dcram_we_during_line_load;
   wire 				tagram_we_end_of_loadstore_loop;
   wire 				tagram_dirty_bit_set;   
   wire 				writethrough;
   wire 				cache_inhibit_with_eval;
   wire [(  4-1)-2:0]		next_addr_word;

   //
   // Cache inhibit
   //
   
   // Indicates whether cache is inhibited, during hitmiss_eval and after
   assign cache_inhibit_with_eval = (hitmiss_eval & dcqmem_ci_i) |
				    (!hitmiss_eval & cache_inhibit);
   
   //
   // Generate of DCRAM write enables
   //

   // WE when non-writethrough, and had to wait for a line to load.
   assign dcram_we_after_line_load = (state ==  3'd3) &
				    dcqmem_we_i & !cache_dirty_needs_writeback &
				     !did_early_load_ack;

   // WE when receiving the data cache line
   assign dcram_we_during_line_load = (state ==  3'd2) & load & 
				      biudata_valid;   
   
   assign dcram_we =(// Write when hit - make sure it is only when hit - could
		     // maybe be doing write through and don't want to corrupt
		     // cache lines corresponding to the writethrough addr_r.
		     ({4{store_hit_ack | store_hit_writethrough_ack}} |
		     // Write after load of line
		     {4{dcram_we_after_line_load}}) & 
		     dcqmem_sel_i		 ) |
		    // Write during load
		    {4{dcram_we_during_line_load}};

   //
   // Tag RAM signals
   //
   
   // WE to tag RAM when we finish loading a line.
   assign tagram_we_end_of_loadstore_loop = ((state== 3'd2) & 
					     biudata_valid & !(|cnt));
   
                              
                                                                   
                                                                

                                                                          
                                                                         
                         
                                                           
                                      
                                                        
                                      
                                     
                                                           
                                         
                                                           
   
   
     
                                        
                                                                      
                                                                
      
   // Lines will never be dirty if always writethrough
   assign tagram_dirty_bit_set = 0;
       
   
   assign mtspr_dc_done = 1'b1;
   
      

   assign tag_dirty = tagram_dirty_bit_set;
   
   // WE to tag RAM
   assign tag_we = tagram_we_end_of_loadstore_loop |		    
                    tagram_dirty_bit_set | (state ==  3'd6);
   

   // Valid bit
   // Set valid when end of line load, or marking dirty (is still valid)
   assign tag_valid = ( tagram_we_end_of_loadstore_loop & 
			(load | (store & cache_spr_block_writeback)) ) |
		      tagram_dirty_bit_set;


   
   //
   // BIU read and write
   //

   assign biu_read = // Bus read request when:
		     // 1) Have a miss and not dirty or a load with inhibit
		     ((state ==  3'd1) &
		      (((hitmiss_eval & tagcomp_miss & !dirty & 
			 !(store & writethrough)) | 
			(load & cache_inhibit_with_eval)) & dcqmem_cycstb_i)) |
		     // 2) In the loop and loading
		     ((state ==  3'd2) & load);
   

   assign biu_write = // Bus write request when:
		      // 1) Have a miss and dirty or store with inhibit
		      ((state ==  3'd1) & 
		       (((hitmiss_eval & tagcomp_miss & dirty) | 
			 (store & writethrough)) | 
			(store & cache_inhibit_with_eval)) & dcqmem_cycstb_i) |
		      // 2) In the loop and storing
		      ((state ==  3'd2) & store);
   
   //
   // Select for data to actual cache RAM (from LSU or BIU)
   //
   // Data to DCRAM - from external bus when loading (from IU when store)
   assign dcram_di_sel = load;
   // Data to external bus - always from IU except in case of bursting back
   //                        the line to memory. (1 selects DCRAM)
   assign biu_do_sel = (state ==  3'd2) & store;

   // 3-bit wire for calculating next word of burst write, depending on
   // line size of data cache.
   assign next_addr_word =  addr_r[  4-1:2] + 1;
   
   // Address to cache RAM (tag address also derived from this)   
   assign dc_addr =
		   // First check if we've got a block flush or WB op
		   ((dc_block_flush & !cache_spr_block_flush) | 
		   (dc_block_writeback & !cache_spr_block_writeback)) ? 
		   spr_dat_i :
		   (state== 3'd5) ? addr_r:
		    // If no SPR action, then always put out address from LSU
		    (state== 3'd0 | hitmiss_eval) ? lsu_addr :
		    // Next, if in writeback loop, when ACKed must immediately
		    // output next word address (the RAM address takes a cycle
		    // to increment, but it's needed immediately for burst)
		    // otherwise, output our registered address.
		    (state== 3'd2 & biudata_valid & store ) ? 
		    {addr_r[31:  4], next_addr_word, 2'b00} : addr_r;
   
                             
                                        
                                             
      
   assign writethrough = 1;
       
     
                           
      
   
   //
   // ACK generation for LSU
   //
   
   // ACK for when it's a cache hit
   assign first_hit_ack = load_hit_ack | store_hit_ack | 
			  store_hit_writethrough_ack | 
			  store_miss_writethrough_ack |
			  store_inhibit_ack | store_miss_ack ;

   // ACK for when it's a cache miss - load only, is used in MUX for data back
   //                                  LSU straight off external data bus. In
   //                                  this was is also used for cache inhibit
   //                                  loads.
   // first_hit_ack takes precedence over first_miss_ack
   assign first_miss_ack = ~first_hit_ack & (load_miss_ack | load_inhibit_ack);
   
   // ACK cache hit on load
   assign load_hit_ack = (state ==  3'd1) & 
			 hitmiss_eval & !tagcomp_miss & !dcqmem_ci_i & load;
   
   // ACK cache hit on store, no writethrough
   assign store_hit_ack = (state ==  3'd1) & 
			  hitmiss_eval  & !tagcomp_miss & !dcqmem_ci_i &
			  store & !writethrough;
   
   // ACK cache hit on store with writethrough
   assign store_hit_writethrough_ack = (state ==  3'd1) & 
				       !cache_miss & !cache_inhibit &
				       store & writethrough & biudata_valid;
   
   // ACK cache miss on store with writethrough
   assign store_miss_writethrough_ack = (state ==  3'd1) & 
					cache_miss & !cache_inhibit &
					store & writethrough & biudata_valid;
      
   // ACK store when cacheinhibit
   assign store_inhibit_ack = (state ==  3'd1) &
			      store & cache_inhibit & biudata_valid;
   
   
   // Get the _early_ ack on first ACK back from wishbone during load only
   // Condition is that we're in the loop - that it's the first ack we get (can
   // tell from value of cnt), and we're loading a line to read from it (not
   // loading to write to it, in the case of a write without writethrough.)
   assign load_miss_ack =  ((state==  3'd2) & load &
			    (cnt==((1 <<   4) - 4)) & biudata_valid & 
			    !(dcqmem_we_i & !writethrough));
   
   assign load_inhibit_ack = (state ==  3'd1) &
			     load & cache_inhibit & biudata_valid;   
   
   // This will be case of write through disabled, and had to load a line.
   assign store_miss_ack = dcram_we_after_line_load;
            
   assign first_miss_err = biudata_error & dcqmem_cycstb_i;

   // Signal burst when in the load/store loop. We will always try to burst.
   assign burst = (state ==  3'd2);

   //
   // Main DC FSM
   //
   always @(posedge clk or       posedge rst) begin
      if (rst ==       (1'b1)) begin
	 state <=   3'd0;
	 addr_r <=  32'd0;
	 hitmiss_eval <=  1'b0;
	 store <=  1'b0;
	 load <=  1'b0;
	 cnt <=    4'd0;
         cache_miss <=  1'b0;
	 cache_dirty_needs_writeback <= 1'b0;
	 cache_inhibit <=  1'b0;
	 did_early_load_ack <= 1'b0;
	 cache_spr_block_flush <= 1'b0;
	 cache_spr_block_writeback <= 1'b0;
      end
      else
	case (state)	// synopsys parallel_case
	  
           3'd0 : begin
	     if (dc_en & (dc_block_flush | dc_block_writeback))
	       begin
		  cache_spr_block_flush <= dc_block_flush;
		  cache_spr_block_writeback <= dc_block_writeback;
		  hitmiss_eval <= 1'b1;
		  state <=  3'd5;
		  addr_r <=  spr_dat_i;
	       end
	     else if (dc_en & dcqmem_cycstb_i)
	       begin
		  state <=  3'd1;
		  hitmiss_eval <=  1'b1;
		  store <=  dcqmem_we_i;
		  load <=  !dcqmem_we_i;
	       end
	     
	     
          end // case: `OR1200_DCFSM_IDLE
	  
           3'd1: begin
	     hitmiss_eval <=  1'b0;
	     if (hitmiss_eval) begin
                cache_inhibit <=  dcqmem_ci_i; // Check for cache inhibit here
                cache_miss <=  tagcomp_miss;
		cache_dirty_needs_writeback <= dirty;
		addr_r <=  lsu_addr;
             end

	     // Evaluate any cache line load/stores in first cycle:
			     //
	     if (hitmiss_eval & tagcomp_miss & !(store & writethrough) &
		 !dcqmem_ci_i)
	       begin
		  // Miss - first either:
		  //  1) write back dirty line 
		  if (dirty) begin
		     // Address for writeback
		     addr_r <=  {tag, lsu_addr[      13   -1 :2],2'd0};
		     load <= 1'b0;
		     store <= 1'b1;
                            
                                                    
      
		  end
		  //  2) load requested line
		  else begin
		     addr_r <=  lsu_addr;
		     load <= 1'b1;
		     store <= 1'b0;
		  end // else: !if(dirty)
		  state <=  3'd2;		  
		  // Set the counter for the burst accesses
		  cnt <=  ((1 <<   4) - 4);
	       end
             else if (// Strobe goes low
		      !dcqmem_cycstb_i |
		      // Cycle finishes
		      (!hitmiss_eval & (biudata_valid | biudata_error)) |
		      // Cache hit in first cycle....
		      (hitmiss_eval & !tagcomp_miss & !dcqmem_ci_i &
		      // .. and you're not doing a writethrough store..
		      !(store & writethrough))) begin
                state <=   3'd0;
                load <=  1'b0;
		store <= 1'b0;
		cache_inhibit <= 1'b0;
		cache_dirty_needs_writeback <= 1'b0;
             end	     
          end // case: `OR1200_DCFSM_CLOADSTORE	  
	  
           3'd2 : begin // loop/abort	     
             if (!dc_en| biudata_error) begin
                state <=   3'd0;
                load <=  1'b0;
		store <= 1'b0;
		cnt <=   4'd0;
             end
             if (biudata_valid & (|cnt)) begin
                cnt <=  cnt - 4;
                addr_r[  4-1:2] <=  addr_r[  4-1:2] + 1;
             end
	     else if (biudata_valid & !(|cnt)) begin
		state <=  3'd3;
		addr_r <=  lsu_addr;
		load <= 1'b0;
		store <= 1'b0;
	     end

	     // Track if we did an early ack during a load
	     if (load_miss_ack)
	       did_early_load_ack <= 1'b1;
	     

          end // case: `OR1200_DCFSM_LOOP2
	  
	   3'd3: begin // figure out next step
	     if (cache_dirty_needs_writeback) begin
		// Just did store of the dirty line so now load new one
		load <= 1'b1;
		// Set the counter for the burst accesses
		cnt <=  ((1 <<   4) - 4);
		// Address of line to be loaded
		addr_r <=  lsu_addr;
		cache_dirty_needs_writeback <= 1'b0;
		state <=  3'd2;
	     end // if (cache_dirty_needs_writeback)
	     else if (cache_spr_block_flush | cache_spr_block_writeback) begin
		// Just wrote back the line to memory, we're finished.
		cache_spr_block_flush <= 1'b0;
		cache_spr_block_writeback <= 1'b0;
		state <=  3'd7;
	     end
	     else begin
		// Just loaded a new line, finish up
		did_early_load_ack <= 1'b0;
		state <=  3'd4;
	     end
	  end // case: `OR1200_DCFSM_LOOP3

	   3'd4: begin
	     state <=   3'd0;
	  end

	   3'd5: begin
	     hitmiss_eval <= 1'b0;
	     if (hitmiss_eval & !tag_v)
	       begin
		  // Not even cached, just ignore
		  cache_spr_block_flush <= 1'b0;
		  cache_spr_block_writeback <= 1'b0;
		  state <=   3'd7;
	       end
	     else if (hitmiss_eval & tag_v)
	       begin
		  // Tag is valid - what do we do?
		  if ((cache_spr_block_flush | cache_spr_block_writeback) & 
		      dirty) begin
		     // Need to writeback
		     // Address for writeback (spr_dat_i has already changed so
		     // use line number from addr_r)
		     addr_r <=  {tag, addr_r[      13   -1 :2],2'd0};
		     load <= 1'b0;
		     store <= 1'b1;
                            
                                                       
      
		     state <=  3'd2;		  
		     // Set the counter for the burst accesses
		     cnt <=  ((1 <<   4) - 4);
		  end
		  else if (cache_spr_block_flush & !dirty)
		    begin
		       // Line not dirty, just need to invalidate
		       state <=   3'd6;
		    end // else: !if(dirty)
		  else if (cache_spr_block_writeback & !dirty)
		    begin
		       // Nothing to do - line is valid but not dirty
		       cache_spr_block_writeback <= 1'b0;
		       state <=   3'd7;
		    end
	  end // if (hitmiss_eval & tag_v)
	  end
	   3'd6: begin
	     cache_spr_block_flush <= 1'b0;
	     // Wait until SPR CS goes low before going back to idle
	     if (!spr_cswe)
	       state <=   3'd0;
	  end
	   3'd7: begin
	     // Wait until SPR CS goes low before going back to idle
	     if (!spr_cswe)
	       state <=   3'd0;
	  end

	endcase // case (state)
      
   end // always @ (posedge clk or `OR1200_RST_EVENT rst)
   

endmodule

`line 1 "../../rtl/verilog/or1200_dc_ram.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's DC RAMs                                            ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Instatiation of DC RAM blocks.                              ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_dc_ram.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 52 "../../rtl/verilog/or1200_dc_ram.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 53 "../../rtl/verilog/or1200_dc_ram.v" 2

module or1200_dc_ram(
	// Reset and clock
	clk, rst,

                  
            
                                      
      

	// Internal i/f
	addr, en, we, datain, dataout
);

parameter dw =   32;
parameter aw =       13   -2 ;

//
// I/O
//
input				clk;
input				rst;
input	[aw-1:0]		addr;
input				en;
input	[3:0]			we;
input	[dw-1:0]		datain;
output	[dw-1:0]		dataout;

                  
  
           
  
                    
                                                                                      
                     
      

                   

  
                             
  
                            
                  
                               
      

     

//
// Instantiation of RAM block
//
   or1200_spram_32_bw #
     (
      .aw(      13   -2 ),
      .dw(dw)
      )
   dc_ram
     (
                  
                 
                              
                              
                                  
      
      .clk(clk),
      .ce(en),
      .we(we),
      .addr(addr),
      .di(datain),
      .doq(dataout)
      );
      

endmodule // or1200_dc_ram

`line 1 "../../rtl/verilog/or1200_dc_tag.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's DC TAG RAMs                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Instatiation of data cache tag rams.                        ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_dc_tag.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_dc_tag.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_dc_tag.v" 2

module or1200_dc_tag(
	// Clock and reset
	clk, rst,

                  
            
                                      
      

	// Internal i/f
	addr, en, we, datain, tag_v, tag, dirty
);

parameter dw =    20+1;
parameter aw =       13   -  4 ;

//
// I/O
//
input				clk;
input				rst;
input	[aw-1:0]		addr;
input				en;
input				we;
input	[dw-1:0]		datain;
output				tag_v;
output	[dw-3:0]		tag;
output  			dirty;
   

                  
  
           
  
                 
                                                    
                  
      

                   

  
                             
  
                          
                    
                  
                               
      

     

//
// Instantiation of TAG RAM block
//
// Data widths are tag width plus one for valid
   or1200_spram #
     (
      .aw(      13   -  4 ),
      .dw(   20 + 1)
      )
   dc_tag0
     (
                  
                 
                              
                              
                                  
      
      .clk(clk),
      .ce(en),
      .we(we),
      .addr(addr),
      .di(datain),
      .doq({tag, tag_v, dirty})
      );
      

endmodule // or1200_dc_tag

`line 1 "../../rtl/verilog/or1200_dc_top.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Data Cache top level                               ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of all DC blocks.                             ////
////                                                              ////
////  To Do:                                                      ////
////   - Test error during line read or write                     ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////      - Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000, 2010 Authors and OPENCORES.ORG           ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_dc_top.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 53 "../../rtl/verilog/or1200_dc_top.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 54 "../../rtl/verilog/or1200_dc_top.v" 2

//
// Data cache
//
module or1200_dc_top(
	// Rst, clk and clock control
	clk, rst,

	// External i/f
	dcsb_dat_o, dcsb_adr_o, dcsb_cyc_o, dcsb_stb_o, dcsb_we_o, dcsb_sel_o, 
	dcsb_cab_o, dcsb_dat_i, dcsb_ack_i, dcsb_err_i,

	// Internal i/f
	dc_en,
	dcqmem_adr_i, dcqmem_cycstb_i, dcqmem_ci_i,
	dcqmem_we_i, dcqmem_sel_i, dcqmem_tag_i, dcqmem_dat_i,
	dcqmem_dat_o, dcqmem_ack_o, dcqmem_rty_o, dcqmem_err_o, dcqmem_tag_o,
	
        dc_no_writethrough,

                  
            
                                      
      

	// SPRs
	spr_cs, spr_write, spr_dat_i, spr_addr, mtspr_dc_done
);

parameter dw =   32;
parameter aw =   32;
   
//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// External I/F
//
output	[dw-1:0]		dcsb_dat_o;
output	[31:0]			dcsb_adr_o;
output				dcsb_cyc_o;
output				dcsb_stb_o;
output				dcsb_we_o;
output	[3:0]			dcsb_sel_o;
output				dcsb_cab_o;
input	[dw-1:0]		dcsb_dat_i;
input				dcsb_ack_i;
input				dcsb_err_i;

//
// Internal I/F
//
input				dc_en;
input	[31:0]			dcqmem_adr_i;
input				dcqmem_cycstb_i;
input				dcqmem_ci_i;
input				dcqmem_we_i;
input	[3:0]			dcqmem_sel_i;
input	[3:0]			dcqmem_tag_i;
input	[dw-1:0]		dcqmem_dat_i;
output	[dw-1:0]		dcqmem_dat_o;
output				dcqmem_ack_o;
output				dcqmem_rty_o;
output				dcqmem_err_o;
output	[3:0]			dcqmem_tag_o;

input   			dc_no_writethrough;
   
                  
  
           
  
                 
                                                    
                  
      

//
// SPR access
//
input				spr_cs;
input				spr_write;
input	[31:0]			spr_dat_i;
input	[aw-1:0]	        spr_addr;
output  			mtspr_dc_done;

                   

               

                        
                                 
                                 
                                    
                                    
                               
                                 
                         

                        
                                 
                                 
                                    
                                    
                                                                    

                            

        
   
//
// Internal wires and regs
//
wire				tag_v;
wire	[   20-2:0]	tag;
wire    			dirty;   
wire	[dw-1:0]		to_dcram;
wire	[dw-1:0]		from_dcram;
wire	[3:0]			dcram_we;
wire				dctag_we;
wire	[31:0]			dc_addr;
wire				dcfsm_biu_read;
wire				dcfsm_biu_write;
wire                            dcfsm_dcram_di_sel;
wire                            dcfsm_biu_do_sel;   
reg				tagcomp_miss;
wire	[      13   -1 :  4]	dctag_addr;
wire				dctag_en;
wire				dctag_v;
wire    			dctag_dirty;
   
wire				dc_block_invalidate;
wire 			        dc_block_flush;
wire 			        dc_block_writeback;   
wire				dcfsm_first_hit_ack;
wire				dcfsm_first_miss_ack;
wire				dcfsm_first_miss_err;
wire				dcfsm_burst;
wire				dcfsm_tag_we;
wire    			dcfsm_tag_valid;
wire    			dcfsm_tag_dirty;
   
                  
  
           
  
                     
                     
                                  
                                    
                                    
      

// Address out to external bus - always from FSM   
assign dcsb_adr_o = dc_addr;
//
// SPR register decodes
//
                             
assign dc_block_invalidate = spr_cs & spr_write & 
       ((spr_addr[ 3-1:0]==  3'd3) |
	(spr_addr[ 3-1:0]==  3'd2));
assign dc_block_flush = 0;
assign dc_block_writeback = 0;
        
                                                  
                                                                        
                                               
                                                                         
                                                   
                                                                         
       // !`ifdef OR1200_DC_WRITETHROUGH
   
assign dctag_we = dcfsm_tag_we | dc_block_invalidate;
assign dctag_addr = dc_block_invalidate ? 
		    spr_dat_i[      13   -1 :  4] :
		    dc_addr[      13   -1 :  4];
assign dctag_en = dc_block_invalidate | dc_en;

assign dctag_v = dc_block_invalidate ? 1'b0 : dcfsm_tag_valid;
assign dctag_dirty = dc_block_invalidate ? 1'b0 : dcfsm_tag_dirty;
   
//
// Data to BIU is from DCRAM when bursting lines back into memory
//
assign dcsb_dat_o = dcfsm_biu_do_sel ? from_dcram : dcqmem_dat_i;


//
// Bypases of the DC when DC is disabled
//
assign dcsb_cyc_o = (dc_en) ? 
		    dcfsm_biu_read | dcfsm_biu_write : dcqmem_cycstb_i;
   
assign dcsb_stb_o = (dc_en) ? 
		    dcfsm_biu_read | dcfsm_biu_write : dcqmem_cycstb_i;
   
assign dcsb_we_o = (dc_en) ? 
		   dcfsm_biu_write : dcqmem_we_i;

assign dcsb_sel_o = (dc_en & dcfsm_burst) ? 
		    4'b1111 : dcqmem_sel_i;

assign dcsb_cab_o = dc_en & dcfsm_burst & dcsb_cyc_o;
assign dcqmem_rty_o = ~dcqmem_ack_o;
assign dcqmem_tag_o = dcqmem_err_o ?   4'hb  : dcqmem_tag_i;

//
// DC/LSU normal and error termination
//
assign dcqmem_ack_o = dc_en ? 
		      dcfsm_first_hit_ack | dcfsm_first_miss_ack : dcsb_ack_i;
   
assign dcqmem_err_o = dc_en ? dcfsm_first_miss_err : dcsb_err_i;
   
//
// Select between input data generated by LSU or by BIU
//
assign to_dcram = (dcfsm_dcram_di_sel) ? dcsb_dat_i : dcqmem_dat_i;

//
// Select between data generated by DCRAM or passed by BIU
//
assign dcqmem_dat_o = dcfsm_first_miss_ack | !dc_en ? dcsb_dat_i : from_dcram;

//
// Tag comparison
//
   wire [31:         13   -1 +1 ]  dcqmem_adr_i_tag;
   assign dcqmem_adr_i_tag = dcqmem_adr_i[31:         13   -1 +1 ];
   
always @(tag or dcqmem_adr_i_tag or tag_v) begin
	if ((tag != dcqmem_adr_i_tag) || !tag_v)
		tagcomp_miss = 1'b1;
	else
		tagcomp_miss = 1'b0;
end

//
// Instantiation of DC Finite State Machine
//
or1200_dc_fsm or1200_dc_fsm(
	.clk(clk),
	.rst(rst),
	.dc_en(dc_en),
	.dcqmem_cycstb_i(dcqmem_cycstb_i),
	.dcqmem_ci_i(dcqmem_ci_i),
	.dcqmem_we_i(dcqmem_we_i),
	.dcqmem_sel_i(dcqmem_sel_i),
	.tagcomp_miss(tagcomp_miss),
	.tag(tag),
        .tag_v(tag_v),
	.dirty(dirty),
	.biudata_valid(dcsb_ack_i),
	.biudata_error(dcsb_err_i),
	.lsu_addr(dcqmem_adr_i),
	.dcram_we(dcram_we),
	.biu_read(dcfsm_biu_read),
	.biu_write(dcfsm_biu_write),
	.dcram_di_sel(dcfsm_dcram_di_sel),
	.biu_do_sel(dcfsm_biu_do_sel),
	.first_hit_ack(dcfsm_first_hit_ack),
	.first_miss_ack(dcfsm_first_miss_ack),
	.first_miss_err(dcfsm_first_miss_err),
	.burst(dcfsm_burst),
	.tag_we(dcfsm_tag_we),
        .tag_valid(dcfsm_tag_valid),
	.tag_dirty(dcfsm_tag_dirty),
	.dc_addr(dc_addr),
	.dc_no_writethrough(dc_no_writethrough),
	.dc_block_flush(dc_block_flush),
	.dc_block_writeback(dc_block_writeback),
	.spr_dat_i(spr_dat_i),
	.mtspr_dc_done(mtspr_dc_done),
	.spr_cswe(spr_cs & spr_write)
);

//
// Instantiation of DC main memory
//
or1200_dc_ram or1200_dc_ram(
	.clk(clk),
	.rst(rst),
                  
            
                           
                           
                             
      
	.addr(dc_addr[      13   -1 :2]),
	.en(dc_en),
	.we(dcram_we),
	.datain(to_dcram),
	.dataout(from_dcram)
);

//
// Instantiation of DC TAG memory
//
or1200_dc_tag or1200_dc_tag(
	.clk(clk),
	.rst(rst),
                  
            
                           
                           
                             
      
	.addr(dctag_addr),
	.en(dctag_en),
	.we(dctag_we),
	.datain({dc_addr[31:         13   -1 +1 ], dctag_v, dctag_dirty}),
	.tag_v(tag_v),
	.tag(tag),
	.dirty(dirty)
);
       // !`ifdef OR1200_NO_DC
   
endmodule

`line 1 "../../rtl/verilog/or1200_defines.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 1 "../../rtl/verilog/or1200_dmmu_tlb.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Data TLB                                           ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of DTLB.                                      ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_dmmu_tlb.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed, coding style changed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 52 "../../rtl/verilog/or1200_dmmu_tlb.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 53 "../../rtl/verilog/or1200_dmmu_tlb.v" 2

//
// Data TLB
//

module or1200_dmmu_tlb(
	// Rst and clk
	clk, rst,

	// I/F for translation
	tlb_en, vaddr, hit, ppn, uwe, ure, swe, sre, ci,

                  
            
                                      
      

	// SPR access
	spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o
);

parameter dw =   32;
parameter aw =   32;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// I/F for translation
//
input				tlb_en;
input	[aw-1:0]		vaddr;
output				hit;
output	[31:  13     ]	ppn;
output				uwe;
output				ure;
output				swe;
output				sre;
output				ci;

                  
  
           
  
                 
                                                    
                  
      

//
// SPR access
//
input				spr_cs;
input				spr_write;
input	[31:0]			spr_addr;
input	[31:0]			spr_dat_i;
output	[31:0]			spr_dat_o;

//
// Internal wires and regs
//
wire	[  31:    13     + 6     -1 +1      ]	vpn;
wire				v;
wire	[ 6     -1:0]	tlb_index;
wire				tlb_mr_en;
wire				tlb_mr_we;
wire	[   32- 6     -  13      +1   -1:0]	tlb_mr_ram_in;
wire	[   32- 6     -  13      +1   -1:0]	tlb_mr_ram_out;
wire				tlb_tr_en;
wire				tlb_tr_we;
wire	[  32-  13     +5   -1:0]	tlb_tr_ram_in;
wire	[  32-  13     +5   -1:0]	tlb_tr_ram_out;
                  
  
           
  
                    
                    
                                 
                                  
                                   
      

//
// Implemented bits inside match and translate registers
//
// dtlbwYmrX: vpn 31-19  v 0
// dtlbwYtrX: ppn 31-13  swe 9  sre 8  uwe 7  ure 6
//
// dtlb memory width:
// 19 bits for ppn
// 13 bits for vpn
// 1 bit for valid
// 4 bits for protection
// 1 bit for cache inhibit

//
// Enable for Match registers
//
assign tlb_mr_en = tlb_en | (spr_cs & !spr_addr[ 7]);

//
// Write enable for Match registers
//
assign tlb_mr_we = spr_cs & spr_write & !spr_addr[ 7];

//
// Enable for Translate registers
//
assign tlb_tr_en = tlb_en | (spr_cs & spr_addr[ 7]);

//
// Write enable for Translate registers
//
assign tlb_tr_we = spr_cs & spr_write & spr_addr[ 7];

//
// Output to SPRS unit
//
assign spr_dat_o = (spr_cs & !spr_write & !spr_addr[ 7]) ?
			{vpn, tlb_index, { 32- 6     -  13      -7{1'b0}}, 1'b0, 5'b00000, v} : 
		(spr_cs & !spr_write & spr_addr[ 7]) ?
			{ppn, {  13     -10{1'b0}}, swe, sre, uwe, ure, {4{1'b0}}, ci, 1'b0} :
			32'h00000000;

//
// Assign outputs from Match registers
//
assign {vpn, v} = tlb_mr_ram_out;

//
// Assign to Match registers inputs
//
assign tlb_mr_ram_in = {spr_dat_i[  31:    13     + 6     -1 +1      ], spr_dat_i[ 0]};

//
// Assign outputs from Translate registers
//
assign {ppn, swe, sre, uwe, ure, ci} = tlb_tr_ram_out;

//
// Assign to Translate registers inputs
//
assign tlb_tr_ram_in = {spr_dat_i[31:  13     ],
			spr_dat_i[ 9],
			spr_dat_i[ 8],
			spr_dat_i[ 7],
			spr_dat_i[ 6],
			spr_dat_i[ 1]};

//
// Generate hit
//
assign hit = (vpn == vaddr[  31:    13     + 6     -1 +1      ]) & v;

//
// TLB index is normally vaddr[18:13]. If it is SPR access then index is
// spr_addr[5:0].
//
assign tlb_index = spr_cs ? spr_addr[ 6     -1:0] : vaddr[    13     + 6     -1 :   13          ];

//
// Instantiation of DTLB Match Registers
//
//or1200_spram_64x14 dtlb_mr_ram(
   or1200_spram #
     (
      .aw(6),
      .dw(14)
      )
   dtlb_ram
     (
      .clk(clk),
                  
                 
                               
                               
                                  
      
      .ce(tlb_mr_en),
      .we(tlb_mr_we),
      .addr(tlb_index),
      .di(tlb_mr_ram_in),
      .doq(tlb_mr_ram_out)
      );
   
   //
   // Instantiation of DTLB Translate Registers
   //
   //or1200_spram_64x24 dtlb_tr_ram(
   or1200_spram #
     (
      .aw(6),
      .dw(24)
      )
   dtlb_tr_ram
     (
      .clk(clk),
                  
                 
                               
                               
                                  
      
      .ce(tlb_tr_en),
      .we(tlb_tr_we),
      .addr(tlb_index),
      .di(tlb_tr_ram_in),
      .doq(tlb_tr_ram_out)
      );
   
endmodule // or1200_dmmu_tlb

`line 1 "../../rtl/verilog/or1200_dmmu_top.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Data MMU top level                                 ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of all DMMU blocks.                           ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_dmmu_top.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_dmmu_top.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_dmmu_top.v" 2

//
// Data MMU
//

module or1200_dmmu_top(
	// Rst and clk
	clk, rst,

	// CPU i/f
	dc_en, dmmu_en, supv, dcpu_adr_i, dcpu_cycstb_i, dcpu_we_i,
	dcpu_tag_o, dcpu_err_o,

	// SPR access
	spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o,

                  
            
                                      
      

	// DC i/f
	qmemdmmu_err_i, qmemdmmu_tag_i, qmemdmmu_adr_o, qmemdmmu_cycstb_o, qmemdmmu_ci_o
);

parameter dw =   32;
parameter aw =   32;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// CPU I/F
//
input				dc_en;
input				dmmu_en;
input				supv;
input	[aw-1:0]		dcpu_adr_i;
input				dcpu_cycstb_i;
input				dcpu_we_i;
output	[3:0]			dcpu_tag_o;
output				dcpu_err_o;

//
// SPR access
//
input				spr_cs;
input				spr_write;
input	[aw-1:0]		spr_addr;
input	[31:0]			spr_dat_i;
output	[31:0]			spr_dat_o;

                  
  
           
  
                 
                                                    
                  
      

//
// DC I/F
//
input				qmemdmmu_err_i;
input	[3:0]			qmemdmmu_tag_i;
output	[aw-1:0]		qmemdmmu_adr_o;
output				qmemdmmu_cycstb_o;
output				qmemdmmu_ci_o;

//
// Internal wires and regs
//
wire				dtlb_spr_access;
wire	[31:  13     ]	dtlb_ppn;
wire				dtlb_hit;
wire				dtlb_uwe;
wire				dtlb_ure;
wire				dtlb_swe;
wire				dtlb_sre;
wire	[31:0]			dtlb_dat_o;
wire				dtlb_en;
wire				dtlb_ci;
wire				fault;
wire				miss;
                     
     
reg				dtlb_done;
reg	[31:  13     ]	dcpu_vpn_r;
      

//
// Implemented bits inside match and translate registers
//
// dtlbwYmrX: vpn 31-10  v 0
// dtlbwYtrX: ppn 31-10  swe 9  sre 8  uwe 7  ure 6
//
// dtlb memory width:
// 19 bits for ppn
// 13 bits for vpn
// 1 bit for valid
// 4 bits for protection
// 1 bit for cache inhibit

                     

  
                                    
  
                                
                                   
                                   
                                         
                                   
                                       
                  
                               
      

     

//
// DTLB SPR access
//
// 0A00 - 0AFF  dtlbmr w0
// 0A00 - 0A3F  dtlbmr w0 [63:0]
//
// 0B00 - 0BFF  dtlbtr w0
// 0B00 - 0B3F  dtlbtr w0 [63:0]
//
assign dtlb_spr_access = spr_cs;

//
// Tags:
//
// OR1200_DTAG_TE - TLB miss Exception
// OR1200_DTAG_PE - Page fault Exception
//
assign dcpu_tag_o = miss ?   4'hd  : fault ?   4'hc  : qmemdmmu_tag_i;

//
// dcpu_err_o
//
assign dcpu_err_o = miss | fault | qmemdmmu_err_i;

//
// Assert dtlb_done one clock cycle after new address and dtlb_en must be active
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dtlb_done <=  1'b0;
	else if (dtlb_en)
		dtlb_done <=  dcpu_cycstb_i;
	else
		dtlb_done <=  1'b0;

//
// Cut transfer if something goes wrong with translation. Also delayed signals 
// because of translation delay.
assign qmemdmmu_cycstb_o = (dc_en & dmmu_en) ? 
			   !(miss | fault) & dtlb_done & dcpu_cycstb_i : 
			   !(miss | fault) & dcpu_cycstb_i;


//
// Cache Inhibit
//
assign qmemdmmu_ci_o = dmmu_en ? dtlb_ci :    dcpu_adr_i[31];

//
// Register dcpu_adr_i's VPN for use when DMMU is not enabled but PPN is 
// expected to come one clock cycle after offset part.
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dcpu_vpn_r <=  {32-  13     {1'b0}};
	else
		dcpu_vpn_r <=  dcpu_adr_i[31:  13     ];

//
// Physical address is either translated virtual address or
// simply equal when DMMU is disabled
//
assign qmemdmmu_adr_o = dmmu_en ? {dtlb_ppn, dcpu_adr_i[  13     -1:0]} :
			          dcpu_adr_i;

//
// Output to SPRS unit
//
assign spr_dat_o = dtlb_spr_access ? dtlb_dat_o : 32'h00000000;

//
// Page fault exception logic
//
assign fault = dtlb_done &
	(  (!dcpu_we_i & !supv & !dtlb_ure) // Load in user mode not enabled
	   || (!dcpu_we_i & supv & !dtlb_sre) // Load in supv mode not enabled
	   || (dcpu_we_i & !supv & !dtlb_uwe) // Store in user mode not enabled
	   || (dcpu_we_i & supv & !dtlb_swe)); // Store in supv mode not enabled

//
// TLB Miss exception logic
//
assign miss = dtlb_done & !dtlb_hit;

//
// DTLB Enable
//
assign dtlb_en = dmmu_en & dcpu_cycstb_i;

//
// Instantiation of DTLB
//
or1200_dmmu_tlb or1200_dmmu_tlb(
	// Rst and clk
        .clk(clk),
	.rst(rst),

        // I/F for translation
        .tlb_en(dtlb_en),
	.vaddr(dcpu_adr_i),
	.hit(dtlb_hit),
	.ppn(dtlb_ppn),
	.uwe(dtlb_uwe),
	.ure(dtlb_ure),
	.swe(dtlb_swe),
	.sre(dtlb_sre),
	.ci(dtlb_ci),

                  
            
                         
                         
                             
      

        // SPR access
        .spr_cs(dtlb_spr_access),
	.spr_write(spr_write),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_i),
	.spr_dat_o(dtlb_dat_o)
);

      

endmodule

`line 1 "../../rtl/verilog/or1200_dpram_32x32.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Double-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common double-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  double-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Double-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage 2-port Sync RAM                                    ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - fix Avant!                                               ////
////   - xilinx rams need external tri-state logic                ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_dpram_32x32.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.10  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.9  2004/06/08 18:15:48  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.8  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.7.4.1  2003/07/08 15:36:37  lampret
// Added embedded memory QMEM.
//
// Revision 1.7  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.6  2002/03/28 19:25:42  lampret
// Added second type of Virtual Silicon two-port SRAM (for register file). Changed defines for VS STP RAMs.
//
// Revision 1.5  2002/02/01 19:56:54  lampret
// Fixed combinational loops.
//
// Revision 1.4  2002/01/23 07:52:36  lampret
// Changed default reset values for SR and ESR to match or1ksim's. Fixed flop model in or1200_dpram_32x32 when OR1200_XILINX_RAM32X1D is defined.
//
// Revision 1.3  2002/01/19 14:10:22  lampret
// Fixed OR1200_XILINX_RAM32X1D.
//
// Revision 1.2  2002/01/15 06:12:22  lampret
// Fixed module name when compiling with OR1200_XILINX_RAM32X1D
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.10  2001/11/05 14:48:00  lampret
// Added missing endif
//
// Revision 1.9  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.8  2001/10/22 19:39:56  lampret
// Fixed parameters in generic sprams.
//
// Revision 1.7  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.6  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 130 "../../rtl/verilog/or1200_dpram_32x32.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 131 "../../rtl/verilog/or1200_dpram_32x32.v" 2

module or1200_dpram_32x32(
	// Generic synchronous double-port RAM interface
	clk_a, rst_a, ce_a, oe_a, addr_a, do_a,
	clk_b, rst_b, ce_b, we_b, addr_b, di_b
);

//
// Default address and data buses width
//
parameter aw = 5;
parameter dw = 32;

//
// Generic synchronous double-port RAM interface
//
input			clk_a;	// Clock
input			rst_a;	// Reset
input			ce_a;	// Chip enable input
input			oe_a;	// Output enable input
input 	[aw-1:0]	addr_a;	// address bus inputs
output	[dw-1:0]	do_a;	// output data bus
input			clk_b;	// Clock
input			rst_b;	// Reset
input			ce_b;	// Chip enable input
input			we_b;	// Write enable input
input 	[aw-1:0]	addr_b;	// address bus inputs
input	[dw-1:0]	di_b;	// input data bus

//
// Internal wires and registers
//

                         

  
                                
  
                                              
  
             
                                            
     
                           
      
           
              
              
             
             
                   
              
       
              
              
              
             
           
            
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
       

               
                   
            
            
            
              

               
           
            
            
            
             
  

     

                                   

  
                                
  
                                           
  
             
                                          
     
                     
      
              
               
              
               
                        
                      
               

              
               
               
              
                        
             
          
  

     

                                   

  
                                
  
                                           
  
             
                                          
     
                     
      
                    
                    
                    
                      
                    

             
             
               
          
  

     

                             

  
                                
  
                  
  

                   

                                                  
                                
                        
               
                      

  
          
  
                                    
                 
        
            
               
                 
              
          
  

  
          
  
                                    
                  
        
            
                
                 
              
          
  


  
          
  
                                    
                   
        
            
                 
                 
              
          
  

  
          
  
                                    
                   
        
            
                 
                 
              
          
  

     

                          

  
                                
  
                  
  

  
          
  
                          
              
             
                          
                
            
            
                  

              
             
                          
                  
            
            
       
  

  
          
  
                          
              
             
                          
                
            
            
                   

              
             
                          
                   
            
            
       
  

     

                           

  
                                
  
                    
  
                   
  

                              
              
             
                           
                    
             
            
            
            
         

              
             
                           
            
             
            
            
        
        
  

     

                            

  
                                
  
             
  
                        
  
                             
                              
                            
                              
                       
                            
                       
                         
                         
                           
                           
                       
                       
                    
                   
  

                                                               
                                              
                                                
                                                 
                                             
                                               
                                                
                                              
                                                
                                                 
                                             
                                               
                                                
                                                      
                                                                   
                                                       
                                                      
                                                                   
                                                       
                                                      
                                                         
                                                         
                                                       
                                                  
                                                     
                                                     
                                                       
                                                   
                                                          

     

//
// Generic double-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_a_reg;		// RAM address registered

//
// Data output drivers
//
assign do_a = (oe_a) ? mem[addr_a_reg] : {dw{1'b0}};

//
// RAM read
//
always @(posedge clk_a or       posedge rst_a)
	if (rst_a ==       (1'b1))
		addr_a_reg <=  {aw{1'b0}};
	else if (ce_a)
		addr_a_reg <=  addr_a;

//
// RAM write
//
always @(posedge clk_b)
	if (ce_b && we_b)
		mem[addr_b] <=  di_b;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_XILINX_RAM32X1D
      	// !OR1200_VIRTUALSILICON_SSP_T1
      	// !OR1200_VIRTUALSILICON_SSP_T2
      	// !OR1200_VIRAGE_STP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SDP

endmodule

`line 1 "../../rtl/verilog/or1200_du.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Debug Unit                                         ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Basic OR1200 debug unit.                                    ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_du.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_du.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_du.v" 2

//
// Debug unit
//

module or1200_du(
	// RISC Internal Interface
	clk, rst,
	dcpu_cycstb_i, dcpu_we_i, dcpu_adr_i, dcpu_dat_lsu,
	dcpu_dat_dc, icpu_cycstb_i,
	ex_freeze, branch_op, ex_insn, id_pc,
	spr_dat_npc, rf_dataw,
	du_dsr, du_dmr1, du_stall, du_addr, du_dat_i, du_dat_o,
	du_read, du_write, du_except_stop, du_hwbkpt, du_flush_pipe,
	spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o,

	// External Debug Interface
	dbg_stall_i, dbg_ewt_i,	dbg_lss_o, dbg_is_o, dbg_wp_o, dbg_bp_o,
	dbg_stb_i, dbg_we_i, dbg_adr_i, dbg_dat_i, dbg_dat_o, dbg_ack_o
);

parameter dw =   32;
parameter aw =   32;

//
// I/O
//

//
// RISC Internal Interface
//
input				clk;		// Clock
input				rst;		// Reset
input				dcpu_cycstb_i;	// LSU status
input				dcpu_we_i;	// LSU status
input	[31:0]			dcpu_adr_i;	// LSU addr
input	[31:0]			dcpu_dat_lsu;	// LSU store data
input	[31:0]			dcpu_dat_dc;	// LSU load data
input	[  1-1:0]	icpu_cycstb_i;	// IFETCH unit status
input				ex_freeze;	// EX stage freeze
input	[  3-1:0]	branch_op;	// Branch op
input	[dw-1:0]		ex_insn;	// EX insn
input	[31:0]			id_pc;		// insn fetch EA
input	[31:0]			spr_dat_npc;	// Next PC (for trace)
input	[31:0]			rf_dataw;	// ALU result (for trace)
output	[ 14-1:0]     du_dsr;		// DSR
output	[24: 0]			du_dmr1;
output				du_stall;	// Debug Unit Stall
output	[aw-1:0]		du_addr;	// Debug Unit Address
input	[dw-1:0]		du_dat_i;	// Debug Unit Data In
output	[dw-1:0]		du_dat_o;	// Debug Unit Data Out
output				du_read;	// Debug Unit Read Enable
output				du_write;	// Debug Unit Write Enable
input	[13:0]			du_except_stop;	// Exception masked by DSR
output				du_hwbkpt;	// Cause trap exception (HW Breakpoints)
output				du_flush_pipe;	// Cause pipeline flush and pc<-npc
input				spr_cs;		// SPR Chip Select
input				spr_write;	// SPR Read/Write
input	[aw-1:0]		spr_addr;	// SPR Address
input	[dw-1:0]		spr_dat_i;	// SPR Data Input
output	[dw-1:0]		spr_dat_o;	// SPR Data Output

//
// External Debug Interface
//
input			dbg_stall_i;	// External Stall Input
input			dbg_ewt_i;	// External Watchpoint Trigger Input
output	[3:0]		dbg_lss_o;	// External Load/Store Unit Status
output	[1:0]		dbg_is_o;	// External Insn Fetch Status
output	[10:0]		dbg_wp_o;	// Watchpoints Outputs
output			dbg_bp_o;	// Breakpoint Output
input			dbg_stb_i;      // External Address/Data Strobe
input			dbg_we_i;       // External Write Enable
input	[aw-1:0]	dbg_adr_i;	// External Address Input
input	[dw-1:0]	dbg_dat_i;	// External Data Input
output	[dw-1:0]	dbg_dat_o;	// External Data Output
output			dbg_ack_o;	// External Data Acknowledge (not WB compatible)
reg	[dw-1:0]	dbg_dat_o;	// External Data Output
reg			dbg_ack_o;	// External Data Acknowledge (not WB compatible)


//
// Some connections go directly from the CPU through DU to Debug I/F
//
                                     
assign dbg_lss_o = 4'b0000;

reg	[1:0]			dbg_is_o;
//
// Show insn activity (temp, must be removed)
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dbg_is_o <=  2'b00;
	else if (!ex_freeze & ~((ex_insn[31:26] ==                6'b000101) & ex_insn[16]))
		dbg_is_o <=  ~dbg_is_o;
             
                        
      
     
                                                                 
                                        
      
assign dbg_wp_o = 11'b000_0000_0000;

//
// Some connections go directly from Debug I/F through DU to the CPU
//
assign du_stall = dbg_stall_i;
assign du_addr = dbg_adr_i;
assign du_dat_o = dbg_dat_i;
assign du_read = dbg_stb_i && !dbg_we_i;
assign du_write = dbg_stb_i && dbg_we_i;

//
// After a sw breakpoint, the replaced instruction need to be executed.
// We flush the entire pipeline and set the pc to the current address
// to execute the restored address.
//

reg du_flush_pipe_r;
reg dbg_stall_i_r;

assign du_flush_pipe = du_flush_pipe_r;

//
// Register du_flush_pipe
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		du_flush_pipe_r   <=  1'b0;
	end
	else begin
		du_flush_pipe_r   <=  (dbg_stall_i_r && !dbg_stall_i && |du_except_stop);
	end
end

//
// Detect dbg_stall falling edge
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		dbg_stall_i_r   <=  1'b0;
	end
	else begin
		dbg_stall_i_r   <=  dbg_stall_i;
	end
end

reg				dbg_ack;
//
// Generate acknowledge -- just delay stb signal
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		dbg_ack   <=  1'b0;
		dbg_ack_o <=  1'b0;
	end
	else begin
		dbg_ack   <=  dbg_stb_i;		// valid when du_dat_i 
		dbg_ack_o <=  dbg_ack & dbg_stb_i;	// valid when dbg_dat_o 
	end
end

// 
// Register data output
//
always @(posedge clk)
    dbg_dat_o <=  du_dat_i;

                            

//
// Debug Mode Register 1
//
                     
reg	[24:0]			dmr1;		// DMR1 implemented
     
                                            
      
assign du_dmr1 = dmr1;

//
// Debug Mode Register 2
//
                     
                                       
     
wire	[23:0]			dmr2;		// DMR2 not implemented
      

//
// Debug Stop Register
//
                    
reg	[ 14-1:0]	dsr;		// DSR implemented
     
                                                            
      

//
// Debug Reason Register
//
                    
reg	[13:0]			drr;		// DRR implemented
     
                                          
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr0;
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr1;
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr2;
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr3;
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr4;
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr5;
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr6;
      

//
// Debug Value Register N
//
                     
                  
     
wire	[31:0]			dvr7;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr0;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr1;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr2;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr3;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr4;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr5;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr6;
      

//
// Debug Control Register N
//
                     
                 
     
wire	[7:0]			dcr7;
      

//
// Debug Watchpoint Counter Register 0
//
                      
                   
     
wire	[31:0]			dwcr0;
      

//
// Debug Watchpoint Counter Register 1
//
                      
                   
     
wire	[31:0]			dwcr1;
      

//
// Internal wires
//
wire				dmr1_sel; 	// DMR1 select
wire				dmr2_sel; 	// DMR2 select
wire				dsr_sel; 	// DSR select
wire				drr_sel; 	// DRR select
wire				dvr0_sel,
				dvr1_sel,
				dvr2_sel,
				dvr3_sel,
				dvr4_sel,
				dvr5_sel,
				dvr6_sel,
				dvr7_sel; 	// DVR selects
wire				dcr0_sel,
				dcr1_sel,
				dcr2_sel,
				dcr3_sel,
				dcr4_sel,
				dcr5_sel,
				dcr6_sel,
				dcr7_sel; 	// DCR selects
wire				dwcr0_sel,
				dwcr1_sel; 	// DWCR selects
reg				dbg_bp_r;
reg 				ex_freeze_q;
                        
                            
                            
                            
                            
                            
                            
                            
                            
                       
                       
                       
                       
                       
                       
                       
                       
              
              
              
              
              
              
              
              
                     
                     
                    
                    
                
      
wire				du_hwbkpt;
reg				du_hwbkpt_hold;
                         
reg	[31:0]			spr_dat_o;
      
reg	[13:0]			except_stop;	// Exceptions that stop because of DSR
                               
               
                    
                        
      
wire	[31:0]			tbia_dat_o;
wire	[31:0]			tbim_dat_o;
wire	[31:0]			tbar_dat_o;
wire	[31:0]			tbts_dat_o;

//
// DU registers address decoder
//
                     
assign dmr1_sel = (spr_cs && (spr_addr[ 10:0] ==   11'd16));
      
                     
                                                                                
      
                    
assign dsr_sel = (spr_cs && (spr_addr[ 10:0] ==   11'd20));
      
                    
assign drr_sel = (spr_cs && (spr_addr[ 10:0] ==   11'd21));
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                     
                                                                                
      
                      
                                                                                  
      
                      
                                                                                  
      

// Track previous ex_freeze to detect when signals are updated
always @(posedge clk)
  ex_freeze_q <= ex_freeze;

//
// Decode started exception
//
// du_except_stop comes from or1200_except
//   
always @(du_except_stop or ex_freeze_q) begin
	except_stop = 14'b00_0000_0000_0000;
	casez (du_except_stop)
	        14'b1?_????_????_????:
			except_stop[ 4] = 1'b1;
		14'b01_????_????_????: begin
			except_stop[ 7] = 1'b1;
		end
		14'b00_1???_????_????: begin
			except_stop[ 9] = 1'b1;
		end
		14'b00_01??_????_????:
			except_stop[ 3] = 1'b1;
		14'b00_001?_????_????: begin
			except_stop[ 1] = 1'b1;
		end
		14'b00_0001_????_????:
			except_stop[ 6] = 1'b1;
		14'b00_0000_1???_????: begin
			except_stop[ 5] = 1'b1;
		end
		14'b00_0000_01??_????: begin
			except_stop[ 8] = 1'b1;
		end
		14'b00_0000_001?_????:
			except_stop[ 2] = 1'b1;
		14'b00_0000_0001_????:
			except_stop[ 1] = 1'b1;
		14'b00_0000_0000_1???: begin
			except_stop[ 10] = 1'b1;
		end
		14'b00_0000_0000_01??: begin
			except_stop[ 13] = 1'b1 & ~ex_freeze_q;
		end
		14'b00_0000_0000_001?: begin
		        except_stop[ 12] = 1'b1;
		end	  
		14'b00_0000_0000_0001:
			except_stop[ 11] = 1'b1 & ~ex_freeze_q;
		default:
			except_stop = 14'b00_0000_0000_0000;
	endcase // casez (du_except_stop)
end

//
// dbg_bp_o is registered
//
assign dbg_bp_o = dbg_bp_r;

//
// Breakpoint activation register
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dbg_bp_r <=  1'b0;
	else if (!ex_freeze)
		dbg_bp_r <=  |except_stop
                        
                        | ~((ex_insn[31:26] ==                6'b000101) & ex_insn[16]) & dmr1[ 22]
      
                        
                        | (branch_op !=   3'd0) & (branch_op !=   3'd6) & dmr1[ 23]
      
			;
        else
                dbg_bp_r <=  |except_stop;

//
// Write to DMR1
//
                     
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dmr1 <= 25'h000_0000;
	else if (dmr1_sel && spr_write)
                        
                           
     
		dmr1 <=  {1'b0, spr_dat_i[23:22], 22'h00_0000};
      
     
                           
      

//
// Write to DMR2
//
                     
                                              
                              
                      
                                
                           
     
assign dmr2 = 24'h00_0000;
      

//
// Write to DSR
//
                    
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dsr <= { 14{1'b0}};
	else if (dsr_sel && spr_write)
		dsr <=  spr_dat_i[ 14-1:0];
     
                                          
      

//
// Write to DRR
//
                    
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		drr <= 14'b0;
	else if (drr_sel && spr_write)
		drr <=  spr_dat_i[13:0];
	else
		drr <=  drr | except_stop;
     
                   
      

//
// Write to DVR0
//
                     
                                              
                              
                        
                                
                           
     
assign dvr0 = 32'h0000_0000;
      

//
// Write to DVR1
//
                     
                                              
                              
                        
                                
                           
     
assign dvr1 = 32'h0000_0000;
      

//
// Write to DVR2
//
                     
                                              
                              
                        
                                
                           
     
assign dvr2 = 32'h0000_0000;
      

//
// Write to DVR3
//
                     
                                              
                              
                        
                                
                           
     
assign dvr3 = 32'h0000_0000;
      

//
// Write to DVR4
//
                     
                                              
                              
                        
                                
                           
     
assign dvr4 = 32'h0000_0000;
      

//
// Write to DVR5
//
                     
                                              
                              
                        
                                
                           
     
assign dvr5 = 32'h0000_0000;
      

//
// Write to DVR6
//
                     
                                              
                              
                        
                                
                           
     
assign dvr6 = 32'h0000_0000;
      

//
// Write to DVR7
//
                     
                                              
                              
                        
                                
                           
     
assign dvr7 = 32'h0000_0000;
      

//
// Write to DCR0
//
                     
                                              
                              
                
                                
                          
     
assign dcr0 = 8'h00;
      

//
// Write to DCR1
//
                     
                                              
                              
                
                                
                          
     
assign dcr1 = 8'h00;
      

//
// Write to DCR2
//
                     
                                              
                              
                
                                
                          
     
assign dcr2 = 8'h00;
      

//
// Write to DCR3
//
                     
                                              
                              
                
                                
                          
     
assign dcr3 = 8'h00;
      

//
// Write to DCR4
//
                     
                                              
                              
                
                                
                          
     
assign dcr4 = 8'h00;
      

//
// Write to DCR5
//
                     
                                              
                              
                
                                
                          
     
assign dcr5 = 8'h00;
      

//
// Write to DCR6
//
                     
                                              
                              
                
                                
                          
     
assign dcr6 = 8'h00;
      

//
// Write to DCR7
//
                     
                                              
                              
                
                                
                          
     
assign dcr7 = 8'h00;
      

//
// Write to DWCR0
//
                      
                                              
                              
                         
                                 
                            
                       
                                                                           
     
assign dwcr0 = 32'h0000_0000;
      

//
// Write to DWCR1
//
                      
                                              
                              
                         
                                 
                            
                       
                                                                           
     
assign dwcr1 = 32'h0000_0000;
      

//
// Read DU registers
//
                         
always @(spr_addr or dsr or drr or dmr1 or dmr2
	or dvr0 or dvr1 or dvr2 or dvr3 or dvr4
	or dvr5 or dvr6 or dvr7
	or dcr0 or dcr1 or dcr2 or dcr3 or dcr4
	or dcr5 or dcr6 or dcr7
	or dwcr0 or dwcr1
                               
                                       
                            
      
	)
	casez (spr_addr[ 10:0]) // synopsys parallel_case
                     
                  
                    
      
                     
                  
                    
      
                     
                  
                    
      
                     
                  
                    
      
                     
                  
                    
      
                     
                  
                    
      
                     
                  
                    
      
                     
                  
                    
      
                     
                  
                                   
      
                     
                  
                                   
      
                     
                  
                                   
      
                     
                  
                                   
      
                     
                  
                                   
      
                     
                  
                                   
      
                     
                  
                                   
      
                     
                  
                                   
      
                     
		  11'd16:
			spr_dat_o = {7'h00, dmr1};
      
                     
                  
                             
      
                      
                   
                     
      
                      
                   
                     
      
                    
		  11'd20:
			spr_dat_o = {18'b0, dsr};
      
                    
		  11'd21:
			spr_dat_o = {18'b0, drr};
      
                               
                   
                                     
                  
                          
                  
                          
                  
                          
                  
                          
      
		default:
			spr_dat_o = 32'h0000_0000;
	endcase
      

//
// DSR alias
//
assign du_dsr = dsr;

                        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                        
                                 
                        
                        
                        
                      
        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                              
                                 
                        
                                
                                
                      
        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                              
                                 
                        
                                
                                
                      
        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                              
                                 
                        
                                
                                
                      
        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                              
                                 
                        
                                
                                
                      
        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                              
                                 
                        
                                
                                
                      
        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                              
                                 
                        
                                
                                
                      
        

  
                                      
  
                                                   
                              
                                                          
                                                   
                                                 
                                                  
                                                    
                                                      
                                                       
                                                                  
        

  
                                      
  
                               
                                                           
                                                        
                                                   
                                                            
        

  
                    
  
                                                           
                                                   
           
           
                          
                    
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                            
                                                        
                     
                                                                             
                                                        
                     
                                                                             
                                                        
        

  
               
  
                              
                                 
                        
                                
                                
                      
        

  
                                 
  
                    
                                
                                                     
     
                      

  
                                       
  
               
                                                                  
                       
     
                       


  
               
  
                                     
                                 
                               
                                       
                                       
                      
        


  
                                 
  
                    
                                
                                                    
     
                      

  
                                       
  
               
                                                                  
                       
     
                       

  
               
  
                                     
                                 
                               
                                       
                                       
                      
        

  
                
  
                                 
                                  
                            
                                    
                                    
                       
        

      

//
// Watchpoints can cause trap exception
//
                        
                                                                                                             
     
assign du_hwbkpt = 1'b0;
      

// Hold du_hwbkpt if ex_freeze is active in order to cause trap exception 
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		du_hwbkpt_hold <=  1'b0;
	else if (du_hwbkpt & ex_freeze)
		du_hwbkpt_hold <=  1'b1;
	else if (!ex_freeze)
		du_hwbkpt_hold <=  1'b0;

                               
  
                      
                                                
  
                                                     
                                
  

  
                            
  
                                                                                   

  
                                     
  
                                              
                              
                    
                 
                             

  
                                    
  
                                              
                              
                              
                    
                                    

  
                    
  

                             
             
              
                        
             
             
                   

             
              
                  
                    
             
              

  

                             
             
              
                        
             
             
                   
 
             
              
                  
                
             
              
  

                             
             
              
                        
             
             
                   
 
             
              
                  
                 
             
              
  

                             
             
              
                        
             
             
                   

             
              
                  
                   
             
              
  

     

assign tbia_dat_o = 32'h0000_0000;
assign tbim_dat_o = 32'h0000_0000;
assign tbar_dat_o = 32'h0000_0000;
assign tbts_dat_o = 32'h0000_0000;

      	// OR1200_DU_TB_IMPLEMENTED

                              

  
                                                                             
  
                       
                                             
                            
                        

  
                    
  
                         
                                 
                            
      
      

      

endmodule

`line 1 "../../rtl/verilog/or1200_except.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Exception logic                                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Handles all OR1K exceptions inside CPU block.               ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_except.v,v $
//
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_except.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_except.v" 2

                                
                                                        
                                                         
                                                         
                                                         
                                                         
                                                         

//
// Exception recognition and sequencing
//

module or1200_except
  (
   // Clock and reset
   clk, rst, 
   
   // Internal i/f
   sig_ibuserr, sig_dbuserr, sig_illegal, sig_align, sig_range, sig_dtlbmiss, 
   sig_dmmufault, sig_int, sig_syscall, sig_trap, sig_itlbmiss, sig_immufault, 
   sig_tick, ex_branch_taken, genpc_freeze, id_freeze, ex_freeze, wb_freeze,  
   if_stall,  if_pc, id_pc, ex_pc, wb_pc, id_flushpipe, ex_flushpipe, 
   extend_flush, except_flushpipe, except_type, except_start, except_started, 
   except_stop, except_trig, ex_void, abort_mvspr, branch_op, spr_dat_ppc, 
   spr_dat_npc, datain, du_dsr, epcr_we, eear_we, esr_we, pc_we, epcr, eear, 
   du_dmr1, du_hwbkpt, du_hwbkpt_ls_r, esr, sr_we, to_sr, sr, lsu_addr, 
   abort_ex, icpu_ack_i, icpu_err_i, dcpu_ack_i, dcpu_err_i, sig_fp, fpcsr_fpee,
   dsx
   
);

//
// I/O
//
input				clk;
input				rst;
input				sig_ibuserr;
input				sig_dbuserr;
input				sig_illegal;
input				sig_align;
input				sig_range;
input				sig_dtlbmiss;
input				sig_dmmufault;
input				sig_int;
input				sig_syscall;
input				sig_trap;
input				sig_itlbmiss;
input				sig_immufault;
input				sig_tick;
input   			sig_fp;
input    			fpcsr_fpee;   
input				ex_branch_taken;
input				genpc_freeze;
input				id_freeze;
input				ex_freeze;
input				wb_freeze;
input				if_stall;
input	[31:0]		if_pc;
output	[31:0]		id_pc;
output  [31:0]      ex_pc;
output  [31:0]      wb_pc;
input	[31:0]		datain;
input   [ 14-1:0]     du_dsr;
input   [24:0]                       du_dmr1;
input			du_hwbkpt;
input			du_hwbkpt_ls_r;
input				epcr_we;
input				eear_we;
input				esr_we;
input				pc_we;
output	[31:0]			epcr;
output	[31:0]			eear;
output	[ 17-1:0]	esr;
input	[ 17-1:0]	to_sr;
input				sr_we;
input	[ 17-1:0]	sr;
input	[31:0]			lsu_addr;
input              	id_flushpipe;
input              	ex_flushpipe;
output				except_flushpipe;
output				extend_flush;
output	[ 4-1:0]	except_type;
output				except_start;
output				except_started;
output	[13:0]		except_stop;
output	[13:0]		except_trig;
input				ex_void;
input   [  3-1:0]    branch_op; 
output	[31:0]			spr_dat_ppc;
output	[31:0]			spr_dat_npc;
output				abort_ex;
output              abort_mvspr;
input				icpu_ack_i;
input				icpu_err_i;
input				dcpu_ack_i;
input				dcpu_err_i;
output 			        dsx;
   
//
// Internal regs and wires
//
reg	[ 4-1:0]	except_type /* verilator public */;
reg	[31:0]			id_pc /* verilator public */;
reg                 id_pc_val;
reg	[31:0]			ex_pc /* verilator public */;
reg                 ex_pc_val;
reg	[31:0]			wb_pc /* verilator public */;
reg [31:0]          dl_pc;
reg	[31:0]			epcr;
reg	[31:0]			eear;
reg	[ 17-1:0]		esr;
reg	[2:0]			id_exceptflags;
reg	[2:0]			ex_exceptflags;
reg	[ 3-1:0]	state;
reg				extend_flush;
reg				extend_flush_last;
reg				ex_dslot /* verilator public */;
reg				delayed1_ex_dslot;
reg				delayed2_ex_dslot;
wire				except_started;
wire				except_flushpipe /* verilator public */;
reg	[2:0]			delayed_iee;
reg	[2:0]			delayed_tee;
wire				int_pending;
wire				tick_pending;
wire    			fp_pending;
wire    			range_pending;
reg 				dsx;
			
reg trace_trap      ;
reg ex_freeze_prev;
reg sr_ted_prev;
reg dsr_te_prev;
reg dmr1_st_prev    ;
reg dmr1_bt_prev    ;
wire dsr_te = ex_freeze_prev ? dsr_te_prev : du_dsr[ 13];
wire sr_ted = ex_freeze_prev ? sr_ted_prev : sr[  16];
wire dmr1_st = ex_freeze_prev ? dmr1_st_prev: du_dmr1[ 22] ;
wire dmr1_bt = ex_freeze_prev ? dmr1_bt_prev: du_dmr1[ 23] ;

//
// Simple combinatorial logic
//
assign except_started = extend_flush & except_start;
   
assign except_start = (except_type !=    4'h0) & extend_flush;
   
assign int_pending = sig_int & (sr[  2] | 
				(sr_we & to_sr[  2])) 
		    & id_pc_val & delayed_iee[2] & ~ex_freeze & ~ex_branch_taken
		     & ~ex_dslot & ~(sr_we & ~to_sr[  2]);
   
assign tick_pending = sig_tick & (sr[  1] | 
				  (sr_we & to_sr[  1])) & id_pc_val
		      & delayed_tee[2] & ~ex_freeze & ~ex_branch_taken 
		      & ~ex_dslot & ~(sr_we & ~to_sr[  1]);

assign fp_pending = sig_fp & fpcsr_fpee & ~ex_freeze & ~ex_branch_taken 
		    & ~ex_dslot;

                         
assign range_pending =  sig_range & sr[  12 ] & ~ex_freeze & 
		       ~ex_branch_taken & ~ex_dslot;
     
                         
         
   
// Abort write into RF by load & other instructions   
assign abort_ex = sig_dbuserr | sig_dmmufault | sig_dtlbmiss | sig_align | 
		  sig_illegal | ((du_hwbkpt | trace_trap) & ex_pc_val 
				 & !sr_ted & !dsr_te);

// abort spr read/writes   
assign abort_mvspr  = sig_illegal | ((du_hwbkpt | trace_trap) & ex_pc_val 
				     & !sr_ted & !dsr_te) ; 
assign spr_dat_ppc = wb_pc;
   
assign spr_dat_npc = ex_void ? id_pc : ex_pc;

//
// Order defines exception detection priority
//
assign except_trig = {
		      ex_exceptflags[1]	& ~du_dsr[ 9],
		      ex_exceptflags[0]	& ~du_dsr[ 3],
		      ex_exceptflags[2]	& ~du_dsr[ 1],
		      sig_illegal       & ~du_dsr[ 6],
		      sig_align		& ~du_dsr[ 5],
		      sig_dtlbmiss	& ~du_dsr[ 8],
		      sig_trap		& ~du_dsr[ 13],
		      sig_syscall       & ~du_dsr[ 11] & ~ex_freeze,
		      sig_dmmufault	& ~du_dsr[ 2],
		      sig_dbuserr	& ~du_dsr[ 1],
		      range_pending	& ~du_dsr[ 10],
		      fp_pending	& ~du_dsr[ 12],
		      int_pending 	& ~du_dsr[ 7],
		      tick_pending	& ~du_dsr[ 4]
		      };

wire    trace_cond  = !ex_freeze && !ex_void && (1'b0
                        
    ||  dmr1_st
      
                        
    ||  ((branch_op !=   3'd0) && (branch_op !=   3'd6) && dmr1_bt)
      
    );

assign except_stop = {
			tick_pending		& du_dsr[ 4],
			int_pending 		& du_dsr[ 7],
			ex_exceptflags[1]	& du_dsr[ 9],
			ex_exceptflags[0]	& du_dsr[ 3],
			ex_exceptflags[2]	& du_dsr[ 1],
			sig_illegal		& du_dsr[ 6],
			sig_align		& du_dsr[ 5],
			sig_dtlbmiss		& du_dsr[ 8],
			sig_dmmufault		& du_dsr[ 2],
			sig_dbuserr		& du_dsr[ 1],
			range_pending		& du_dsr[ 10],
			sig_trap		& du_dsr[ 13],
		        fp_pending  		& du_dsr[ 12],
			sig_syscall		& du_dsr[ 11] & ~ex_freeze
		};

always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		trace_trap  <=  1'b0 ;
	end 
	else if (!(trace_trap && !ex_pc_val)) begin
		trace_trap  <=  trace_cond & !dsr_te & !sr_ted ;
	end
end

always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
        ex_freeze_prev  <=  1'b0 ;
        sr_ted_prev     <=  1'b0 ;
        dsr_te_prev     <=  1'b0 ;
        dmr1_st_prev    <=  1'b0 ;
        dmr1_bt_prev    <=  1'b0 ;
    end 
    else begin
        ex_freeze_prev  <=  ex_freeze ;
        if (!ex_freeze_prev || ex_void) begin
            sr_ted_prev     <=  sr     [  16    ] ;
            dsr_te_prev     <=  du_dsr [ 13 ] ;
            dmr1_st_prev    <=  du_dmr1[ 22] ;
            dmr1_bt_prev    <=  du_dmr1[ 23] ;
        end
    end
end

                
                                                                      
                                                                       
                
                             
                         
                        
                           

                                                                      
                                                                       
                
                             
                         
                        
                           

                                                                      
                                                                       
                
                             
                         
                        
                           
                                                                                 
                                                                       
                
                                  
                         
                                    
                                 
   
      
   
   
//
// PC and Exception flags pipelines
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		id_pc <=  32'd0;
        id_pc_val <=  1'b0 ;
		id_exceptflags <=  3'b000;
	end
	else if (id_flushpipe) begin
        id_pc_val <=  1'b0 ;
		id_exceptflags <=  3'b000;
	end
	else if (!id_freeze) begin
		id_pc <=  if_pc;
        id_pc_val <=  1'b1 ;
		id_exceptflags <=  { sig_ibuserr, sig_itlbmiss, sig_immufault };
	end
end

//
// delayed_iee
//
// SR[IEE] should not enable interrupts right away
// when it is restored with l.rfe. Instead delayed_iee
// together with SR[IEE] enables interrupts once
// pipeline is again ready.
//
always @(      posedge rst or posedge clk)
	if (rst ==       (1'b1))
		delayed_iee <=  3'b000;
	else if (!sr[  2])
		delayed_iee <=  3'b000;
	else
		delayed_iee <=  {delayed_iee[1:0], 1'b1};

//
// delayed_tee
//
// SR[TEE] should not enable tick exceptions right away
// when it is restored with l.rfe. Instead delayed_tee
// together with SR[TEE] enables tick exceptions once
// pipeline is again ready.
//
always @(      posedge rst or posedge clk)
	if (rst ==       (1'b1))
		delayed_tee <=  3'b000;
	else if (!sr[  1])
		delayed_tee <=  3'b000;
	else
		delayed_tee <=  {delayed_tee[1:0], 1'b1};

//
// PC and Exception flags pipelines
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		ex_dslot <=  1'b0;
		ex_pc <=  32'd0;
                ex_pc_val <=  1'b0 ;
		ex_exceptflags <=  3'b000;
		delayed1_ex_dslot <=  1'b0;
		delayed2_ex_dslot <=  1'b0;
	end
	else if (ex_flushpipe) begin
		ex_dslot <=  1'b0;
                ex_pc_val <=  1'b0 ;
		ex_exceptflags <=  3'b000;
		delayed1_ex_dslot <=  1'b0;
		delayed2_ex_dslot <=  1'b0;
	end
	else if (!ex_freeze & id_freeze) begin
		ex_dslot <=  1'b0;
		ex_pc <=  id_pc;
                ex_pc_val <=  id_pc_val ;
		ex_exceptflags <=  3'b000;
		delayed1_ex_dslot <=  ex_dslot;
		delayed2_ex_dslot <=  delayed1_ex_dslot;
	end
	else if (!ex_freeze) begin
		ex_dslot <=  ex_branch_taken;
		ex_pc <=  id_pc;
                ex_pc_val <=  id_pc_val ;
		ex_exceptflags <=  id_exceptflags;
		delayed1_ex_dslot <=  ex_dslot;
		delayed2_ex_dslot <=  delayed1_ex_dslot;
	end
end

//
// PC and Exception flags pipelines
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		wb_pc <=  32'd0;
        dl_pc <=  32'd0;
	end
	else if (!wb_freeze) begin
		wb_pc <=  ex_pc;
        dl_pc <=  wb_pc;
	end
end

//
// We have started execution of exception handler:
//  1. Asserted for 3 clock cycles
//  2. Don't execute any instruction that is still in pipeline and is not part of exception handler
//
assign except_flushpipe = |except_trig & ~|state;

//
// Exception FSM that sequences execution of exception handler
//
// except_type signals which exception handler we start fetching in:
//  1. Asserted in next clock cycle after exception is recognized
//
   always @(posedge clk or       posedge rst) begin
      if (rst ==       (1'b1)) begin
	 state <=    3'd0;
	 except_type <=     4'h0;
	 extend_flush <=  1'b0;
	 epcr <=  32'b0;
	 eear <=  32'b0;
	 esr <=  {2'h1, { 17-3{1'b0}}, 1'b1};
	 extend_flush_last <=  1'b0;
	 dsx <= 1'b0;
      end
      else begin
                          
	 case (state)	// synopsys parallel_case
     
                                                    
      
	       3'd0:
	       if (except_flushpipe) begin
		  state <=     3'd1;
		  extend_flush <=  1'b1;
		  esr <=  sr_we ? to_sr : sr;
		  casez (except_trig)
                             
		    14'b1?_????_????_????: begin
		       except_type <=     4'ha;
		       eear <=  ex_dslot ? 
			       ex_pc : ex_pc;
		       epcr <=  ex_dslot ? 
			       wb_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                        
		    14'b01_????_????_????: begin
		       except_type <=     4'h4;
		       eear <=  ex_dslot ? 
			       ex_pc : delayed1_ex_dslot ? 
			       id_pc : delayed2_ex_dslot ? 
			       id_pc : id_pc;
		       epcr <=  ex_dslot ? 
			       wb_pc : delayed1_ex_dslot ? 
			       id_pc : delayed2_ex_dslot ? 
			       id_pc : id_pc;
		       dsx <= ex_dslot;
		    end
      
                           
		    14'b00_1???_????_????: begin	// Insn. Bus Error
		       except_type <=     4'h2;
		       eear <=  ex_dslot ? 
			       wb_pc : ex_pc;
		       epcr <=  ex_dslot ? 
			       wb_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                            
		    14'b00_01??_????_????: begin
		       except_type <=     4'h7;
		       eear <=  ex_pc;
		       epcr <=  ex_dslot ? 
			       wb_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                          
		    14'b00_001?_????_????: begin
		       except_type <=     4'h6;
		       eear <=  lsu_addr;
		       epcr <=  ex_dslot ? 
			       wb_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                             
		    14'b00_0001_????_????: begin
		       except_type <=     4'h9;
		       eear <=  lsu_addr;
		       epcr <=  ex_dslot ? 
			       wb_pc : delayed1_ex_dslot ? 
			       dl_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                         			
		    14'b00_0000_1???_????: begin
		       except_type <=     4'he;
		       epcr <=  ex_dslot ? 
			       wb_pc : delayed1_ex_dslot ? 
			       id_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                            
		    14'b00_0000_01??_????: begin
		       except_type <=     4'hc;
		       epcr <=  ex_dslot ? 
			       wb_pc : delayed1_ex_dslot ? 
			       id_pc : delayed2_ex_dslot ? 
			       id_pc : id_pc;
		       dsx <= ex_dslot;
		    end
      
                        
		    14'b00_0000_001?_????: begin
		       except_type <=     4'h3;
		       eear <=  lsu_addr;
		       epcr <=  ex_dslot ? 
			       wb_pc : delayed1_ex_dslot ? 
			       dl_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                           
		    14'b00_0000_0001_????: begin	// Data Bus Error
		       except_type <=     4'h2;
		       eear <=  lsu_addr;
		       epcr <=  ex_dslot ? 
			       wb_pc : delayed1_ex_dslot ? 
			       dl_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                          
		    14'b00_0000_0000_1???: begin
		       except_type <=     4'hb;
		       epcr <=  ex_dslot ? 
			       wb_pc : delayed1_ex_dslot ? 
			       dl_pc : delayed2_ex_dslot ? 
			       id_pc : ex_pc;
		       dsx <= ex_dslot;
		    end
      
                          
		    14'b00_0000_0000_01??: begin
		       except_type <=     4'hd;
		       epcr <=  id_pc;
		       dsx <= ex_dslot;
		    end
      
                        
		    14'b00_0000_0000_001?: begin
		       except_type <=     4'h8;
		       epcr <=  id_pc;
		       dsx <= ex_dslot;
		    end
      
                         
		    14'b00_0000_0000_0001: begin
		       except_type <=     4'h5;
		       epcr <=  id_pc;
		       dsx <= ex_dslot;
		    end
      
		    default:
		      except_type <=     4'h0;
		  endcase
	       end
	       else if (pc_we) begin
		  state <=     3'd1;
		  extend_flush <=  1'b1;
	       end
	       else begin
		  if (epcr_we)
		    epcr <=  datain;
		  if (eear_we)
		    eear <=  datain;
		  if (esr_we)
		    esr <=  {datain[ 17-1], 1'b1, datain[ 17-3:0]};
	       end
	        3'd1:
	       if (icpu_ack_i | icpu_err_i | genpc_freeze)
		 state <=     3'd2;
	        3'd2:
                         
	       if (except_type ==    4'he) begin
		  state <=    3'd0;
		  extend_flush <=  1'b0;
		  extend_flush_last <=  1'b0;
		  except_type <=     4'h0;
	       end
               else
      
		 state <=     3'd3;
	        3'd3:
	       begin
		  state <=     3'd4;
	       end
	        3'd4: begin
		state <=     3'd5;
		extend_flush <=  1'b0;
		extend_flush_last <=  1'b0; // damjan
	     end
                          
	     default: begin
     
                               
      
		   if (!if_stall && !id_freeze) begin
		      state <=    3'd0;
		      except_type <=     4'h0;
		      extend_flush_last <=  1'b0;
		   end
		end
	   endcase
	 end
   end

endmodule

`line 1 "../../rtl/verilog/or1200_freeze.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Freeze logic                                       ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Generates all freezes and stalls inside RISC                ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_freeze.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_freeze.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_freeze.v" 2

                             
                               
                                       
                                      
                             

//
// Freeze logic (stalls CPU pipeline, ifetcher etc.)
//
module or1200_freeze
  (
   // Clock and reset
   clk, rst,
   
   // Internal i/f
   multicycle, wait_on, flushpipe, extend_flush, lsu_stall, if_stall,
   lsu_unstall, du_stall, mac_stall, 
   force_dslot_fetch, abort_ex,
   genpc_freeze, if_freeze, id_freeze, ex_freeze, wb_freeze, saving_if_insn,
   fpu_done, mtspr_done,
   icpu_ack_i, icpu_err_i
   );

//
// I/O
//
input				clk;
input				rst;
input	[ 3-1:0]	multicycle;
input   [ 2-1:0] 	wait_on;   
input				flushpipe;
input				extend_flush;
input				lsu_stall;
input				if_stall;
input				lsu_unstall;
input				force_dslot_fetch;
input				abort_ex;
input				du_stall;
input				mac_stall;
output				genpc_freeze;
output				if_freeze;
output				id_freeze;
output				ex_freeze;
output				wb_freeze;
input                           saving_if_insn;
input   			fpu_done;
input   			mtspr_done;   
input				icpu_ack_i;
input				icpu_err_i;

//
// Internal wires and regs
//
wire				multicycle_freeze;
reg	[ 3-1:0]	multicycle_cnt;
reg				flushpipe_r;
reg [ 2-1:0]	waiting_on;
   
//
// Pipeline freeze
//
// Rules how to create freeze signals:
// 1. Not overwriting pipeline stages:
// Freeze signals at the beginning of pipeline (such as if_freeze) can be 
// asserted more often than freeze signals at the of pipeline (such as 
// wb_freeze). In other words, wb_freeze must never be asserted when ex_freeze 
// is not. ex_freeze must never be asserted when id_freeze is not etc.
//
// 2. Inserting NOPs in the middle of pipeline only if supported:
// At this time, only ex_freeze (and wb_freeze) can be deassrted when id_freeze
// (and if_freeze) are asserted.
// This way NOP is asserted from stage ID into EX stage.
//

assign genpc_freeze = (du_stall & !saving_if_insn) | flushpipe_r;
assign if_freeze = id_freeze | extend_flush;

assign id_freeze = (lsu_stall | (~lsu_unstall & if_stall) | multicycle_freeze 
		    | (|waiting_on) | force_dslot_fetch) | du_stall;
assign ex_freeze = wb_freeze;

assign wb_freeze = (lsu_stall | (~lsu_unstall & if_stall) | multicycle_freeze 
		    | (|waiting_on)) | du_stall | abort_ex;

//
// registered flushpipe
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		flushpipe_r <=  1'b0;
	else if (icpu_ack_i | icpu_err_i)
//	else if (!if_stall)
		flushpipe_r <=  flushpipe;
	else if (!flushpipe)
		flushpipe_r <=  1'b0;
		
//
// Multicycle freeze
//
assign multicycle_freeze = |multicycle_cnt;

//
// Multicycle counter
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		multicycle_cnt <=   3'd0;
	else if (|multicycle_cnt)
		multicycle_cnt <=  multicycle_cnt -  3'd1;
	else if (|multicycle & !ex_freeze)
		multicycle_cnt <=  multicycle;


//
// Waiting on generation
//
always @(posedge clk or       posedge rst)
  if (rst ==       (1'b1))
    waiting_on <= 0;
  else if ((waiting_on ==      2'd1) & !mac_stall)
    waiting_on <= 0;   
  else if ((waiting_on ==          2'd2) & fpu_done)
    waiting_on <= 0;
  else if ((waiting_on ==        2'd3) & mtspr_done)
    waiting_on <= 0;
  else if (!ex_freeze)
    waiting_on <= wait_on;
   
	   
endmodule

`line 1 "../../rtl/verilog/or1200_genpc.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's generate PC                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  PC, interface to IC.                                        ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_genpc.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 50 "../../rtl/verilog/or1200_genpc.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 51 "../../rtl/verilog/or1200_genpc.v" 2

module or1200_genpc(
	// Clock and reset
	clk, rst,

	// External i/f to IC
	icpu_adr_o, icpu_cycstb_o, icpu_sel_o, icpu_tag_o,
	icpu_rty_i, icpu_adr_i,

	// Internal i/f
	pre_branch_op, branch_op, except_type, except_prefix,
	id_branch_addrtarget, ex_branch_addrtarget, muxed_b, operand_b, 
	flag, flagforw, ex_branch_taken, except_start,
	epcr, spr_dat_i, spr_pc_we, genpc_refetch,
	genpc_freeze, no_more_dslot, lsu_stall, du_flush_pipe, spr_dat_npc
);

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// External i/f to IC
//
output	[31:0]			icpu_adr_o;
output				icpu_cycstb_o;
output	[3:0]			icpu_sel_o;
output	[3:0]			icpu_tag_o;
input				icpu_rty_i;
input	[31:0]			icpu_adr_i;

//
// Internal i/f
//
input   [  3-1:0]    pre_branch_op;
input	[  3-1:0]	branch_op;
input	[ 4-1:0]	except_type;
input					except_prefix;
input	[31:2]			id_branch_addrtarget;
input	[31:2]			ex_branch_addrtarget;
input	[31:0]			muxed_b;
input	[31:0]			operand_b;
input				flag;
input				flagforw;
output				ex_branch_taken;
input				except_start;
input	[31:0]			epcr;
input	[31:0]			spr_dat_i;
input				spr_pc_we;
input [31:0] 			spr_dat_npc;
input				genpc_refetch;
input				genpc_freeze;
input				no_more_dslot;
input				lsu_stall;
input				du_flush_pipe;

parameter boot_adr =  32'h00000100;
//
// Internal wires and regs
//
reg	[31:2]			pcreg_default;
reg				pcreg_select;
reg	[31:2]			pcreg;
reg	[31:0]			pc;
// Set in event of jump or taken branch   
reg				ex_branch_taken;
reg				genpc_refetch_r;
reg				wait_lsu;

   //
   // Address of insn to be fecthed
   //
   assign icpu_adr_o = !no_more_dslot & !except_start & !spr_pc_we & !du_flush_pipe
		       & (icpu_rty_i | genpc_refetch) ? 
		       icpu_adr_i : {pc[31:2], 1'b0, ex_branch_taken|spr_pc_we};

   //
   // Control access to IC subsystem
   //
   assign icpu_cycstb_o = ~(genpc_freeze | (|pre_branch_op && !icpu_rty_i) | wait_lsu);
   assign icpu_sel_o = 4'b1111;
   assign icpu_tag_o =   4'h1 ;

   //
   // wait_lsu
   //
   always @(posedge clk or       posedge rst)
     if (rst ==       (1'b1))
       wait_lsu <=  1'b0;
     else if (!wait_lsu & |pre_branch_op & lsu_stall)
       wait_lsu <=  1'b1;
     else if (wait_lsu & ~|pre_branch_op)
       wait_lsu <=  1'b0;

   //
   // genpc_freeze_r
   //
   always @(posedge clk or       posedge rst)
     if (rst ==       (1'b1))
       genpc_refetch_r <=  1'b0;
     else if (genpc_refetch)
       genpc_refetch_r <=  1'b1;
     else
       genpc_refetch_r <=  1'b0;

   //
   // Async calculation of new PC value. This value is used for addressing the
   // IC.
   //
   always @(pcreg or ex_branch_addrtarget or flag or branch_op or except_type
	    or except_start or operand_b or epcr or spr_pc_we or spr_dat_i or 
	    except_prefix or du_flush_pipe) 
     begin
	casez ({du_flush_pipe, spr_pc_we, except_start, branch_op}) // synopsys parallel_case
	  {3'b000,   3'd0}: begin
	     pc = {pcreg + 30'd1, 2'b0};
	     ex_branch_taken = 1'b0;
	  end
	  {3'b000,   3'd1}: begin
                     
                               
                                                              
                                       
                              
      
	     pc = {ex_branch_addrtarget, 2'b00};
	     ex_branch_taken = 1'b1;
	  end
	  {3'b000,   3'd2}: begin
                     
                               
                                                      
                          
                              
      
	     pc = operand_b;
	     ex_branch_taken = 1'b1;
	  end
	  {3'b000,   3'd4}:
	    if (flag) begin
                     
                                 
                                                                   
                                
                                
      
	       pc = {ex_branch_addrtarget, 2'b00};
	       ex_branch_taken = 1'b1;
	    end
	    else begin
                     
                                 
                                                      
                                
      
	       pc = {pcreg + 30'd1, 2'b0};
	       ex_branch_taken = 1'b0;
	    end
	  {3'b000,   3'd5}:
	    if (flag) begin
                     
                                 
                                                       
                                
      
	       pc = {pcreg + 30'd1, 2'b0};
	       ex_branch_taken = 1'b0;
	    end
	    else begin
                     
                                 
                                                                    
                                
                                
      
	       pc = {ex_branch_addrtarget, 2'b00};
	       ex_branch_taken = 1'b1;
	    end
	  {3'b000,   3'd6}: begin
                     
                               
                                                  
                     
                              
      
	     pc = epcr;
	     ex_branch_taken = 1'b1;
	  end
	  {3'b100, 3'b???}: begin
                     
                               
                                                           
                              
      
	     pc = spr_dat_npc;
	     ex_branch_taken = 1'b1;
	  end
	  {3'b001, 3'b???}: begin
                     
                               
                                                       
                              
      
	     pc = {(except_prefix ? 
		        20'hF0000 :     20'h00000), 
		   except_type,       8'h00};
	     ex_branch_taken = 1'b1;
	  end
	  default: begin
                     
                               
                                                          
                              
      
	     pc = spr_dat_i;
	     ex_branch_taken = 1'b0;
	  end
	endcase
     end

   // select async. value for pcreg after reset - PC jumps to the address selected
   // after boot.
   wire [31:0] pcreg_boot = boot_adr;

   //
   // PC register
   //
   always @(posedge clk or       posedge rst)
     // default value 
     if (rst ==       (1'b1)) begin
	pcreg_default <=  (boot_adr >>2) - 4;
	pcreg_select <=  1'b1;// select async. value due to reset state
     end
   // selected value (different from default) is written into FF after
   // reset state
     else if (pcreg_select) begin
	// dynamic value can only be assigned to FF out of reset! 
	pcreg_default <=  pcreg_boot[31:2];	
	pcreg_select <=  1'b0;		// select FF value 
     end
     else if (spr_pc_we) begin
	pcreg_default <=  spr_dat_i[31:2];
     end
     else if (du_flush_pipe | no_more_dslot | except_start | !genpc_freeze & !icpu_rty_i 
	      & !genpc_refetch) begin
	pcreg_default <=  pc[31:2];
     end

   always @(pcreg_boot or pcreg_default or pcreg_select)
     if (pcreg_select)
       // async. value is selected due to reset state 
       pcreg = pcreg_boot[31:2];
     else
       // FF value is selected 2nd clock after reset state 
       pcreg = pcreg_default ;

endmodule

`line 1 "../../rtl/verilog/or1200_gmultp2_32x32.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic 32x32 multiplier                                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Generic 32x32 multiplier with pipeline stages.              ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_gmultp2_32x32.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 52 "../../rtl/verilog/or1200_gmultp2_32x32.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 53 "../../rtl/verilog/or1200_gmultp2_32x32.v" 2

// 32x32 multiplier, no input/output registers
// Registers inside Wallace trees every 8 full adder levels,
// with first pipeline after level 4

                                  

                   
                    

module or1200_gmultp2_32x32 ( X, Y, CLK, RST, P );

input   [ 32-1:0]  X;
input   [ 32-1:0]  Y;
input           CLK;
input           RST;
output  [ 64-1:0]  P;

reg     [ 64-1:0]  p0;
reg     [ 64-1:0]  p1;
integer 		  xi;
integer 		  yi;

//
// Conversion unsigned to signed
//
always @(X)
	xi = X;

//
// Conversion unsigned to signed
//
always @(Y)
	yi = Y;

//
// First multiply stage
//
always @(posedge CLK or       posedge RST)
        if (RST ==       (1'b1))
                p0 <=  64'b0;
        else
                p0 <=  xi * yi;

//
// Second multiply stage
//
always @(posedge CLK or       posedge RST)
        if (RST ==       (1'b1))
                p1 <=  64'b0;
        else
                p1 <=  p0;

assign P = p1;

endmodule

      

`line 1 "../../rtl/verilog/or1200_ic_fsm.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's IC FSM                                             ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Insn cache state machine                                    ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_ic_fsm.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_ic_fsm.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_ic_fsm.v" 2

                              
                                
                                  
                                

//
// Instruction cache FSM
//

module or1200_ic_fsm(
	// Clock and reset
	clk, rst,

	// Internal i/f to top level IC
	ic_en, icqmem_cycstb_i, icqmem_ci_i,
	tagcomp_miss, 
	biudata_valid, biudata_error, 
        start_addr, saved_addr,
	icram_we, tag_we,
        biu_read, 
        first_hit_ack, first_miss_ack, first_miss_err,
	burst
);

//
// I/O
//
input				clk;
input				rst;
input				ic_en;
input				icqmem_cycstb_i;
input				icqmem_ci_i;
input				tagcomp_miss;
input				biudata_valid;
input				biudata_error;
input	[31:0]			start_addr;
output	[31:0]			saved_addr;
output	[3:0]			icram_we;
output				biu_read;
output				first_hit_ack;
output				first_miss_ack;
output				first_miss_err;
output				burst;
output				tag_we;

//
// Internal wires and regs
//
reg	[31:0]			saved_addr_r;
reg	[1:0]			state;
reg [  4-1:0]    	cnt;
reg				hitmiss_eval;
reg				load;
reg				cache_inhibit;
reg 				last_eval_miss; // JPB
   
   //
   // Generate of ICRAM write enables
   //
   assign icram_we = {4{biu_read & biudata_valid & !cache_inhibit}};
   assign tag_we = biu_read & biudata_valid & !cache_inhibit;

   //
   // BIU read and write
   //
   assign biu_read = (hitmiss_eval & tagcomp_miss) | (!hitmiss_eval & load);

   //assign saved_addr = hitmiss_eval ? start_addr : saved_addr_r;
   assign saved_addr = saved_addr_r;

   // Asserted when a cache hit occurs and the first word is ready/valid
   assign first_hit_ack = (state ==  2'd1) & hitmiss_eval & 
			  !tagcomp_miss & !cache_inhibit;

   // Asserted when a cache miss occurs, but the first word of the new
   // cache line is ready (on the bus)
   // Cache hits overpower bus data
   assign first_miss_ack = (state ==  2'd1) & biudata_valid &
			   ~first_hit_ack;
   
   // Asserted when a cache occurs, but there was a bus error with handling
   // the old line or fetching the new line
   assign first_miss_err = (state ==  2'd1) & biudata_error;

   //
   // Assert burst when doing reload of complete cache line
   //
   assign burst = (state ==  2'd1) & tagcomp_miss & 
		  !cache_inhibit | (state ==  2'd2);

   //
   // Main IC FSM
   //
   always @(posedge clk or       posedge rst) begin
      if (rst ==       (1'b1)) begin
	 state <=   2'd0;
	 saved_addr_r <=  32'b0;
	 hitmiss_eval <=  1'b0;
	 load <=  1'b0;
	 cnt <=    4'd0;
	 cache_inhibit <=  1'b0;
	 last_eval_miss <= 0; // JPB
	 
      end
      else
	case (state)	// synopsys parallel_case
	   2'd0 :
	    if (ic_en & icqmem_cycstb_i) begin		// fetch
	       state <=   2'd1;
	       saved_addr_r <=  start_addr;
	       hitmiss_eval <=  1'b1;
	       load <=  1'b1;
	       cache_inhibit <=  icqmem_ci_i;
	       last_eval_miss <= 0; // JPB
	    end
	    else begin			// idle
	       hitmiss_eval <=  1'b0;
	       load <=  1'b0;
	       cache_inhibit <=  1'b0;
	    end	  
	   2'd1: begin	// fetch
	     
	     if (icqmem_cycstb_i & icqmem_ci_i)
	       cache_inhibit <=  1'b1;
	     
	     if (hitmiss_eval)
	       saved_addr_r[31:         13   -1 +1 ] <= start_addr[31:         13   -1 +1 ];

	     // Check for stopped cache loads
	         // instruction cache turned-off
	     if ((!ic_en) ||
		 // fetch aborted (usually caused by IMMU)
		 (hitmiss_eval & !icqmem_cycstb_i) ||	
		 (biudata_error) ||  // fetch terminated with an error
		 // fetch from cache-inhibited page
		 (cache_inhibit & biudata_valid)) begin	
		state <=   2'd0;
		hitmiss_eval <=  1'b0;
		load <=  1'b0;
		cache_inhibit <=  1'b0;
	     end // if ((!ic_en) ||...	     
	     // fetch missed, wait for first fetch and continue filling line
	     else if (tagcomp_miss & biudata_valid) begin	
		state <=   2'd2;
		saved_addr_r[  4-1:2] 
		  <= saved_addr_r[  4-1:2] + 1;
		hitmiss_eval <=  1'b0;
		cnt <= ((1 <<   4) - (2 * 4));
		cache_inhibit <=  1'b0;
	     end
	     // fetch aborted (usually caused by exception)
	     else if (!icqmem_cycstb_i
		      & !last_eval_miss // JPB
		      ) begin	
		state <=   2'd0;
		hitmiss_eval <=  1'b0;
		load <=  1'b0;
		cache_inhibit <=  1'b0;
	     end
	     // fetch hit, wait in this state for now
	     else if (!tagcomp_miss & !icqmem_ci_i) begin
		saved_addr_r <=  start_addr;
		cache_inhibit <=  1'b0;
	     end
	     else   // fetch in-progress
	       hitmiss_eval <=  1'b0;

	     if (hitmiss_eval & !tagcomp_miss) // JPB
	       last_eval_miss <= 1; // JPB
	     
	  end
	   2'd2 : begin
	     // abort because IC has just been turned off
             if (!ic_en) begin
		// invalidate before IC can be turned on
		state <=   2'd0;	
                saved_addr_r <=  start_addr;
                hitmiss_eval <=  1'b0;
                load <=  1'b0;
             end
	     // refill ack, more fetchs to come
	     else if (biudata_valid && (|cnt)) begin	
		cnt <=  cnt -   4'd4;
		saved_addr_r[  4-1:2] 
		  <= saved_addr_r[  4-1:2] + 1;
	     end
	     // last fetch of line refill
	     else if (biudata_valid) begin
		state <=   2'd0;
		saved_addr_r <=  start_addr;
		hitmiss_eval <=  1'b0;
		load <=  1'b0;
	     end
	  end
	  default:
	    state <=   2'd0;
	endcase
   end

endmodule

`line 1 "../../rtl/verilog/or1200_ic_ram.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's IC RAMs                                            ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of Instruction cache data rams                ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_ic_ram.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 53 "../../rtl/verilog/or1200_ic_ram.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 54 "../../rtl/verilog/or1200_ic_ram.v" 2

module or1200_ic_ram(
	// Clock and reset
	clk, rst, 

                  
            
                                      
      

	// Internal i/f
	addr, en, we, datain, dataout
);

parameter dw =   32;
parameter aw =       13   -2 ;

//
// I/O
//
input 				clk;
input				rst;
input	[aw-1:0]		addr;
input				en;
input	[3:0]			we;
input	[dw-1:0]		datain;
output	[dw-1:0]		dataout;

                  
  
           
  
                 
                                                    
                  
      

                   

  
                             
  
                            
                  
                               
      

     

//
// Instantiation of IC RAM block
//
   or1200_spram #
     (
      .aw(      13   -2 ),
      .dw(32)
      )
   ic_ram0
     (
                  
                 
                              
                              
                                  
      
      .clk(clk),
      .ce(en),
      .we(we[0]),
      //.oe(1'b1),
      .addr(addr),
      .di(datain),
      .doq(dataout)
      );   
      

endmodule


`line 1 "../../rtl/verilog/or1200_ic_tag.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's IC TAGs                                            ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Instatiation of instruction cache tag rams                  ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_ic_tag.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 53 "../../rtl/verilog/or1200_ic_tag.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 54 "../../rtl/verilog/or1200_ic_tag.v" 2

module or1200_ic_tag(
	// Clock and reset
	clk, rst,

                  
            
                                      
      

	// Internal i/f
	addr, en, we, datain, tag_v, tag
);

parameter dw =    20;
parameter aw =       13   -  4 ;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

                  
  
           
  
                 
                                                    
                  
      

//
// Internal i/f
//
input	[aw-1:0]		addr;
input				en;
input				we;
input	[dw-1:0]		datain;
output				tag_v;
output	[dw-2:0]		tag;

                   

  
                             
  
                          
                    
                  
                               
      

     

//
// Instantiation of TAG RAM block
//
   or1200_spram #
     (
      .aw(      13   -  4 ),
      .dw(   20)
      )
   ic_tag0
     (
                  
                 
                              
                              
                                  
      
      .clk(clk),
      .ce(en),
      .we(we),
      //.oe(1'b1),
      .addr(addr),
      .di(datain),
      .doq({tag, tag_v})
      );   
      

endmodule

`line 1 "../../rtl/verilog/or1200_ic_top.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Instruction Cache top level                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of all IC blocks.                             ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_ic_top.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 49 "../../rtl/verilog/or1200_ic_top.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 50 "../../rtl/verilog/or1200_ic_top.v" 2

//
// Instruction cache top
//
module or1200_ic_top(
	// Rst, clk and clock control
	clk, rst,

	// External i/f
	icbiu_dat_o, icbiu_adr_o, icbiu_cyc_o, icbiu_stb_o, icbiu_we_o, 
	icbiu_sel_o, icbiu_cab_o, icbiu_dat_i, icbiu_ack_i, icbiu_err_i,

	// Internal i/f
	ic_en,
	icqmem_adr_i, icqmem_cycstb_i, icqmem_ci_i, icqmem_sel_i, icqmem_tag_i,
	icqmem_dat_o, icqmem_ack_o, icqmem_rty_o, icqmem_err_o, icqmem_tag_o,

                  
            
                                      
      

	// SPRs
	spr_cs, spr_write, spr_dat_i
);

parameter dw =   32;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// External I/F
//
output	[dw-1:0]		icbiu_dat_o;
output	[31:0]			icbiu_adr_o;
output				icbiu_cyc_o;
output				icbiu_stb_o;
output				icbiu_we_o;
output	[3:0]			icbiu_sel_o;
output				icbiu_cab_o;
input	[dw-1:0]		icbiu_dat_i;
input				icbiu_ack_i;
input				icbiu_err_i;

//
// Internal I/F
//
input				ic_en;
input	[31:0]			icqmem_adr_i;
input				icqmem_cycstb_i;
input				icqmem_ci_i;
input	[3:0]			icqmem_sel_i;
input	[3:0]			icqmem_tag_i;
output	[dw-1:0]		icqmem_dat_o;
output				icqmem_ack_o;
output				icqmem_rty_o;
output				icqmem_err_o;
output	[3:0]			icqmem_tag_o;

                  
  
           
  
                 
                                                    
                  
      

//
// SPR access
//
input				spr_cs;
input				spr_write;
input	[31:0]			spr_dat_i;

//
// Internal wires and regs
//
wire				tag_v;
wire	[   20-2:0]	tag;
wire	[dw-1:0]		to_icram;
wire	[dw-1:0]		from_icram;
wire	[31:0]			saved_addr;
wire	[3:0]			icram_we;
wire				ictag_we;
wire	[31:0]			ic_addr;
wire				icfsm_biu_read;
/* verilator lint_off UNOPTFLAT */    
reg				tagcomp_miss;
/* verilator lint_on UNOPTFLAT */    
wire	[      13   -1 :  4]	ictag_addr;
wire				ictag_en;
wire				ictag_v; 
wire				ic_inv;
wire				icfsm_first_hit_ack;
wire				icfsm_first_miss_ack;
wire				icfsm_first_miss_err;
wire				icfsm_burst;
wire				icfsm_tag_we;
reg 				ic_inv_q;
   
                  
  
           
  
                     
                     
                                  
                                    
                                    
      

//
// Simple assignments
//
assign icbiu_adr_o = ic_addr;
assign ic_inv = spr_cs & spr_write;
assign ictag_we = icfsm_tag_we | ic_inv;
assign ictag_addr = ic_inv ? 
		    spr_dat_i[      13   -1 :  4] : 
		    ic_addr[      13   -1 :  4];
assign ictag_en = ic_inv | ic_en;
assign ictag_v = ~ic_inv;

//
// Data to BIU is from ICRAM when IC is enabled or from LSU when
// IC is disabled
//
assign icbiu_dat_o = 32'h00000000;

//
// Bypases of the IC when IC is disabled
//
assign icbiu_cyc_o = (ic_en) ? icfsm_biu_read : icqmem_cycstb_i;
assign icbiu_stb_o = (ic_en) ? icfsm_biu_read : icqmem_cycstb_i;
assign icbiu_we_o = 1'b0;
assign icbiu_sel_o = (ic_en & icfsm_biu_read) ? 4'b1111 : icqmem_sel_i;
assign icbiu_cab_o = (ic_en) ? icfsm_burst : 1'b0;
assign icqmem_rty_o = ~icqmem_ack_o & ~icqmem_err_o;
assign icqmem_tag_o = icqmem_err_o ?   4'hb  : icqmem_tag_i;

//
// CPU normal and error termination
//
assign icqmem_ack_o = ic_en ? (icfsm_first_hit_ack | icfsm_first_miss_ack) : icbiu_ack_i;
assign icqmem_err_o = ic_en ? icfsm_first_miss_err : icbiu_err_i;

//
// Select between claddr generated by IC FSM and addr[3:2] generated by LSU
//
assign ic_addr = (icfsm_biu_read) ? saved_addr : icqmem_adr_i;

//
// Select between input data generated by LSU or by BIU
//
assign to_icram = icbiu_dat_i;

//
// Select between data generated by ICRAM or passed by BIU
//
assign icqmem_dat_o = icfsm_first_miss_ack | !ic_en ? icbiu_dat_i : from_icram;

//
// Detect falling edge of IC invalidate signal
// 
always @(posedge clk or       posedge rst)
   if (rst==      (1'b1))
     ic_inv_q <= 1'b0;
   else
     ic_inv_q <= ic_inv;
   
   
//
// Tag comparison
//
// During line invalidate, ensure it stays the same
always @(tag or saved_addr or tag_v) begin
	  if ((tag != saved_addr[31:         13   -1 +1 ]) | !tag_v)
	    tagcomp_miss = 1'b1;
	  else
	    tagcomp_miss = 1'b0;
end

//
// Instantiation of IC Finite State Machine
//
or1200_ic_fsm or1200_ic_fsm(
	.clk(clk),
	.rst(rst),
	.ic_en(ic_en),
	.icqmem_cycstb_i(icqmem_cycstb_i),
	.icqmem_ci_i(icqmem_ci_i),
	.tagcomp_miss(tagcomp_miss),
	.biudata_valid(icbiu_ack_i),
	.biudata_error(icbiu_err_i),
	.start_addr(icqmem_adr_i),
	.saved_addr(saved_addr),
	.icram_we(icram_we),
	.biu_read(icfsm_biu_read),
	.first_hit_ack(icfsm_first_hit_ack),
	.first_miss_ack(icfsm_first_miss_ack),
	.first_miss_err(icfsm_first_miss_err),
	.burst(icfsm_burst),
	.tag_we(icfsm_tag_we)
);

//
// Instantiation of IC main memory
//
or1200_ic_ram or1200_ic_ram(
	.clk(clk),
	.rst(rst),
                  
            
                           
                           
                             
      
	.addr(ic_addr[      13   -1 :2]),
	.en(ic_en),
	.we(icram_we),
	.datain(to_icram),
	.dataout(from_icram)
);

//
// Instantiation of IC TAG memory
//
or1200_ic_tag or1200_ic_tag(
	.clk(clk),
	.rst(rst),
                  
            
                           
                           
                             
      
	.addr(ictag_addr),
	.en(ictag_en),
	.we(ictag_we),
	.datain({ic_addr[31:         13   -1 +1 ], ictag_v}),
	.tag_v(tag_v),
	.tag(tag)
);

endmodule

`line 1 "../../rtl/verilog/or1200_if.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's instruction fetch                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  PC, instruction fetch, interface to IC.                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_if.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 50 "../../rtl/verilog/or1200_if.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 51 "../../rtl/verilog/or1200_if.v" 2

module or1200_if(
	// Clock and reset
	clk, rst,

	// External i/f to IC
	icpu_dat_i, icpu_ack_i, icpu_err_i, icpu_adr_i, icpu_tag_i,

	// Internal i/f
	if_freeze, if_insn, if_pc, if_flushpipe, saving_if_insn, 
	if_stall, no_more_dslot, genpc_refetch, rfe,
	except_itlbmiss, except_immufault, except_ibuserr
);

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// External i/f to IC
//
input	[31:0]			icpu_dat_i;
input				icpu_ack_i;
input				icpu_err_i;
input	[31:0]			icpu_adr_i;
input	[3:0]			icpu_tag_i;

//
// Internal i/f
//
input				if_freeze;
output	[31:0]			if_insn;
output	[31:0]			if_pc;
input				if_flushpipe;
output				saving_if_insn;
output				if_stall;
input				no_more_dslot;
output				genpc_refetch;
input				rfe;
output				except_itlbmiss;
output				except_immufault;
output				except_ibuserr;

//
// Internal wires and regs
//
wire			save_insn;
wire			if_bypass;
reg			if_bypass_reg;
reg	[31:0]		insn_saved;
reg	[31:0]		addr_saved;
reg	[2:0]		err_saved;
reg			saved;

assign save_insn = (icpu_ack_i | icpu_err_i) & if_freeze & !saved;
assign saving_if_insn = !if_flushpipe & save_insn;

//
// IF bypass 
//
assign if_bypass = icpu_adr_i[0] ? 1'b0 : if_bypass_reg | if_flushpipe;

always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		if_bypass_reg <=  1'b0;
	else
		if_bypass_reg <=  if_bypass;

//
// IF stage insn
//
assign if_insn = no_more_dslot | rfe | if_bypass ? {               6'b000101, 26'h041_0000} : saved ? insn_saved : icpu_ack_i ? icpu_dat_i : {               6'b000101, 26'h061_0000};
assign if_pc = saved ? addr_saved : {icpu_adr_i[31:2], 2'h0};
assign if_stall = !icpu_err_i & !icpu_ack_i & !saved;
assign genpc_refetch = saved & icpu_ack_i;
assign except_itlbmiss = no_more_dslot ? 1'b0 : saved ? err_saved[0] : icpu_err_i & (icpu_tag_i ==   4'hd );
assign except_immufault = no_more_dslot ? 1'b0 : saved ? err_saved[1] : icpu_err_i & (icpu_tag_i ==   4'hc );
assign except_ibuserr = no_more_dslot ? 1'b0 : saved ? err_saved[2] : icpu_err_i & (icpu_tag_i ==   4'hb );

//
// Flag for saved insn/address
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		saved <=  1'b0;
	else if (if_flushpipe)
		saved <=  1'b0;
	else if (save_insn)
		saved <=  1'b1;
	else if (!if_freeze)
		saved <=  1'b0;

//
// Store fetched instruction
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		insn_saved <=  {               6'b000101, 26'h041_0000};
	else if (if_flushpipe)
		insn_saved <=  {               6'b000101, 26'h041_0000};
	else if (save_insn)
		insn_saved <=  icpu_err_i ? {               6'b000101, 26'h041_0000} : icpu_dat_i;
	else if (!if_freeze)
		insn_saved <=  {               6'b000101, 26'h041_0000};

//
// Store fetched instruction's address
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		addr_saved <=  32'h00000000;
	else if (if_flushpipe)
		addr_saved <=  32'h00000000;
	else if (save_insn)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};
	else if (!if_freeze)
		addr_saved <=  {icpu_adr_i[31:2], 2'b00};

//
// Store fetched instruction's error tags 
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		err_saved <=  3'b000;
	else if (if_flushpipe)
		err_saved <=  3'b000;
	else if (save_insn) begin
		err_saved[0] <=  icpu_err_i & (icpu_tag_i ==   4'hd );
		err_saved[1] <=  icpu_err_i & (icpu_tag_i ==   4'hc );
		err_saved[2] <=  icpu_err_i & (icpu_tag_i ==   4'hb );
	end
	else if (!if_freeze)
		err_saved <=  3'b000;


endmodule

`line 1 "../../rtl/verilog/or1200_immu_tlb.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Instruction TLB                                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of ITLB.                                      ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_immu_tlb.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed, coding style changed. 
//
// Revision 1.9  2004/06/08 18:17:36  lampret
// Non-functional changes. Coding style fixes.
//
// Revision 1.8  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.6.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.6  2002/10/28 16:34:32  mohor
// RAMs wrong connected to the BIST scan chain.
//
// Revision 1.5  2002/10/17 20:04:40  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.4  2002/08/14 06:23:50  lampret
// Disabled ITLB translation when 1) doing access to ITLB SPRs or 2) crossing page. This modification was tested only with parts of IMMU test - remaining test cases needs to be run.
//
// Revision 1.3  2002/02/11 04:33:17  lampret
// Speed optimizations (removed duplicate _cyc_ and _stb_). Fixed D/IMMU cache-inhibit attr.
//
// Revision 1.2  2002/01/28 01:16:00  lampret
// Changed 'void' nop-ops instead of insn[0] to use insn[16]. Debug unit stalls the tick timer. Prepared new flag generation for add and and insns. Blocked DC/IC while they are turned off. Fixed I/D MMU SPRs layout except WAYs. TODO: smart IC invalidate, l.j 2 and TLB ways.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.8  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.7  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 90 "../../rtl/verilog/or1200_immu_tlb.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 91 "../../rtl/verilog/or1200_immu_tlb.v" 2

//
// Insn TLB
//

module or1200_immu_tlb(
	// Rst and clk
	clk, rst,

	// I/F for translation
	tlb_en, vaddr, hit, ppn, uxe, sxe, ci, 

                  
            
                                      
      

	// SPR access
	spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o
);

parameter dw =   32;
parameter aw =   32;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// I/F for translation
//
input				tlb_en;
input	[aw-1:0]		vaddr;
output				hit;
output	[31:  13     ]	ppn;
output				uxe;
output				sxe;
output				ci;

                  
  
           
  
                 
                                                    
                  
      

//
// SPR access
//
input				spr_cs;
input				spr_write;
input	[31:0]			spr_addr;
input	[31:0]			spr_dat_i;
output	[31:0]			spr_dat_o;

//
// Internal wires and regs
//
wire	[  31:    13     + 6     -1 +1      ]	vpn;
wire				v;
wire	[ 6     -1:0]	tlb_index;
wire				tlb_mr_en;
wire				tlb_mr_we;
wire	[   32- 6     -  13      +1   -1:0]	tlb_mr_ram_in;
wire	[   32- 6     -  13      +1   -1:0]	tlb_mr_ram_out;
wire				tlb_tr_en;
wire				tlb_tr_we;
wire	[  32-  13     +3   -1:0]	tlb_tr_ram_in;
wire	[  32-  13     +3   -1:0]	tlb_tr_ram_out;

// BIST
                  
                                           
                                           
                                           
                                           
      

//
// Implemented bits inside match and translate registers
//
// itlbwYmrX: vpn 31-19  v 0
// itlbwYtrX: ppn 31-13  uxe 7  sxe 6
//
// itlb memory width:
// 19 bits for ppn
// 13 bits for vpn
// 1 bit for valid
// 2 bits for protection
// 1 bit for cache inhibit

//
// Enable for Match registers
//
assign tlb_mr_en = tlb_en | (spr_cs & !spr_addr[ 7]);

//
// Write enable for Match registers
//
assign tlb_mr_we = spr_cs & spr_write & !spr_addr[ 7];

//
// Enable for Translate registers
//
assign tlb_tr_en = tlb_en | (spr_cs & spr_addr[ 7]);

//
// Write enable for Translate registers
//
assign tlb_tr_we = spr_cs & spr_write & spr_addr[ 7];

//
// Output to SPRS unit
//
assign spr_dat_o = (!spr_write & !spr_addr[ 7]) ?
            {vpn, tlb_index, { 32- 6     -  13      -7{1'b0}}, 1'b0, 5'b00000, v} :
		(!spr_write & spr_addr[ 7]) ?
			{ppn, {  13     -8{1'b0}}, uxe, sxe, {4{1'b0}}, ci, 1'b0} :
			32'h00000000;

//
// Assign outputs from Match registers
//
assign {vpn, v} = tlb_mr_ram_out;

//
// Assign to Match registers inputs
//
assign tlb_mr_ram_in = {spr_dat_i[  31:    13     + 6     -1 +1      ], spr_dat_i[ 0]};

//
// Assign outputs from Translate registers
//
assign {ppn, uxe, sxe, ci} = tlb_tr_ram_out;

//
// Assign to Translate registers inputs
//
assign tlb_tr_ram_in = {spr_dat_i[31:  13     ],
			spr_dat_i[ 7],
			spr_dat_i[ 6],
			spr_dat_i[ 1]};

//
// Generate hit
//
assign hit = (vpn == vaddr[  31:    13     + 6     -1 +1      ]) & v;

//
// TLB index is normally vaddr[18:13]. If it is SPR access then index is
// spr_addr[5:0].
//
assign tlb_index = spr_cs ? spr_addr[ 6     -1:0] : vaddr[    13     + 6     -1 :   13          ];


                  
                                   
                                       
                                   
      


//
// Instantiation of ITLB Match Registers
//
   or1200_spram #
     (
      .aw(6),
      .dw(14)
      )
   itlb_mr_ram
     (
      .clk(clk),
                  
                 
                                  
                                  
                                  
      
      .ce(tlb_mr_en),
      .we(tlb_mr_we),
      //.oe(1'b1),
      .addr(tlb_index),
      .di(tlb_mr_ram_in),
      .doq(tlb_mr_ram_out)
      );

//
// Instantiation of ITLB Translate Registers
//
   or1200_spram #
     (
      .aw(6),
      .dw(22)
      )
   itlb_tr_ram
     (
      .clk(clk),
                  
                 
                                  
                                  
                                  
      
      .ce(tlb_tr_en),
      .we(tlb_tr_we),
      //.oe(1'b1),
      .addr(tlb_index),
      .di(tlb_tr_ram_in),
      .doq(tlb_tr_ram_out)
      );
   
endmodule

`line 1 "../../rtl/verilog/or1200_immu_top.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Instruction MMU top level                          ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of all IMMU blocks.                           ////
////                                                              ////
////  To Do:                                                      ////
////   - cache inhibit                                            ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 45 "../../rtl/verilog/or1200_immu_top.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 46 "../../rtl/verilog/or1200_immu_top.v" 2

//
// Insn MMU
//

module or1200_immu_top(
	// Rst and clk
	clk, rst,

	// CPU i/f
	ic_en, immu_en, supv, icpu_adr_i, icpu_cycstb_i,
	icpu_adr_o, icpu_tag_o, icpu_rty_o, icpu_err_o,

	// SR Interface
	boot_adr_sel_i,

	// SPR access
	spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o,

                  
            
                                      
      

	// QMEM i/f
	qmemimmu_rty_i, qmemimmu_err_i, qmemimmu_tag_i, qmemimmu_adr_o, qmemimmu_cycstb_o, qmemimmu_ci_o
);

parameter dw =   32;
parameter aw =   32;
parameter boot_adr =  32'h00000100;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// CPU I/F
//
input				ic_en;
input				immu_en;
input				supv;
input	[aw-1:0]		icpu_adr_i;
input				icpu_cycstb_i;
output	[aw-1:0]		icpu_adr_o;
output	[3:0]			icpu_tag_o;
output				icpu_rty_o;
output				icpu_err_o;

//
// SR Interface
//
input				boot_adr_sel_i;

//
// SPR access
//
input				spr_cs;
input				spr_write;
input	[aw-1:0]		spr_addr;
input	[31:0]			spr_dat_i;
output	[31:0]			spr_dat_o;

                  
  
           
  
                 
                                                    
                  
      

//
// IC I/F
//
input				qmemimmu_rty_i;
input				qmemimmu_err_i;
input	[3:0]			qmemimmu_tag_i;
output	[aw-1:0]		qmemimmu_adr_o;
output				qmemimmu_cycstb_o;
output				qmemimmu_ci_o;

//
// Internal wires and regs
//
wire				itlb_spr_access;
wire	[31:  13     ]	itlb_ppn;
wire				itlb_hit;
wire				itlb_uxe;
wire				itlb_sxe;
wire	[31:0]			itlb_dat_o;
wire				itlb_en;
wire				itlb_ci;
wire				itlb_done;
wire				fault;
wire				miss;
wire				page_cross;
reg	[31:0]			icpu_adr_default;
reg				icpu_adr_select;
reg		[31:0]		icpu_adr_o;
reg	[31:  13     ]	icpu_vpn_r;
                     
     
reg				itlb_en_r;
reg				dis_spr_access_frst_clk;
reg				dis_spr_access_scnd_clk;
      

//
// Implemented bits inside match and translate registers
//
// itlbwYmrX: vpn 31-10  v 0
// itlbwYtrX: ppn 31-10  uxe 7  sxe 6
//
// itlb memory width:
// 19 bits for ppn
// 13 bits for vpn
// 1 bit for valid
// 2 bits for protection
// 1 bit for cache inhibit

//
// icpu_adr_o
//
                                
wire	[31:0]			icpu_adr_boot = boot_adr;

always @(      posedge rst or posedge clk)
	// default value 
	if (rst ==       (1'b1)) begin
	        // select async. value due to reset state
		icpu_adr_default <=  32'h0000_0100;
		icpu_adr_select  <=  1'b1;		
	end
	// selected value (different from default) is written 
        // into FF after reset state
	else if (icpu_adr_select) begin
	        // dynamic value can only be assigned to FF out of reset!
		icpu_adr_default <=  icpu_adr_boot;
	        // select FF value 
		icpu_adr_select  <=  1'b0;
	end
	else begin
		icpu_adr_default <=  icpu_adr_i;
	end

// select async. value for boot address after reset - PC jumps to the address 
// selected after boot! 
   //assign icpu_adr_boot = {(boot_adr_sel_i ? `OR1200_EXCEPT_EPH1_P : 
   // `OR1200_EXCEPT_EPH0_P), 12'h100} ;

always @(icpu_adr_boot or icpu_adr_default or icpu_adr_select)
	if (icpu_adr_select)
	        // async. value is selected due to reset state 
		icpu_adr_o = icpu_adr_boot ;
	else
	        // FF value is selected 2nd clock after reset state 
		icpu_adr_o = icpu_adr_default ;		
     
               
      

//
// Page cross
//
// Asserted when CPU address crosses page boundary. Most of the time it is zero.
//
assign page_cross = icpu_adr_i[31:  13     ] != icpu_vpn_r;

//
// Register icpu_adr_i's VPN for use when IMMU is not enabled but PPN is expected to come
// one clock cycle after offset part.
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		icpu_vpn_r <=  {32-  13     {1'b0}};
	else
		icpu_vpn_r <=  icpu_adr_i[31:  13     ];

                     

  
                                    
  
                                
                                   
                                   
                                                       
                                   
                                   
                                       
                  
                               
      
     

//
// ITLB SPR access
//
// 1200 - 12FF  itlbmr w0
// 1200 - 123F  itlbmr w0 [63:0]
//
// 1300 - 13FF  itlbtr w0
// 1300 - 133F  itlbtr w0 [63:0]
//
assign itlb_spr_access = spr_cs & ~dis_spr_access_scnd_clk;

//
// Disable ITLB SPR access
//
// This flops are used to mask ITLB miss/fault exception
// during first & second clock cycles of accessing ITLB SPR. In
// subsequent clock cycles it is assumed that ITLB SPR
// access was accomplished and that normal instruction fetching
// can proceed.
//
// spr_cs sets dis_spr_access_frst_clk and icpu_rty_o clears it.
// dis_spr_access_frst_clk  sets dis_spr_access_scnd_clk and 
// icpu_rty_o clears it.
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dis_spr_access_frst_clk  <=  1'b0;
	else if (!icpu_rty_o)
		dis_spr_access_frst_clk  <=  1'b0;
	else if (spr_cs)
		dis_spr_access_frst_clk  <=  1'b1;

always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		dis_spr_access_scnd_clk  <=  1'b0;
	else if (!icpu_rty_o)
		dis_spr_access_scnd_clk  <=  1'b0;
	else if (dis_spr_access_frst_clk)
		dis_spr_access_scnd_clk  <=  1'b1;

//
// Tags:
//
// OR1200_ITAG_TE - TLB miss Exception
// OR1200_ITAG_PE - Page fault Exception
//
assign icpu_tag_o = miss ?   4'hd  : fault ?   4'hc  : qmemimmu_tag_i;

//
// icpu_rty_o
//
// assign icpu_rty_o = !icpu_err_o & qmemimmu_rty_i;
//assign icpu_rty_o = qmemimmu_rty_i | itlb_spr_access & immu_en;
assign icpu_rty_o = qmemimmu_rty_i;

//
// icpu_err_o
//
assign icpu_err_o = miss | fault | qmemimmu_err_i;

//
// Assert itlb_en_r after one clock cycle and when there is no
// ITLB SPR access
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		itlb_en_r <=  1'b0;
	else
		itlb_en_r <=  itlb_en & ~itlb_spr_access;

//
// ITLB lookup successful
//
assign itlb_done = itlb_en_r & ~page_cross;

//
// Cut transfer when access (mtspr/mfspr) to/from ITLB occure or if something goes 
// wrong with translation. If IC is disabled, use delayed signals.
//
// assign qmemimmu_cycstb_o = (!ic_en & immu_en) ? ~(miss | fault) & icpu_cycstb_i & ~page_cross : (miss | fault) ? 1'b0 : icpu_cycstb_i & ~page_cross; // DL
//assign qmemimmu_cycstb_o = immu_en ? ~(miss | fault) & icpu_cycstb_i & ~page_cross & itlb_done : icpu_cycstb_i & ~page_cross;
assign qmemimmu_cycstb_o = immu_en ? ~(miss | fault) & icpu_cycstb_i & ~page_cross & itlb_done & ~itlb_spr_access : icpu_cycstb_i & ~page_cross;

//
// Cache Inhibit
//
// Cache inhibit is not really needed for instruction memory subsystem.
// If we would doq it, we would doq it like this.
// assign qmemimmu_ci_o = immu_en ? itlb_done & itlb_ci : `OR1200_IMMU_CI;
// However this causes an async combinatorial loop so we stick to
// no cache inhibit.
//assign qmemimmu_ci_o = `OR1200_IMMU_CI;
// Cache inhibit without an async combinatorial loop 
assign qmemimmu_ci_o = immu_en ? itlb_ci :    1'b0;


//
// Physical address is either translated virtual address or
// simply equal when IMMU is disabled
//
//assign qmemimmu_adr_o = itlb_done ? {itlb_ppn, icpu_adr_i[`OR1200_IMMU_PS-1:0]} : {icpu_vpn_r, icpu_adr_i[`OR1200_IMMU_PS-1:0]}; // DL: immu_en
assign qmemimmu_adr_o = immu_en & itlb_done ? {itlb_ppn, icpu_adr_i[  13     -1:2], 2'h0} : {icpu_vpn_r, icpu_adr_i[  13     -1:2], 2'h0}; 

reg     [31:0]                  spr_dat_reg;
//
// Output to SPRS unit
//
// spr_dat_o is registered on the 1st clock of spr read 
// so itlb can continue with process during execution of mfspr.
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		spr_dat_reg <=  32'h0000_0000;
	else if (spr_cs & !dis_spr_access_scnd_clk)
		spr_dat_reg <=  itlb_dat_o;

assign spr_dat_o = itlb_spr_access ? itlb_dat_o : spr_dat_reg; 

//
// Page fault exception logic
//
assign fault = itlb_done &
			(  (!supv & !itlb_uxe)		// Execute in user mode not enabled
			|| (supv & !itlb_sxe));		// Execute in supv mode not enabled

//
// TLB Miss exception logic
//
assign miss = itlb_done & !itlb_hit;

//
// ITLB Enable
//
assign itlb_en = immu_en & icpu_cycstb_i;

//
// Instantiation of ITLB
//
or1200_immu_tlb or1200_immu_tlb(
	// Rst and clk
        .clk(clk),
	.rst(rst),

        // I/F for translation
        .tlb_en(itlb_en),
	.vaddr(icpu_adr_i),
	.hit(itlb_hit),
	.ppn(itlb_ppn),
	.uxe(itlb_uxe),
	.sxe(itlb_sxe),
	.ci(itlb_ci),

                  
            
                         
                         
                             
      

        // SPR access
        .spr_cs(itlb_spr_access),
	.spr_write(spr_write),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_i),
	.spr_dat_o(itlb_dat_o)
);

      

endmodule

`line 1 "../../rtl/verilog/or1200_lsu.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Load/Store unit                                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Interface between CPU and DC.                               ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_lsu.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 52 "../../rtl/verilog/or1200_lsu.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 53 "../../rtl/verilog/or1200_lsu.v" 2

module or1200_lsu(
	// Clock and Reset
	clk, rst,

	// Internal i/f
	id_addrbase, ex_addrbase, id_addrofs, ex_addrofs, id_lsu_op, 
	lsu_datain, lsu_dataout, lsu_stall, lsu_unstall,
	du_stall, except_align, except_dtlbmiss, except_dmmufault, except_dbuserr,
	id_freeze, ex_freeze, flushpipe,

	// External i/f to DC
	dcpu_adr_o, dcpu_cycstb_o, dcpu_we_o, dcpu_sel_o, dcpu_tag_o, dcpu_dat_o,
	dcpu_dat_i, dcpu_ack_i, dcpu_rty_i, dcpu_err_i, dcpu_tag_i
);

parameter dw =   32;
parameter aw =  5;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// Internal i/f
//
input	[31:0]			id_addrbase;
input	[31:0]			ex_addrbase;
input	[31:0]			id_addrofs;
input	[31:0]			ex_addrofs;
input	[  4-1:0] id_lsu_op;
input	[dw-1:0]		lsu_datain;
output	[dw-1:0]		lsu_dataout;
output				lsu_stall;
output				lsu_unstall;
input                           du_stall;
output				except_align;
output				except_dtlbmiss;
output				except_dmmufault;
output				except_dbuserr;
input                           id_freeze;
input                           ex_freeze;
input                           flushpipe;

//
// External i/f to DC
//
output	[31:0]			dcpu_adr_o;
output				dcpu_cycstb_o;
output				dcpu_we_o;
output	[3:0]			dcpu_sel_o;
output	[3:0]			dcpu_tag_o;
output	[31:0]			dcpu_dat_o;
input	[31:0]			dcpu_dat_i;
input				dcpu_ack_i;
input				dcpu_rty_i;
input				dcpu_err_i;
input	[3:0]			dcpu_tag_i;

//
// Internal wires/regs
//
reg	[3:0]			dcpu_sel_o;

reg	[  4-1:0] ex_lsu_op;
wire	[  2:0] id_precalc_sum;
reg	[  2:0] dcpu_adr_r;
reg				except_align;

//
// ex_lsu_op
//
always @(posedge clk or       posedge rst) begin
    if (rst ==       (1'b1))
        ex_lsu_op <=    4'b0000;
    else if (!ex_freeze & id_freeze | flushpipe)
        ex_lsu_op <=    4'b0000;
    else if (!ex_freeze)
        ex_lsu_op <=  id_lsu_op;
end

//
// Precalculate part of load/store EA in ID stage
//
assign id_precalc_sum = id_addrbase[  2-1:0] +
                        id_addrofs[  2-1:0];

always @(posedge clk or       posedge rst) begin
    if (rst ==       (1'b1))
        dcpu_adr_r <=  {  2+1{1'b0}};
    else if (!ex_freeze)
        dcpu_adr_r <=  id_precalc_sum;
end

//
// Generate except_align in ID stage
//
always @(posedge clk or       posedge rst) begin
    if (rst ==       (1'b1))
        except_align <=  1'b0;
    else if (!ex_freeze & id_freeze | flushpipe)
        except_align <=  1'b0;
    else if (!ex_freeze)
        except_align <=  ((id_lsu_op ==    4'b1100) |
                            (id_lsu_op ==   4'b0100) |
                            (id_lsu_op ==   4'b0101)) & id_precalc_sum[0]
		        |  ((id_lsu_op ==    4'b1110) |
		            (id_lsu_op ==   4'b0110) |
		            (id_lsu_op ==   4'b0111)) & |id_precalc_sum[1:0];
end

//
// Internal I/F assignments
//
assign lsu_stall = dcpu_rty_i & dcpu_cycstb_o;
assign lsu_unstall = dcpu_ack_i;
assign except_dtlbmiss = dcpu_err_i & (dcpu_tag_i ==   4'hd );
assign except_dmmufault = dcpu_err_i & (dcpu_tag_i ==   4'hc );
assign except_dbuserr = dcpu_err_i & (dcpu_tag_i ==   4'hb );

//
// External I/F assignments
//
assign dcpu_adr_o[31:  2] = 
				   ex_addrbase[31:  2] + 
				   (ex_addrofs[31:  2] +
				    // carry from precalc, pad to 30-bits
				   {{(32-  2)-1{1'b0}},
				    dcpu_adr_r[  2]});
assign dcpu_adr_o[  2-1:0] = dcpu_adr_r[  2-1:0];
assign dcpu_cycstb_o = du_stall | lsu_unstall | except_align ? 
		       1'b0 : |ex_lsu_op;
assign dcpu_we_o = ex_lsu_op[3];
assign dcpu_tag_o = dcpu_cycstb_o ?   4'h1  :  4'h0 ;
always @(ex_lsu_op or dcpu_adr_o)
	casez({ex_lsu_op, dcpu_adr_o[1:0]})
		{   4'b1010, 2'b00} : dcpu_sel_o = 4'b1000;
		{   4'b1010, 2'b01} : dcpu_sel_o = 4'b0100;
		{   4'b1010, 2'b10} : dcpu_sel_o = 4'b0010;
		{   4'b1010, 2'b11} : dcpu_sel_o = 4'b0001;
		{   4'b1100, 2'b00} : dcpu_sel_o = 4'b1100;
		{   4'b1100, 2'b10} : dcpu_sel_o = 4'b0011;
		{   4'b1110, 2'b00} : dcpu_sel_o = 4'b1111;
		{  4'b0010, 2'b00}, {  4'b0011, 2'b00} : dcpu_sel_o = 4'b1000;
		{  4'b0010, 2'b01}, {  4'b0011, 2'b01} : dcpu_sel_o = 4'b0100;
		{  4'b0010, 2'b10}, {  4'b0011, 2'b10} : dcpu_sel_o = 4'b0010;
		{  4'b0010, 2'b11}, {  4'b0011, 2'b11} : dcpu_sel_o = 4'b0001;
		{  4'b0100, 2'b00}, {  4'b0101, 2'b00} : dcpu_sel_o = 4'b1100;
		{  4'b0100, 2'b10}, {  4'b0101, 2'b10} : dcpu_sel_o = 4'b0011;
		{  4'b0110, 2'b00}, {  4'b0111, 2'b00} : dcpu_sel_o = 4'b1111;
		default : dcpu_sel_o = 4'b0000;
	endcase

//
// Instantiation of Memory-to-regfile aligner
//
or1200_mem2reg or1200_mem2reg(
	.addr(dcpu_adr_o[1:0]),
	.lsu_op(ex_lsu_op),
	.memdata(dcpu_dat_i),
	.regdata(lsu_dataout)
);

//
// Instantiation of Regfile-to-memory aligner
//
or1200_reg2mem or1200_reg2mem(
        .addr(dcpu_adr_o[1:0]),
        .lsu_op(ex_lsu_op),
        .regdata(lsu_datain),
        .memdata(dcpu_dat_o)
);

endmodule

`line 1 "../../rtl/verilog/or1200_mem2reg.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's mem2reg alignment                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Two versions of Memory to register data alignment.          ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_mem2reg.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 
//
// Revision 1.5  2002/09/03 22:28:21  lampret
// As per Taylor Su suggestion all case blocks are full case by default and optionally (OR1200_CASE_DEFAULT) can be disabled to increase clock frequncy.
//
// Revision 1.4  2002/03/29 15:16:56  lampret
// Some of the warnings fixed.
//
// Revision 1.3  2002/03/28 19:14:10  lampret
// Changed define name from OR1200_MEM2REG_FAST to OR1200_IMPL_MEM2REG2
//
// Revision 1.2  2002/01/14 06:18:22  lampret
// Fixed mem2reg bug in FAST implementation. Updated debug unit to work with new genpc/if.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.9  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.8  2001/10/19 23:28:46  lampret
// Fixed some synthesis warnings. Configured with caches and MMUs.
//
// Revision 1.7  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.2  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.1  2001/07/20 00:46:03  lampret
// Development version of RTL. Libraries are missing.
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 86 "../../rtl/verilog/or1200_mem2reg.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 87 "../../rtl/verilog/or1200_mem2reg.v" 2

module or1200_mem2reg(addr, lsu_op, memdata, regdata);

parameter width =   32;

//
// I/O
//
input	[1:0]			addr;
input	[  4-1:0]	lsu_op;
input	[width-1:0]		memdata;
output	[width-1:0]		regdata;


//
// In the past faster implementation of mem2reg (today probably slower)
//
                           

                                
                                
                                
                                
                                
                                
                                
                                
                                

                       
                       
                       
                       
                         
                                 
                         

                                                                  

  
                
  
                              
                                                     
                                 
                                                
                                 
                                 
                                                
                                 
                                                
                                
                                                
        
   

  
                
  
                              
                                                     
                           
                                               
                             
                                                            
                             
                                                            
                             
                                                            
                             
                                                            
                                 
                                                
                                
                                                
        
   

  
                
  
                              
                                                     
                           
                           
                                               
                             
                             
                                                            
                             
                                                            
                             
                             
                                                            
                             
                                                            
                                
                                                
        
   

  
                
  
                              
                                                     
                           
                           
                                               
                             
                             
                                                            
                             
                                                            
                             
                             
                                                            
                             
                                                            
                                
                                                
        
   

  
         
  
                                    
                                            
                          
                                                    
     
                                                              
      
     
                          
                                          
     
                                                    
      
      
                          
                              
      
                          
                               
      
                          
                                
      
                          
                
     
                          
      
                                
      
        
   

  
         
  
                                    
                                            
                          
                                                    
     
                                                              
      
     
                          
                                          
     
                                                    
      
      
                         
                       
      
                          
                               
      
                          
                                
      
                          
                                 
      
                          
                                  
      
                          
                                  
      
                          
                
     
                          
      
                                  
      
        
   

  
         
  
                                    
                                            
                          
                                                    
     
                                                              
      
     
                          
                                          
     
                                                    
      
      
                         
                       
      
                          
                                
      
                          
                                 
      
                          
                                  
      
                          
                                  
      
                          
                
     
                          
      
                                  
      
        
   

  
         
  
                                    
                                            
                          
                                                    
     
                                                              
      
     
                          
                                          
     
                                                    
      
      
                         
                       
      
                          
                                
      
                          
                                 
      
                          
                                  
      
                          
                                  
      
                          
                          
     
                          
      
                                  
      
        
   

     

//
// Straightforward implementation of mem2reg
//

reg	[width-1:0]		regdata;
reg	[width-1:0]		aligned;

//
// Alignment
//
always @(addr or memdata) begin
                                            
                                               
     
	case(addr) // synopsys parallel_case
      
		2'b00:
			aligned = memdata;
		2'b01:
			aligned = {memdata[23:0], 8'b0};
		2'b10:
			aligned = {memdata[15:0], 16'b0};
		2'b11:
			aligned = {memdata[7:0], 24'b0};
	endcase
end

//
// Bytes
//
always @(lsu_op or aligned) begin
                                            
                                                 
     
	case(lsu_op) // synopsys parallel_case
      
		  4'b0010: begin
				regdata[7:0] = aligned[31:24];
				regdata[31:8] = 24'b0;
			end
		  4'b0011: begin
				regdata[7:0] = aligned[31:24];
				regdata[31:8] = {24{aligned[31]}};
			end
		  4'b0100: begin
				regdata[15:0] = aligned[31:16];
				regdata[31:16] = 16'b0;
			end
		  4'b0101: begin
				regdata[15:0] = aligned[31:16];
				regdata[31:16] = {16{aligned[31]}};
			end
		default:
				regdata = aligned;
	endcase
end

      

endmodule

`line 1 "../../rtl/verilog/or1200_mult_mac.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Top level multiplier, divider and MAC              ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Multiplier is 32x32 however multiply instructions only      ////
////  use lower 32 bits of the result. MAC is 32x32=64+64.        ////
////                                                              ////
////  To Do:                                                      ////
////   - make signed division better, w/o negating the operands   ////
////   - implement non-serial divider that is synthesizable       ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////      - Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000, 2010 Authors and OPENCORES.ORG           ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_mult_mac.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 56 "../../rtl/verilog/or1200_mult_mac.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 57 "../../rtl/verilog/or1200_mult_mac.v" 2

module or1200_mult_mac(
		       // Clock and reset
		       clk, rst,

		       // Multiplier/MAC interface
		       ex_freeze, id_macrc_op, macrc_op, a, b, mac_op, alu_op, 
		       result, mult_mac_stall,

		       // Overflow
		       ovforw, ov_we,
		       
		       // SPR interface
		       spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o
		       );

   parameter width =   32;

   //
   // I/O
   //

   //
   // Clock and reset
   //
   input				clk;
   input				rst;

   //
   // Multiplier/MAC interface
   //
   input				ex_freeze;
   input				id_macrc_op;
   input				macrc_op;
   input [width-1:0] 			a;
   input [width-1:0] 			b;
   input [ 3-1:0] 	mac_op;
   input [ 5-1:0] 	alu_op;
   output [width-1:0] 			result;
   output				mult_mac_stall;
   output 				ovforw, ov_we;
   
   //
   // SPR interface
   //
   input				spr_cs;
   input				spr_write;
   input [31:0] 			spr_addr;
   input [31:0] 			spr_dat_i;
   output [31:0] 			spr_dat_o;

   //
   // Internal wires and regs
   //
   reg [width-1:0] 			result;
   reg 					ex_freeze_r;
   wire 				alu_op_mul;
   wire 				alu_op_smul;      
                              
   reg [2*width-1:0] 			mul_prod_r;
   wire 				alu_op_umul;   
                          
                                   
                        
       
     
                                    
      
   wire [2*width-1:0] 			mul_prod;
   wire 				mul_stall;
   reg [1:0] 				mul_stall_count;   
   wire [ 3-1:0] 	mac_op;
                             
                                            
                                            
                                            
                        
                        
     
   wire [ 3-1:0] 	mac_op_r1;
   wire [ 3-1:0] 	mac_op_r2;
   wire [ 3-1:0] 	mac_op_r3;
   wire 				mac_stall_r;
   wire [63:0] 				mac_r;
      
   wire [width-1:0] 			x;
   wire [width-1:0] 			y;
   wire 				spr_maclo_we;
   wire 				spr_machi_we; 
   wire 				alu_op_div;  
   wire 				alu_op_udiv;
   wire 				alu_op_sdiv;
   reg 					div_free;
   wire 			        div_stall;
                             
                         
   reg [2*width-1:0] 			div_quot_r;   
   wire [width-1:0] 			div_tmp;
   reg [5:0] 				div_cntr;
      
                                       
                                          
       
   wire 				div_by_zero;
      
   reg 					ovforw, ov_we;
   
   //
   // Combinatorial logic
   //
                              
   assign alu_op_smul = (alu_op ==  5'b0_0110 );
   assign alu_op_umul = (alu_op ==  5'b0_1011 );
   assign alu_op_mul = alu_op_smul | alu_op_umul;
     
                          
                         
      
                             
                                                                         
                                                                          
                                                                              
     
   assign spr_maclo_we = 1'b0;
   assign spr_machi_we = 1'b0;
   assign spr_dat_o = 32'h0000_0000;
      
                             
   assign alu_op_sdiv = (alu_op ==  5'b0_1001 );
   assign alu_op_udiv = (alu_op ==  5'b0_1010 );
   assign alu_op_div = alu_op_sdiv | alu_op_udiv;   
     
                             
                             
                               
      

   assign x = (alu_op_sdiv | alu_op_smul) & a[31] ? ~a + 32'b1 : 
	      alu_op_div | alu_op_mul | (|mac_op) ? a : 32'd0;
   assign y = (alu_op_sdiv | alu_op_smul) & b[31] ? ~b + 32'b1 : 
	      alu_op_div | alu_op_mul | (|mac_op) ? b : 32'd0;

   assign div_by_zero = !(|b) & alu_op_div;
   

   // Used to indicate when we should check for new multiply or MAC ops
   always @(posedge clk or       posedge rst)
     if (rst ==       (1'b1))
       ex_freeze_r <= 1'b1;
     else
       ex_freeze_r <= ex_freeze;

   //
   // Select result of current ALU operation to be forwarded
   // to next instruction and to WB stage
   //
   always @*
     casez(alu_op)	// synopsys parallel_case
                             
        5'b0_1001 : begin
	  result = a[31] ^ b[31] ? ~div_quot_r[31:0] + 32'd1 : div_quot_r[31:0];
       end
        5'b0_1010 : begin
	  result = div_quot_r[31:0];
       end
      
                                  
        5'b0_0110 : begin
	  result = a[31] ^ b[31] ? ~mul_prod_r[31:0] + 32'd1 : mul_prod_r[31:0];
       end
	  5'b0_1011 : begin
	  result = mul_prod_r[31:0];
       end
          
       default:
                                   
                          
                                                             
      
                            
       
     
       result = {width{1'b0}};    
          
     endcase // casez (alu_op)


   //
   // Overflow generation
   //
   always @*
     casez(alu_op)	// synopsys parallel_case
                            
                               
        5'b0_0110 : begin
	  // Actually doing unsigned multiply internally, and then negate on
	  // output as appropriate, so if sign bit is set, then is overflow
          // unless incoming signs differ and result is 2^(width-1)
          ovforw = (mul_prod_r[width-1] && 
                    !((a[width-1]^b[width-1]) && ~|mul_prod_r[width-2:0])) ||
                   |mul_prod_r[2*width-1:32];

	  ov_we = 1;
       end
        5'b0_1011  : begin
	  // Overflow on unsigned multiply is simpler.
	  ovforw = |mul_prod_r[2*width-1:32];
	  ov_we = 1;
       end
        //  `ifdef OR1200_MULT_IMPLEMENTED
                              
        5'b0_1010 ,
        5'b0_1001 : begin
	  // Overflow on divide by zero or -2^(width-1)/-1
	  ovforw = div_by_zero || (a==32'h8000_0000 && b==32'hffff_ffff);
	  ov_we = 1;
       end
       
       //  `ifdef OR1200_IMPL_OV
       default: begin
	  ovforw = 0;
	  ov_we = 0;
       end
     endcase // casez (alu_op)
   

                              
                          

                                                 
                                        
                                        
                        
                  
 
        
                                    
                                         
                   
                                                                        
     
                                                                   
                     
                                                
 
        
                                           
                          
               
                              
        
                                          
                   
        

                                                                      
   
      
   
   //
   // Instantiation of the multiplier
   //
                                 
                                             
                
                
                    
                    
                      
            
        // OR1200_ASIC_MULTP2_32X32
   or1200_gmultp2_32x32 or1200_gmultp2_32x32(
					     .X(x),
					     .Y(y),
					     .RST(rst),
					     .CLK(clk),
					     .P(mul_prod)
					     );
         // OR1200_ASIC_MULTP2_32X32   
   
   //
   // Registered output from the multiplier
   //
   always @(      posedge rst or posedge clk)
     if (rst ==       (1'b1)) begin
	mul_prod_r <=  64'h0000_0000_0000_0000;
     end
     else begin
	mul_prod_r <=  mul_prod[63:0];
     end

   //
   // Generate stall signal during multiplication
   //
   always @(      posedge rst or posedge clk)
     if (rst ==       (1'b1))
       mul_stall_count <= 0;
     else if (!(|mul_stall_count))
       mul_stall_count <= {mul_stall_count[0], alu_op_mul & !ex_freeze_r};
     else 
       mul_stall_count <= {mul_stall_count[0],1'b0};
       
   assign mul_stall = (|mul_stall_count) | 
		      (!(|mul_stall_count) & alu_op_mul & !ex_freeze_r);
   
        // !`ifdef OR1200_MULT_SERIAL   
   
                                
                                     
                                       
                           
       // OR1200_MULT_IMPLEMENTED

                             
   
     
                                                                 
     
                                                 
                                  
                                            
         
                                                                    

     
                                 
     
                                                 
                                  
                                            
         
                               

     
                                 
     
                                                 
                                  
                                            
         
                               

     
                           
     
                                                 
                                  
                                         
                         
                           
                                 
                           
                                  
       
                                             
                                    
                                             
                                    
                                     
                                         

     
                                                                       
                                                       
                                                    
     
                                                 
                                  
                            
         
                                                                 
                                     
   
      // OR1200_MAC_IMPLEMENTED
   assign mac_stall_r = 1'b0;
   assign mac_r = {2*width{1'b0}};
   assign mac_op_r1 =  3'b0;
   assign mac_op_r2 =  3'b0;
   assign mac_op_r3 =  3'b0;
       // OR1200_MAC_IMPLEMENTED

                                
   
   //
   // Serial division
   //
                         
   assign div_tmp = div_quot_r[63:32] - y;   
   always @(      posedge rst or posedge clk)
     if (rst ==       (1'b1)) begin
	div_quot_r <=  64'h0000_0000_0000_0000;
	div_free <=  1'b1;
	div_cntr <=  6'b00_0000;
     end
     else if (div_by_zero) begin
	div_quot_r <=  64'h0000_0000_0000_0000;
	div_free <=  1'b1;
	div_cntr <=  6'b00_0000;
     end
     else if (|div_cntr) begin
	if (div_tmp[31])
	  div_quot_r <=  {div_quot_r[62:0], 1'b0};
	else
	  div_quot_r <=  {div_tmp[30:0], div_quot_r[31:0], 1'b1};
	div_cntr <=  div_cntr - 6'd1;
     end
     else if (alu_op_div && div_free) begin
	div_quot_r <=  {31'b0, x[31:0], 1'b0};
	div_cntr <=  6'b10_0000;
	div_free <=  1'b0;
     end
     else if (div_free | !ex_freeze) begin
	div_free <=  1'b1;
     end

   assign div_stall = (|div_cntr) | (!ex_freeze_r & alu_op_div);


                                   

                  
                                                                    
                                                            
                                         
                           
                                
         
                
                                                                 
                                                
                      
                                    
         

                                                                          
                              
                                                                         
                                    
      
                                           

           
   
                        
   
          

                                       

                        

       // !`ifdef OR1200_DIV_IMPLEMENTED
   
   
   //   
   // Stall output
   //
   assign mult_mac_stall = mac_stall_r | div_stall | mul_stall;
   
endmodule

`line 1 "../../rtl/verilog/or1200_operandmuxes.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's register file read operands mux                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Mux for two register file read operands.                    ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_operandmuxes.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 50 "../../rtl/verilog/or1200_operandmuxes.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 51 "../../rtl/verilog/or1200_operandmuxes.v" 2

module or1200_operandmuxes(
	// Clock and reset
	clk, rst,

	// Internal i/f
	id_freeze, ex_freeze, rf_dataa, rf_datab, ex_forw, wb_forw,
	simm, sel_a, sel_b, operand_a, operand_b, muxed_a, muxed_b
);

parameter width =   32;

//
// I/O
//
input				clk;
input				rst;
input				id_freeze;
input				ex_freeze;
input	[width-1:0]		rf_dataa;
input	[width-1:0]		rf_datab;
input	[width-1:0]		ex_forw;
input	[width-1:0]		wb_forw;
input	[width-1:0]		simm;
input	[  2-1:0]	sel_a;
input	[  2-1:0]	sel_b;
output	[width-1:0]		operand_a;
output	[width-1:0]		operand_b;
output	[width-1:0]		muxed_a;
output	[width-1:0]		muxed_b;

//
// Internal wires and regs
//
reg	[width-1:0]		operand_a;
reg	[width-1:0]		operand_b;
reg	[width-1:0]		muxed_a;
reg	[width-1:0]		muxed_b;
reg				saved_a;
reg				saved_b;

//
// Operand A register
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		operand_a <=  32'd0;
		saved_a <=  1'b0;
	end else if (!ex_freeze && id_freeze && !saved_a) begin
		operand_a <=  muxed_a;
		saved_a <=  1'b1;
	end else if (!ex_freeze && !saved_a) begin
		operand_a <=  muxed_a;
	end else if (!ex_freeze && !id_freeze)
		saved_a <=  1'b0;
end

//
// Operand B register
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		operand_b <=  32'd0;
		saved_b <=  1'b0;
	end else if (!ex_freeze && id_freeze && !saved_b) begin
		operand_b <=  muxed_b;
		saved_b <=  1'b1;
	end else if (!ex_freeze && !saved_b) begin
		operand_b <=  muxed_b;
	end else if (!ex_freeze && !id_freeze)
		saved_b <=  1'b0;
end

//
// Forwarding logic for operand A register
//
always @(ex_forw or wb_forw or rf_dataa or sel_a) begin
                                            
                                                  
     
	casez (sel_a)	// synopsys parallel_case
      
		  2'd2:
			muxed_a = ex_forw;
		  2'd3:
			muxed_a = wb_forw;
		default:
			muxed_a = rf_dataa;
	endcase
end

//
// Forwarding logic for operand B register
//
always @(simm or ex_forw or wb_forw or rf_datab or sel_b) begin
                                            
                                                  
     
	casez (sel_b)	// synopsys parallel_case
      
		   2'd1:
			muxed_b = simm;
		  2'd2:
			muxed_b = ex_forw;
		  2'd3:
			muxed_b = wb_forw;
		default:
			muxed_b = rf_datab;
	endcase
end

endmodule

`line 1 "../../rtl/verilog/or1200_pic.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Programmable Interrupt Controller                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  PIC according to OR1K architectural specification.          ////
////                                                              ////
////  To Do:                                                      ////
////   None                                                       ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_pic.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 49 "../../rtl/verilog/or1200_pic.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 50 "../../rtl/verilog/or1200_pic.v" 2

module or1200_pic(
	// RISC Internal Interface
	clk, rst, spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o,
	pic_wakeup, intr,
	
	// PIC Interface
	pic_int
);

//
// RISC Internal Interface
//
input		clk;		// Clock
input		rst;		// Reset
input		spr_cs;		// SPR CS
input		spr_write;	// SPR Write
input	[31:0]	spr_addr;	// SPR Address
input	[31:0]	spr_dat_i;	// SPR Write Data
output	[31:0]	spr_dat_o;	// SPR Read Data
output		pic_wakeup;	// Wakeup to the PM
output		intr;		// interrupt
				// exception request

//
// PIC Interface
//
input	[ 20-1:0]	pic_int;// Interrupt inputs

                             

//
// PIC Mask Register bits (or no register)
//
                       
reg	[ 20-1:2]	picmr;	// PICMR bits
     
                                                       
      

//
// PIC Status Register bits (or no register)
//
                       
reg	[ 20-1:0]	picsr;	// PICSR bits
     
                                                       
      

//
// Internal wires & regs
//
wire		picmr_sel;	// PICMR select
wire		picsr_sel;	// PICSR select
wire	[ 20-1:0] um_ints;// Unmasked interrupts
reg	[31:0] 	spr_dat_o;	// SPR data out

//
// PIC registers address decoder
//
assign picmr_sel = (spr_cs && (spr_addr[ 1:0] ==  2'd0)) ? 1'b1 : 1'b0;
assign picsr_sel = (spr_cs && (spr_addr[ 1:0] ==  2'd2)) ? 1'b1 : 1'b0;

//
// Write to PICMR
//
                       
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		picmr <= {1'b1, { 20-3{1'b0}}};
	else if (picmr_sel && spr_write) begin
		picmr <=  spr_dat_i[ 20-1:2];
	end
     
                                     
      

//
// Write to PICSR, both CPU and external ints
//
                       
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		picsr <= { 20{1'b0}};
	else if (picsr_sel && spr_write) begin
		picsr <=  spr_dat_i[ 20-1:0] | um_ints;
	end else
		picsr <=  picsr | um_ints;
     
                       
      

//
// Read PIC registers
//
always @(spr_addr or picmr or picsr)
	case (spr_addr[ 1:0])	// synopsys parallel_case
                          
		 2'd0: begin
		   spr_dat_o[ 20-1:0] = {picmr, 2'b11};
                              
		   spr_dat_o[31: 20] = {32- 20{1'b0}};
       
		end
      
	  default: begin
	     spr_dat_o[ 20-1:0] = picsr;
                             
	     spr_dat_o[31: 20] = {32- 20{1'b0}};
      
	  end
	endcase
   
//
// Unmasked interrupts
//
assign um_ints = pic_int & {picmr, 2'b11};

//
// Generate intr
//
assign intr = |um_ints;

//
// Assert pic_wakeup when intr is asserted
//
assign pic_wakeup = intr;

     

  
                                                                               
  
                                      
                        

  
                     
  
                          
                                                             
                             
                                                               
      
      

      

endmodule

`line 1 "../../rtl/verilog/or1200_pm.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Power Management                                   ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  PM according to OR1K architectural specification.           ////
////                                                              ////
////  To Do:                                                      ////
////   - add support for dynamic clock gating                     ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_pm.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.8  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.7  2001/10/14 13:12:10  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:35  igorm
// no message
//
// Revision 1.2  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.1  2001/07/20 00:46:21  lampret
// Development version of RTL. Libraries are missing.
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 71 "../../rtl/verilog/or1200_pm.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 72 "../../rtl/verilog/or1200_pm.v" 2

module or1200_pm(
	// RISC Internal Interface
	clk, rst, pic_wakeup, spr_write, spr_addr, spr_dat_i, spr_dat_o,
	
	// Power Management Interface
	pm_clksd, pm_cpustall, pm_dc_gate, pm_ic_gate, pm_dmmu_gate,
	pm_immu_gate, pm_tt_gate, pm_cpu_gate, pm_wakeup, pm_lvolt
);

//
// RISC Internal Interface
//
input		clk;		// Clock
input		rst;		// Reset
input		pic_wakeup;	// Wakeup from the PIC
input		spr_write;	// SPR Read/Write
input	[31:0]	spr_addr;	// SPR Address
input	[31:0]	spr_dat_i;	// SPR Write Data
output	[31:0]	spr_dat_o;	// SPR Read Data

//
// Power Management Interface
//
input		pm_cpustall;	// Stall the CPU
output	[3:0]	pm_clksd;	// Clock Slowdown factor
output		pm_dc_gate;	// Gate DCache clock
output		pm_ic_gate;	// Gate ICache clock
output		pm_dmmu_gate;	// Gate DMMU clock
output		pm_immu_gate;	// Gate IMMU clock
output		pm_tt_gate;	// Gate Tick Timer clock
output		pm_cpu_gate;	// Gate main RISC/CPU clock
output		pm_wakeup;	// Activate (de-gate) all clocks
output		pm_lvolt;	// Lower operating voltage

                            

  
                                 
  
                                  
                             
                              
                                         

  
                 
  
                            

  
                                        
  
                                 
                                                                                       
     
                                                                            
                                                                          
      

  
                                                     
                         
  
                                              
                              
                                
                                     
                                        
                                        
                                        
                                          
    
                           
               
               
    

  
           
  
                         
                                           
                                           
                                           
                                             
                            
                                                
      
      

  
                    
  
                      

  
                                             
                                         
  
                                               
                                
                                
                                  
                                  
                                      

  
                                               
  
                              

  
                                                               
  
                                            

     

//
// When PM is not implemented, drive all outputs as would when PM is disabled
//
assign pm_clksd = 4'b0;
assign pm_cpu_gate = 1'b0;
assign pm_dc_gate = 1'b0;
assign pm_ic_gate = 1'b0;
assign pm_dmmu_gate = 1'b0;
assign pm_immu_gate = 1'b0;
assign pm_tt_gate = 1'b0;
assign pm_wakeup = 1'b1;
assign pm_lvolt = 1'b0;

//
// Read PMR
//
                         
assign spr_dat_o[ 3:0] = 4'b0;
assign spr_dat_o[ 4] = 1'b0;
assign spr_dat_o[ 5] = 1'b0;
assign spr_dat_o[ 6] = 1'b0;
                            
assign spr_dat_o[ 31:7] = 25'b0;
      
      

      

endmodule

`line 1 "../../rtl/verilog/or1200_reg2mem.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's reg2mem aligner                                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Aligns register data to memory alignment.                   ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_reg2mem.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 
//
// Revision 1.2  2002/03/29 15:16:56  lampret
// Some of the warnings fixed.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.9  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.8  2001/10/19 23:28:46  lampret
// Fixed some synthesis warnings. Configured with caches and MMUs.
//
// Revision 1.7  2001/10/14 13:12:10  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.2  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.1  2001/07/20 00:46:21  lampret
// Development version of RTL. Libraries are missing.
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 77 "../../rtl/verilog/or1200_reg2mem.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 78 "../../rtl/verilog/or1200_reg2mem.v" 2

module or1200_reg2mem(addr, lsu_op, regdata, memdata);

parameter width =   32;

//
// I/O
//
input	[1:0]			addr;
input	[  4-1:0]	lsu_op;
input	[width-1:0]		regdata;
output	[width-1:0]		memdata;

//
// Internal regs and wires
//
reg	[7:0]			memdata_hh;
reg	[7:0]			memdata_hl;
reg	[7:0]			memdata_lh;
reg	[7:0]			memdata_ll;

assign memdata = {memdata_hh, memdata_hl, memdata_lh, memdata_ll};

//
// Mux to memdata[31:24]
//
always @(lsu_op or addr or regdata) begin
	casez({lsu_op, addr[1:0]})	// synopsys parallel_case
		{   4'b1010, 2'b00} : memdata_hh = regdata[7:0];
		{   4'b1100, 2'b00} : memdata_hh = regdata[15:8];
		default : memdata_hh = regdata[31:24];
	endcase
end

//
// Mux to memdata[23:16]
//
always @(lsu_op or addr or regdata) begin
	casez({lsu_op, addr[1:0]})	// synopsys parallel_case
		{   4'b1110, 2'b00} : memdata_hl = regdata[23:16];
		default : memdata_hl = regdata[7:0];
	endcase
end

//
// Mux to memdata[15:8]
//
always @(lsu_op or addr or regdata) begin
	casez({lsu_op, addr[1:0]})	// synopsys parallel_case
		{   4'b1010, 2'b10} : memdata_lh = regdata[7:0];
		default : memdata_lh = regdata[15:8];
	endcase
end

//
// Mux to memdata[7:0]
//
always @(regdata)
	memdata_ll = regdata[7:0];

endmodule

`line 1 "../../rtl/verilog/or1200_rf.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's register file inside CPU                           ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Instantiation of register file memories                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_rf.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed, coding style changed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_rf.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_rf.v" 2

module or1200_rf(
	// Clock and reset
	clk, rst,

	// Write i/f
	cy_we_i, cy_we_o, supv, wb_freeze, addrw, dataw, we, flushpipe,

	// Read i/f
	id_freeze, addra, addrb, dataa, datab, rda, rdb,

	// Debug
	spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o, du_read
);

parameter dw =   32;
parameter aw =  5;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// Write i/f
//
input				cy_we_i;
output				cy_we_o;
input				supv;
input				wb_freeze;
input	[aw-1:0]		addrw;
input	[dw-1:0]		dataw;
input				we;
input				flushpipe;

//
// Read i/f
//
input				id_freeze;
input	[aw-1:0]		addra;
input	[aw-1:0]		addrb;
output	[dw-1:0]		dataa;
output	[dw-1:0]		datab;
input				rda;
input				rdb;

//
// SPR access for debugging purposes
//
input				spr_cs;
input				spr_write;
input	[31:0]			spr_addr;
input	[31:0]			spr_dat_i;
output	[31:0]			spr_dat_o;
input    			du_read;
   
//
// Internal wires and regs
//
wire	[dw-1:0]		from_rfa;
wire	[dw-1:0]		from_rfb;
wire	[aw-1:0]		rf_addra;
wire	[aw-1:0]		rf_addrw;
wire	[dw-1:0]		rf_dataw;
wire				rf_we;
wire				spr_valid;
wire				rf_ena;
wire				rf_enb;
reg				rf_we_allow;

   // Logic to restore output on RFA after debug unit has read out via SPR if.
   // Problem was that the incorrect output would be on RFA after debug unit
   // had read out  - this is bad if that output is relied upon by execute
   // stage for next instruction. We simply save the last address for rf A and
   // and re-read it whenever the SPR select goes low, so we must remember
   // the last address and generate a signal for falling edge of SPR cs.
   // -- Julius
   
   // Detect falling edge of SPR select 
   reg 				spr_du_cs;
   wire 			spr_cs_fe;
   // Track RF A's address each time it's enabled
   reg	[aw-1:0]		addra_last;


   always @(posedge clk)
     if (rf_ena & !(spr_cs_fe | (du_read & spr_cs)))
       addra_last <= addra;

   always @(posedge clk)
     spr_du_cs <= spr_cs & du_read;

   assign spr_cs_fe = spr_du_cs & !(spr_cs & du_read);

   
//
// SPR access is valid when spr_cs is asserted and
// SPR address matches GPR addresses
//
assign spr_valid = spr_cs & (spr_addr[10:5] ==   6'd32 );

//
// SPR data output is always from RF A
//
assign spr_dat_o = from_rfa;

//
// Operand A comes from RF or from saved A register
//
assign dataa = from_rfa;

//
// Operand B comes from RF or from saved B register
//
assign datab = from_rfb;

//
// RF A read address is either from SPRS or normal from CPU control
//
assign rf_addra = (spr_valid & !spr_write) ? spr_addr[4:0] : 
		  spr_cs_fe ? addra_last : addra;

//
// RF write address is either from SPRS or normal from CPU control
//
assign rf_addrw = (spr_valid & spr_write) ? spr_addr[4:0] : addrw;

//
// RF write data is either from SPRS or normal from CPU datapath
//
assign rf_dataw = (spr_valid & spr_write) ? spr_dat_i : dataw;

//
// RF write enable is either from SPRS or normal from CPU control
//
always @(      posedge rst or posedge clk)
	if (rst ==       (1'b1))
		rf_we_allow <=  1'b1;
	else if (~wb_freeze)
		rf_we_allow <=  ~flushpipe;

assign rf_we = ((spr_valid & spr_write) | (we & ~wb_freeze)) & rf_we_allow;

assign cy_we_o = cy_we_i && ~wb_freeze && rf_we_allow;
   
//
// CS RF A asserted when instruction reads operand A and ID stage
// is not stalled
//
assign rf_ena = (rda & ~id_freeze) | (spr_valid & !spr_write) | spr_cs_fe;

//
// CS RF B asserted when instruction reads operand B and ID stage
// is not stalled
//
assign rf_enb = rdb & ~id_freeze;

                           

  
                                                
  
                        
          
             
             
               
             
             
                   
                      
                 

          
             
             
              
              
             
                   
                 
        
  

  
                                                
  
                        
          
             
             
               
             
             
                
                      
                 

          
             
             
              
              
             
                   
                 
        
  

     

                            

//
// Instantiation of register file two-port RAM A
//
   or1200_dpram #
     (
      .aw(5),
      .dw(32)
      )
   rf_a
     (
      // Port A
      .clk_a(clk),
      .ce_a(rf_ena),
      .addr_a(rf_addra),
      .do_a(from_rfa),
      
      // Port B
      .clk_b(clk),
      .ce_b(rf_we),
      .we_b(rf_we),
      .addr_b(rf_addrw),
      .di_b(rf_dataw)
      );

   //
   // Instantiation of register file two-port RAM B
   //
   or1200_dpram #
     (
      .aw(5),
      .dw(32)
      )
   rf_b
     (
      // Port A
      .clk_a(clk),
      .ce_a(rf_enb),
      .addr_a(addrb),
      .do_a(from_rfb),
      
      // Port B
      .clk_b(clk),
      .ce_b(rf_we),
      .we_b(rf_we),
      .addr_b(rf_addrw),
      .di_b(rf_dataw)
      );
   
     

                           

  
                                                           
  
                          
                   
           
           

          
               
                   
                 

          
               
                
                 

          
              
              
                   
                
  

     

  
                           
  
             
                                
         
   

      
      
      

endmodule

`line 1 "../../rtl/verilog/or1200_rfram_generic.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's register file generic memory                       ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Generic (flip-flop based) register file memory              ////
////                                                              ////
////  To Do:                                                      ////
////   - nothing                                                  ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_rfram_generic.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, coding style changed. 
//
// Revision 1.3  2004/06/08 18:16:32  lampret
// GPR0 hardwired to zero.
//
// Revision 1.2  2002/09/03 22:28:21  lampret
// As per Taylor Su suggestion all case blocks are full case by default and optionally (OR1200_CASE_DEFAULT) can be disabled to increase clock frequncy.
//
// Revision 1.1  2002/06/08 16:23:30  lampret
// Generic flip-flop based memory macro for register file.
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 63 "../../rtl/verilog/or1200_rfram_generic.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 64 "../../rtl/verilog/or1200_rfram_generic.v" 2

module or1200_rfram_generic(
	// Clock and reset
	clk, rst,

	// Port A
	ce_a, addr_a, do_a,

	// Port B
	ce_b, addr_b, do_b,

	// Port W
	ce_w, we_w, addr_w, di_w
);

parameter dw =   32;
parameter aw =  5;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// Port A
//
input				ce_a;
input	[aw-1:0]		addr_a;
output	[dw-1:0]		do_a;

//
// Port B
//
input				ce_b;
input	[aw-1:0]		addr_b;
output	[dw-1:0]		do_b;

//
// Port W
//
input				ce_w;
input				we_w;
input	[aw-1:0]		addr_w;
input	[dw-1:0]		di_w;

//
// Internal wires and regs
//
reg	[aw-1:0]		intaddr_a;
reg	[aw-1:0]		intaddr_b;
                         
                     
     
reg	[32*dw-1:0]		mem;
      
reg	[dw-1:0]		do_a;
reg	[dw-1:0]		do_b;

                
                                                                              
                                                                                
                           
                         
                              

                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                             
      
                         

                                                                              
                                                                                
                           
                         
                              
                             

                                        
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      
                                       
                                      

                  
      
                         
       //  `ifdef verilator
   
//
// Write port
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1)) begin
		mem <=  {512'h0, 512'h0};
	end
	else if (ce_w & we_w)
		case (addr_w)	// synopsys parallel_case
			5'd01: mem[32*1+31:32*1] <=  di_w;
			5'd02: mem[32*2+31:32*2] <=  di_w;
			5'd03: mem[32*3+31:32*3] <=  di_w;
			5'd04: mem[32*4+31:32*4] <=  di_w;
			5'd05: mem[32*5+31:32*5] <=  di_w;
			5'd06: mem[32*6+31:32*6] <=  di_w;
			5'd07: mem[32*7+31:32*7] <=  di_w;
			5'd08: mem[32*8+31:32*8] <=  di_w;
			5'd09: mem[32*9+31:32*9] <=  di_w;
			5'd10: mem[32*10+31:32*10] <=  di_w;
			5'd11: mem[32*11+31:32*11] <=  di_w;
			5'd12: mem[32*12+31:32*12] <=  di_w;
			5'd13: mem[32*13+31:32*13] <=  di_w;
			5'd14: mem[32*14+31:32*14] <=  di_w;
			5'd15: mem[32*15+31:32*15] <=  di_w;
                         
     
			5'd16: mem[32*16+31:32*16] <=  di_w;
			5'd17: mem[32*17+31:32*17] <=  di_w;
			5'd18: mem[32*18+31:32*18] <=  di_w;
			5'd19: mem[32*19+31:32*19] <=  di_w;
			5'd20: mem[32*20+31:32*20] <=  di_w;
			5'd21: mem[32*21+31:32*21] <=  di_w;
			5'd22: mem[32*22+31:32*22] <=  di_w;
			5'd23: mem[32*23+31:32*23] <=  di_w;
			5'd24: mem[32*24+31:32*24] <=  di_w;
			5'd25: mem[32*25+31:32*25] <=  di_w;
			5'd26: mem[32*26+31:32*26] <=  di_w;
			5'd27: mem[32*27+31:32*27] <=  di_w;
			5'd28: mem[32*28+31:32*28] <=  di_w;
			5'd29: mem[32*29+31:32*29] <=  di_w;
			5'd30: mem[32*30+31:32*30] <=  di_w;
			5'd31: mem[32*31+31:32*31] <=  di_w;
      
			default: mem[32*0+31:32*0] <=  32'h0000_0000;
		endcase

//
// Read port A
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1)) begin
		intaddr_a <=  5'h00;
	end
	else if (ce_a)
		intaddr_a <=  addr_a;

always @(mem or intaddr_a)
	case (intaddr_a)	// synopsys parallel_case
		5'd01: do_a = mem[32*1+31:32*1];
		5'd02: do_a = mem[32*2+31:32*2];
		5'd03: do_a = mem[32*3+31:32*3];
		5'd04: do_a = mem[32*4+31:32*4];
		5'd05: do_a = mem[32*5+31:32*5];
		5'd06: do_a = mem[32*6+31:32*6];
		5'd07: do_a = mem[32*7+31:32*7];
		5'd08: do_a = mem[32*8+31:32*8];
		5'd09: do_a = mem[32*9+31:32*9];
		5'd10: do_a = mem[32*10+31:32*10];
		5'd11: do_a = mem[32*11+31:32*11];
		5'd12: do_a = mem[32*12+31:32*12];
		5'd13: do_a = mem[32*13+31:32*13];
		5'd14: do_a = mem[32*14+31:32*14];
		5'd15: do_a = mem[32*15+31:32*15];
                         
     
		5'd16: do_a = mem[32*16+31:32*16];
		5'd17: do_a = mem[32*17+31:32*17];
		5'd18: do_a = mem[32*18+31:32*18];
		5'd19: do_a = mem[32*19+31:32*19];
		5'd20: do_a = mem[32*20+31:32*20];
		5'd21: do_a = mem[32*21+31:32*21];
		5'd22: do_a = mem[32*22+31:32*22];
		5'd23: do_a = mem[32*23+31:32*23];
		5'd24: do_a = mem[32*24+31:32*24];
		5'd25: do_a = mem[32*25+31:32*25];
		5'd26: do_a = mem[32*26+31:32*26];
		5'd27: do_a = mem[32*27+31:32*27];
		5'd28: do_a = mem[32*28+31:32*28];
		5'd29: do_a = mem[32*29+31:32*29];
		5'd30: do_a = mem[32*30+31:32*30];
		5'd31: do_a = mem[32*31+31:32*31];
      
		default: do_a = 32'h0000_0000;
	endcase

//
// Read port B
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1)) begin
		intaddr_b <=  5'h00;
	end
	else if (ce_b)
		intaddr_b <=  addr_b;

always @(mem or intaddr_b)
	case (intaddr_b)	// synopsys parallel_case
		5'd01: do_b = mem[32*1+31:32*1];
		5'd02: do_b = mem[32*2+31:32*2];
		5'd03: do_b = mem[32*3+31:32*3];
		5'd04: do_b = mem[32*4+31:32*4];
		5'd05: do_b = mem[32*5+31:32*5];
		5'd06: do_b = mem[32*6+31:32*6];
		5'd07: do_b = mem[32*7+31:32*7];
		5'd08: do_b = mem[32*8+31:32*8];
		5'd09: do_b = mem[32*9+31:32*9];
		5'd10: do_b = mem[32*10+31:32*10];
		5'd11: do_b = mem[32*11+31:32*11];
		5'd12: do_b = mem[32*12+31:32*12];
		5'd13: do_b = mem[32*13+31:32*13];
		5'd14: do_b = mem[32*14+31:32*14];
		5'd15: do_b = mem[32*15+31:32*15];
                         
     
		5'd16: do_b = mem[32*16+31:32*16];
		5'd17: do_b = mem[32*17+31:32*17];
		5'd18: do_b = mem[32*18+31:32*18];
		5'd19: do_b = mem[32*19+31:32*19];
		5'd20: do_b = mem[32*20+31:32*20];
		5'd21: do_b = mem[32*21+31:32*21];
		5'd22: do_b = mem[32*22+31:32*22];
		5'd23: do_b = mem[32*23+31:32*23];
		5'd24: do_b = mem[32*24+31:32*24];
		5'd25: do_b = mem[32*25+31:32*25];
		5'd26: do_b = mem[32*26+31:32*26];
		5'd27: do_b = mem[32*27+31:32*27];
		5'd28: do_b = mem[32*28+31:32*28];
		5'd29: do_b = mem[32*29+31:32*29];
		5'd30: do_b = mem[32*30+31:32*30];
		5'd31: do_b = mem[32*31+31:32*31];
      
		default: do_b = 32'h0000_0000;
	endcase

endmodule

`line 1 "../../rtl/verilog/or1200_sb.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Store Buffer                                       ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Implements store buffer.                                    ////
////                                                              ////
////  To Do:                                                      ////
////   - byte combining                                           ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2002 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_sb.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 51 "../../rtl/verilog/or1200_sb.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 52 "../../rtl/verilog/or1200_sb.v" 2

module or1200_sb(
	// RISC clock, reset
	clk, rst,

	// Internal RISC bus (SB)
	sb_en,

	// Internal RISC bus (DC<->SB)
	dcsb_dat_i, dcsb_adr_i, dcsb_cyc_i, dcsb_stb_i, dcsb_we_i, dcsb_sel_i, dcsb_cab_i,
	dcsb_dat_o, dcsb_ack_o, dcsb_err_o,

	// BIU bus
	sbbiu_dat_o, sbbiu_adr_o, sbbiu_cyc_o, sbbiu_stb_o, sbbiu_we_o, sbbiu_sel_o, sbbiu_cab_o,
	sbbiu_dat_i, sbbiu_ack_i, sbbiu_err_i
);

parameter dw =   32;
parameter aw =   32;

//
// RISC clock, reset
//
input			clk;		// RISC clock
input			rst;		// RISC reset

//
// Internal RISC bus (SB)
//
input			sb_en;		// SB enable

//
// Internal RISC bus (DC<->SB)
//
input	[dw-1:0]	dcsb_dat_i;	// input data bus
input	[aw-1:0]	dcsb_adr_i;	// address bus
input			dcsb_cyc_i;	// WB cycle
input			dcsb_stb_i;	// WB strobe
input			dcsb_we_i;	// WB write enable
input			dcsb_cab_i;	// CAB input
input	[3:0]		dcsb_sel_i;	// byte selects
output	[dw-1:0]	dcsb_dat_o;	// output data bus
output			dcsb_ack_o;	// ack output
output			dcsb_err_o;	// err output

//
// BIU bus
//
output	[dw-1:0]	sbbiu_dat_o;	// output data bus
output	[aw-1:0]	sbbiu_adr_o;	// address bus
output			sbbiu_cyc_o;	// WB cycle
output			sbbiu_stb_o;	// WB strobe
output			sbbiu_we_o;	// WB write enable
output			sbbiu_cab_o;	// CAB input
output	[3:0]		sbbiu_sel_o;	// byte selects
input	[dw-1:0]	sbbiu_dat_i;	// input data bus
input			sbbiu_ack_i;	// ack output
input			sbbiu_err_i;	// err output

                            

  
                          
  
                                              
                                               
               
               
                 
                  
              
                
                        
                  

  
                   
  
                                                         
                                                                                                            

  
          
  
                                                                                 
                                    
                                
                                                       
                                                                          
                                                             
                                                             
                                              
                                                
                                                                             

  
            
  
                                              
                              
                    
                              
                                                                             
                                                                    
                                                                              

  
                                  
  
                               
             
             
                    
                
                
                    
                    
                     
  

  
          
  
                                              
                              
                             
                      
                             
                           
                             

  
              
  
                                              
                              
                       
                  
                       
     
                       

     	// !OR1200_SB_IMPLEMENTED

assign sbbiu_dat_o = dcsb_dat_i;
assign sbbiu_adr_o = dcsb_adr_i;
assign sbbiu_cyc_o = dcsb_cyc_i;
assign sbbiu_stb_o = dcsb_stb_i;
assign sbbiu_we_o = dcsb_we_i;
assign sbbiu_cab_o = dcsb_cab_i;
assign sbbiu_sel_o = dcsb_sel_i;
assign dcsb_dat_o = sbbiu_dat_i;
assign dcsb_ack_o = sbbiu_ack_i;
assign dcsb_err_o = sbbiu_err_i;

      

endmodule

`line 1 "../../rtl/verilog/or1200_sb_fifo.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Store Buffer FIFO                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Implementation of store buffer FIFO.                        ////
////                                                              ////
////  To Do:                                                      ////
////   - N/A                                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2002 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_sb_fifo.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 
//
// Revision 1.3  2002/11/06 13:53:41  simons
// SB mem width fixed.
//
// Revision 1.2  2002/08/22 02:18:55  lampret
// Store buffer has been tested and it works. BY default it is still disabled until uClinux confirms correct operation on FPGA board.
//
// Revision 1.1  2002/08/18 19:53:08  lampret
// Added store buffer.
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 62 "../../rtl/verilog/or1200_sb_fifo.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 63 "../../rtl/verilog/or1200_sb_fifo.v" 2

module or1200_sb_fifo(
	clk_i, rst_i, dat_i, wr_i, rd_i, dat_o, full_o, empty_o
);

parameter dw = 68;
parameter fw =   2 ;
parameter fl =  4 ;

//
// FIFO signals
//
input			clk_i;	// Clock
input			rst_i;	// Reset
input	[dw-1:0]	dat_i;	// Input data bus
input			wr_i;	// Write request
input			rd_i;	// Read request
output [dw-1:0]	dat_o;	// Output data bus
output			full_o;	// FIFO full
output			empty_o;// FIFO empty

//
// Internal regs
//
reg	[dw-1:0]	mem [fl-1:0];
reg	[dw-1:0]	dat_o;
reg	[fw+1:0]	cntr;
reg	[fw-1:0]	wr_pntr;
reg	[fw-1:0]	rd_pntr;
reg			empty_o;
reg			full_o;

always @(posedge clk_i or       posedge rst_i)
	if (rst_i ==       (1'b1)) begin
		full_o <=  1'b0;
		empty_o <=  1'b1;
		wr_pntr <=  {fw{1'b0}};
		rd_pntr <=  {fw{1'b0}};
		cntr <=  {fw+2{1'b0}};
		dat_o <=  {dw{1'b0}};
	end
	else if (wr_i && rd_i) begin		// FIFO Read and Write
		mem[wr_pntr] <=  dat_i;
		if (wr_pntr >= fl-1)
			wr_pntr <=  {fw{1'b0}};
		else
			wr_pntr <=  wr_pntr + 1'b1;
		if (empty_o) begin
			dat_o <=  dat_i;
		end
		else begin
			dat_o <=  mem[rd_pntr];
		end
		if (rd_pntr >= fl-1)
			rd_pntr <=  {fw{1'b0}};
		else
			rd_pntr <=  rd_pntr + 1'b1;
	end
	else if (wr_i && !full_o) begin		// FIFO Write
		mem[wr_pntr] <=  dat_i;
		cntr <=  cntr + 1'b1;
		empty_o <=  1'b0;
		if (cntr >= (fl-1)) begin
			full_o <=  1'b1;
			cntr <=  fl;
		end
		if (wr_pntr >= fl-1)
			wr_pntr <=  {fw{1'b0}};
		else
			wr_pntr <=  wr_pntr + 1'b1;
	end
	else if (rd_i && !empty_o) begin	// FIFO Read
		dat_o <=  mem[rd_pntr];
		cntr <=  cntr - 1'b1;
		full_o <=  1'b0;
		if (cntr <= 1) begin
			empty_o <=  1'b1;
			cntr <=  {fw+2{1'b0}};
		end
		if (rd_pntr >= fl-1)
			rd_pntr <=  {fw{1'b0}};
		else
			rd_pntr <=  rd_pntr + 1'b1;
	end

endmodule

`line 1 "../../rtl/verilog/or1200_spram_1024x32.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_1024x32.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.2  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3.4.1  2003/07/08 15:36:37  lampret
// Added embedded memory QMEM.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:40  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.8  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.7  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.6  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 116 "../../rtl/verilog/or1200_spram_1024x32.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 117 "../../rtl/verilog/or1200_spram_1024x32.v" 2

module or1200_spram_1024x32(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 10;
parameter dw = 32;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                              
     
                  
                                  
     
                             
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                            
     
                  
                            
     
                       
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
               
         
         
               
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

     

                           

  
                                
  
                    
  
                   
  

  
          
  
                      
           
            
                    
              
            
         
         
               
       
  

  
          
  
                      
           
            
                    
               
            
         
         
                
       
  

  
          
  
                      
           
            
                    
                
            
         
         
                 
       
  

  
          
  
                      
           
            
                    
                
            
         
         
                 
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		addr_reg <=  {aw{1'b0}};
	else if (ce)
		addr_reg <=  addr;

//
// RAM write
//
always @(posedge clk)
	if (ce && we)
		mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_1024x8.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_1024x8.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:40  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.8  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.7  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.6  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 113 "../../rtl/verilog/or1200_spram_1024x8.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 114 "../../rtl/verilog/or1200_spram_1024x8.v" 2

module or1200_spram_1024x8(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 10;
parameter dw = 8;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                             
     
                  
                                 
     
                            
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                           
     
                  
                           
     
                      
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

     

                           

  
                                
  
                    
  
                   
  

                    
           
            
                    
         
            
         
         
          
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		addr_reg <=  {aw{1'b0}};
	else if (ce)
		addr_reg <=  addr;

//
// RAM write
//
always @(posedge clk)
	if (ce && we)
		mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_2048x32.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_2048x32.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.10  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.9  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.8  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.4.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.4  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.3  2002/10/28 15:03:50  mohor
// Signal scanb_sen renamed to scanb_en.
//
// Revision 1.2  2002/10/17 20:04:40  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.8  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.7  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.6  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 116 "../../rtl/verilog/or1200_spram_2048x32.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 117 "../../rtl/verilog/or1200_spram_2048x32.v" 2

module or1200_spram_2048x32(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 11;
parameter dw = 32;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                              
     
                  
                                  
     
                             
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                            
     
                  
                            
     
                       
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
          
  
                    
           
            
             
                
         
         
                
  

  
           
  
                     
           
            
             
                
         
         
                
  

  
           
  
                     
           
            
             
                
         
         
                
  

  
           
  
                     
           
            
             
                
         
         
                
  

  
           
  
                     
           
            
             
                
         
         
                
  

  
           
  
                     
           
            
             
                
         
         
                
  

  
           
  
                     
           
            
             
                
         
         
                
  

     

                           

  
                                
  
                    
  
                   
  

  
          
  
                      
           
            
             
              
            
         
         
               
       
  

  
          
  
                      
           
            
             
               
            
         
         
                
       
  

  
          
  
                      
           
            
             
                
            
         
         
                 
       
  

  
          
  
                      
           
            
             
                
            
         
         
                 
       
  

     

                        

  
                                
  
             
  
                        
  

        

                    

                                      

                                 
                
               
                
           
         
        
  

                                             
                                       
                                                
                                                         
                                                   
                                              
                                                      

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		addr_reg <=  {aw{1'b0}};
	else if (ce)
		addr_reg <=  addr;

//
// RAM write
//
always @(posedge clk)
	if (ce && we)
		mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_2048x8.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_2048x8.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:40  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.8  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.7  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.6  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 113 "../../rtl/verilog/or1200_spram_2048x8.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 114 "../../rtl/verilog/or1200_spram_2048x8.v" 2

module or1200_spram_2048x8(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 11;
parameter dw = 8;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                             
     
                  
                                 
     
                            
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                           
     
                  
                           
     
                      
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
              
         
         
              
  

     

                           

  
                                
  
                    
  
                   
  

                    
           
            
             
         
            
         
         
          
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		addr_reg <=  {aw{1'b0}};
	else if (ce)
		addr_reg <=  addr;

//
// RAM write
//
always @(posedge clk)
	if (ce && we)
		mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_256x21.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMBS16                                     ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_256x21.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.2  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3.4.1  2003/07/08 15:36:37  lampret
// Added embedded memory QMEM.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:40  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.10  2001/11/27 21:24:04  lampret
// Changed instantiation name of VS RAMs.
//
// Revision 1.9  2001/11/27 19:45:04  lampret
// Fixed VS RAM instantiation - again.
//
// Revision 1.8  2001/11/23 21:42:31  simons
// Program counter divided to PPC and NPC.
//
// Revision 1.6  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.5  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 122 "../../rtl/verilog/or1200_spram_256x21.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 123 "../../rtl/verilog/or1200_spram_256x21.v" 2

module or1200_spram_256x21(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 8;
parameter dw = 21;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//
                          
                         
     
                           
                         
       // !OR1200_XILINX_RAMB16
       // !OR1200_XILINX_RAMB4

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                             
     
                  
                                 
     
                            
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                           
     
                  
                           
     
                      
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                      
           
            
             
               
         
         
               
  

  
          
  
                      
           
            
             
                                   
         
         
                               
  

     

                           

  
                                
  
                    
  
                   
  

                      
           
            
                    
                                 
            
         
         
                              
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM adress register
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		addr_reg <=  {aw{1'b0}};
	else if (ce)
		addr_reg <=  addr;

//
// RAM write
//
always @(posedge clk)
	if (ce && we)
		mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_512x20.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_512x20.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:40  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.10  2001/11/27 21:24:04  lampret
// Changed instantiation name of VS RAMs.
//
// Revision 1.9  2001/11/27 19:45:04  lampret
// Fixed VS RAM instantiation - again.
//
// Revision 1.8  2001/11/23 21:42:31  simons
// Program counter divided to PPC and NPC.
//
// Revision 1.6  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.5  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 119 "../../rtl/verilog/or1200_spram_512x20.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 120 "../../rtl/verilog/or1200_spram_512x20.v" 2

module or1200_spram_512x20(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 9;
parameter dw = 20;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//
                          
                        
     
                           
                         
       // !OR1200_XILINX_RAMB16
       // !OR1200_XILINX_RAMB4

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                             
     
                  
                                 
     
                            
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                           
     
                  
                           
     
                      
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                    
           
            
             
              
         
         
              
  

  
          
  
                    
           
            
             
               
         
         
               
  

  
          
  
                    
           
            
             
                           
         
         
                               
  

     

                           

  
                                
  
                    
  
                   
  

                      
           
            
             
                   
            
         
         
                        
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		addr_reg <=  {aw{1'b0}};
	else if (ce)
		addr_reg <=  addr;

//
// RAM write
//
always @(posedge clk)
	if (ce && we)
		mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_64x14.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_64x14.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:41  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.7  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.6  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.5  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 113 "../../rtl/verilog/or1200_spram_64x14.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 114 "../../rtl/verilog/or1200_spram_64x14.v" 2

module or1200_spram_64x14(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 6;
parameter dw = 14;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//

                          
                        
     
                           
                        
       // !OR1200_XILINX_RAMB16
       // !OR1200_XILINX_RAMB4

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                            
     
                  
                                
     
                           
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                          
     
                  
                          
     
                     
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                      
           
            
                      
                        
         
         
                              
  

     

                           

  
                                
  
                    
  

                      
           
            
                        
                        
             
         
         
                               
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
        if (rst ==       (1'b1))
                addr_reg <=  {aw{1'b0}};
        else if (ce)
                addr_reg <=  addr;
                                                                                                                                                                                                     
//
// RAM write
//
always @(posedge clk)
        if (ce && we)
                mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_64x22.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_64x22.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:41  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.7  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.6  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.5  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 113 "../../rtl/verilog/or1200_spram_64x22.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 114 "../../rtl/verilog/or1200_spram_64x22.v" 2

module or1200_spram_64x22(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 6;
parameter dw = 22;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//
                          
                        
     
                           
                        
       // !OR1200_XILINX_RAMB16
       // !OR1200_XILINX_RAMB4


                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                            
     
                  
                                
     
                           
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                          
     
                  
                          
     
                     
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                      
           
            
                      
               
         
         
               
  

  
          
  
                      
           
            
                      
                                  
         
         
                               
  

     

                           

  
                                
  
                    
  
                   
  

                      
           
            
                       
                          
            
         
         
                         
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
        if (rst ==       (1'b1))
                addr_reg <=  {aw{1'b0}};
        else if (ce)
                addr_reg <=  addr;
                                                                                                                                                                                                     
//
// RAM write
//
always @(posedge clk)
        if (ce && we)
                mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_spram_64x24.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Single-Port Synchronous RAM                         ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common single-port             ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  single-port synchronous RAM.                                ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Single-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage Single-Port Sync RAM                               ////
////  - Virtual Silicon Single-Port Sync RAM                      ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - xilinx rams need external tri-state logic                ////
////   - fix avant! two-port ram                                  ////
////   - add additional RAMs                                      ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_spram_64x24.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.9  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.8  2004/06/08 18:15:32  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.7  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.3.4.1  2003/12/09 11:46:48  simons
// Mbist nameing changed, Artisan ram instance signal names fixed, some synthesis waning fixed.
//
// Revision 1.3  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.2  2002/10/17 20:04:41  lampret
// Added BIST scan. Special VS RAMs need to be used to implement BIST.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.8  2001/11/02 18:57:14  lampret
// Modified virtual silicon instantiations.
//
// Revision 1.7  2001/10/22 19:39:56  lampret
// Fixed parameters in generic sprams.
//
// Revision 1.6  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.5  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 116 "../../rtl/verilog/or1200_spram_64x24.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 117 "../../rtl/verilog/or1200_spram_64x24.v" 2

module or1200_spram_64x24(
                  
            
                                      
      
	// Generic synchronous single-port RAM interface
	clk, rst, ce, we, oe, addr, di, doq
);

//
// Default address and data buses width
//
parameter aw = 6;
parameter dw = 24;

                  
  
           
  
                 
                                                    
                  
      

//
// Generic synchronous single-port RAM interface
//
input			clk;	// Clock
input			rst;	// Reset
input			ce;	// Chip enable input
input			we;	// Write enable input
input			oe;	// Output enable input
input 	[aw-1:0]	addr;	// address bus inputs
input	[dw-1:0]	di;	// input data bus
output	[dw-1:0]	doq;	// output data bus

//
// Internal wires and registers
//
                          
                        
     
                           
                        
       // !OR1200_XILINX_RAMB16
       // !OR1200_XILINX_RAMB4

                         
     
                                
     
                  
                               
      
      
      

                         

  
                                
  
                                              
  
             
                                            
     
                  
                                
     
                           
      
      
                  
            
                         
                         
                             
      
           
           
           
          
        
           
        
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
            
        
         
         
         
        
  

     

                                

  
                                
  
                                               
  
             
                                          
     
                  
                          
     
                     
      
      
                  
            
                         
                         
                             
      
          
            
         
           
           
           
           
  

     

                          

  
                                
  
                  
  

  
          
  
                      
           
            
                      
               
         
         
               
  

  
          
  
                      
           
            
                      
                         
         
         
                               
  

     

                           

  
                                
  
                    
  
                   
  

                      
           
            
                       
                 
            
         
         
                         
       
  

     

                        

  
                                
  
             
  
                        
  

           

                     

                                      

                                 
                       
                      
                       
                  
                
               
  

                                             
                                              
                                                       
                                                                
                                                          
                                                     
                                                             

     

//
// Generic single-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_reg;		// RAM address register

//
// Data output drivers
//
assign doq = (oe) ? mem[addr_reg] : {dw{1'b0}};

//
// RAM address register
//
always @(posedge clk or       posedge rst)
        if (rst ==       (1'b1))
                addr_reg <=  {aw{1'b0}};
        else if (ce)
                addr_reg <=  addr;
                                                                                                                                                                                                     
//
// RAM write
//
always @(posedge clk)
        if (ce && we)
                mem[addr] <=  di;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRTUALSILICON_SSP
      	// !OR1200_VIRAGE_SSP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SSP

endmodule

`line 1 "../../rtl/verilog/or1200_sprs.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's interface to SPRs                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  Decoding of SPR addresses and access to SPRs                ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_sprs.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 50 "../../rtl/verilog/or1200_sprs.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 51 "../../rtl/verilog/or1200_sprs.v" 2

module or1200_sprs(
		   // Clk & Rst
		   clk, rst,

		   // Internal CPU interface
		   flagforw, flag_we, flag, cyforw, cy_we, carry,
		   ovforw, ov_we, dsx,
		   addrbase, addrofs, dat_i, branch_op, ex_spr_read, 
		   ex_spr_write, 
		   epcr, eear, esr, except_started,
		   to_wbmux, epcr_we, eear_we, esr_we, pc_we, sr_we, to_sr, sr,
		   spr_dat_cfgr, spr_dat_rf, spr_dat_npc, spr_dat_ppc, 
		   spr_dat_mac,
		   
		   boot_adr_sel_i,

		   // Floating point SPR input
		   fpcsr, fpcsr_we, spr_dat_fpu,

		   // From/to other RISC units
		   spr_dat_pic, spr_dat_tt, spr_dat_pm,
		   spr_dat_dmmu, spr_dat_immu, spr_dat_du,
		   spr_addr, spr_dat_o, spr_cs, spr_we,

		   du_addr, du_dat_du, du_read,
		   du_write, du_dat_cpu

		   );

   parameter width =   32;

   //
   // I/O Ports
   //

   //
   // Internal CPU interface
   //
   input				clk; 		// Clock
   input 				rst;		// Reset
   input 				flagforw;	// From ALU
   input 				flag_we;	// From ALU
   output 				flag;		// SR[F]
   input 				cyforw;		// From ALU
   input 				cy_we;		// From ALU
   output 				carry;		// SR[CY]
   input 				ovforw;		// From ALU
   input 				ov_we;		// From ALU
   input                                dsx;            // From except
   input [width-1:0] 			addrbase;	// SPR base address
   input [15:0] 			addrofs;	// SPR offset
   input [width-1:0] 			dat_i;		// SPR write data
   input 				ex_spr_read;	// l.mfspr in EX
   input 				ex_spr_write;	// l.mtspr in EX
   input [  3-1:0] 	branch_op;	// Branch operation
   input [width-1:0] 			epcr /* verilator public */;// EPCR0
   input [width-1:0] 			eear /* verilator public */;// EEAR0
   input [ 17-1:0] 	esr /* verilator public */; // ESR0
   input 				except_started; // Exception was started
   output [width-1:0] 			to_wbmux;	// For l.mfspr
   output				epcr_we;	// EPCR0 write enable
   output				eear_we;	// EEAR0 write enable
   output				esr_we;		// ESR0 write enable
   output				pc_we;		// PC write enable
   output 				sr_we;		// Write enable SR
   output [ 17-1:0] 	to_sr;		// Data to SR
   output [ 17-1:0] 	sr /* verilator public */;// SR
   input [31:0] 			spr_dat_cfgr;	// Data from CFGR
   input [31:0] 			spr_dat_rf;	// Data from RF
   input [31:0] 			spr_dat_npc;	// Data from NPC
   input [31:0] 			spr_dat_ppc;	// Data from PPC   
   input [31:0] 			spr_dat_mac;	// Data from MAC
   input				boot_adr_sel_i;

   input [ 12-1:0] 	fpcsr;	// FPCSR
   output 				fpcsr_we;	// Write enable FPCSR   
   input [31:0] 			spr_dat_fpu;    // Data from FPU
   
   //
   // To/from other RISC units
   //
   input [31:0] 			spr_dat_pic;	// Data from PIC
   input [31:0] 			spr_dat_tt;	// Data from TT
   input [31:0] 			spr_dat_pm;	// Data from PM
   input [31:0] 			spr_dat_dmmu;	// Data from DMMU
   input [31:0] 			spr_dat_immu;	// Data from IMMU
   input [31:0] 			spr_dat_du;	// Data from DU
   output [31:0] 			spr_addr;	// SPR Address
   output [31:0] 			spr_dat_o;	// Data to unit
   output [31:0] 			spr_cs;		// Unit select
   output				spr_we;		// SPR write enable

   //
   // To/from Debug Unit
   //
   input [width-1:0] 			du_addr;	// Address
   input [width-1:0] 			du_dat_du;	// Data from DU to SPRS
   input				du_read;	// Read qualifier
   input				du_write;	// Write qualifier
   output [width-1:0] 			du_dat_cpu;	// Data from SPRS to DU

   //
   // Internal regs & wires
   //
   reg [ 17-1:0] 		sr_reg;		// SR
   reg 					sr_reg_bit_eph;	// SR_EPH bit
   reg 					sr_reg_bit_eph_select;// SR_EPH select
   wire 				sr_reg_bit_eph_muxed;// SR_EPH muxed bit
   reg [ 17-1:0] 		sr;			// SR
   reg [width-1:0] 			to_wbmux;	// For l.mfspr
   wire 				cfgr_sel;	// Select for cfg regs
   wire 				rf_sel;		// Select for RF
   wire 				npc_sel;	// Select for NPC
   wire 				ppc_sel;	// Select for PPC
   wire 				sr_sel;		// Select for SR	
   wire 				epcr_sel;	// Select for EPCR0
   wire 				eear_sel;	// Select for EEAR0
   wire 				esr_sel;	// Select for ESR0
   wire 				fpcsr_sel;	// Select for FPCSR   
   wire [31:0] 				sys_data;// Read data from system SPRs
   wire 				du_access;// Debug unit access
   reg [31:0] 				unqualified_cs;	// Unqualified selects
   wire 				ex_spr_write; // jb
   
   //
   // Decide if it is debug unit access
   //
   assign du_access = du_read | du_write;

   //
   // Generate SPR address from base address and offset
   // OR from debug unit address
   //
   assign spr_addr = du_access ? du_addr : (addrbase | {16'h0000, addrofs});

   //
   // SPR is written by debug unit or by l.mtspr
   //
   assign spr_dat_o = du_write ? du_dat_du : dat_i;

   //
   // debug unit data input:
   //  - read of SPRS by debug unit
   //  - write into debug unit SPRs by debug unit itself
   //  - write into debug unit SPRs by l.mtspr
   //
   assign du_dat_cpu = du_read ? to_wbmux : du_write ? du_dat_du : dat_i;

   //
   // Write into SPRs when DU or l.mtspr
   //
   assign spr_we = du_write | ( ex_spr_write & !du_access );


   //
   // Qualify chip selects
   //
   assign spr_cs = unqualified_cs & {32{du_read | du_write | ex_spr_read | 
					(ex_spr_write & sr[   0])}};

   //
   // Decoding of groups
   //
   always @(spr_addr)
     case (spr_addr[ 15:11])	// synopsys parallel_case
         5'd00: unqualified_cs 
	 = 32'b00000000_00000000_00000000_00000001;
         5'd01: unqualified_cs 
	 = 32'b00000000_00000000_00000000_00000010;
         5'd02: unqualified_cs 
	 = 32'b00000000_00000000_00000000_00000100;
         5'd03: unqualified_cs 
	 = 32'b00000000_00000000_00000000_00001000;
         5'd04: unqualified_cs 
	 = 32'b00000000_00000000_00000000_00010000;
         5'd05: unqualified_cs 
	 = 32'b00000000_00000000_00000000_00100000;
         5'd06: unqualified_cs 
	 = 32'b00000000_00000000_00000000_01000000;
         5'd07: unqualified_cs 
	 = 32'b00000000_00000000_00000000_10000000;
         5'd08: unqualified_cs 
	 = 32'b00000000_00000000_00000001_00000000;
         5'd09: unqualified_cs 
	 = 32'b00000000_00000000_00000010_00000000;
         5'd10: unqualified_cs 
	 = 32'b00000000_00000000_00000100_00000000;
         5'd11: unqualified_cs 
	 = 32'b00000000_00000000_00001000_00000000;
         5'd12: unqualified_cs 
	 = 32'b00000000_00000000_00010000_00000000;
         5'd13: unqualified_cs 
	 = 32'b00000000_00000000_00100000_00000000;
         5'd14: unqualified_cs 
	 = 32'b00000000_00000000_01000000_00000000;
         5'd15: unqualified_cs 
	 = 32'b00000000_00000000_10000000_00000000;
         5'd16: unqualified_cs 
	 = 32'b00000000_00000001_00000000_00000000;
         5'd17: unqualified_cs 
	 = 32'b00000000_00000010_00000000_00000000;
         5'd18: unqualified_cs 
	 = 32'b00000000_00000100_00000000_00000000;
         5'd19: unqualified_cs 
	 = 32'b00000000_00001000_00000000_00000000;
         5'd20: unqualified_cs 
	 = 32'b00000000_00010000_00000000_00000000;
         5'd21: unqualified_cs 
	 = 32'b00000000_00100000_00000000_00000000;
         5'd22: unqualified_cs 
	 = 32'b00000000_01000000_00000000_00000000;
         5'd23: unqualified_cs 
	 = 32'b00000000_10000000_00000000_00000000;
         5'd24: unqualified_cs 
	 = 32'b00000001_00000000_00000000_00000000;
         5'd25: unqualified_cs 
	 = 32'b00000010_00000000_00000000_00000000;
         5'd26: unqualified_cs 
	 = 32'b00000100_00000000_00000000_00000000;
         5'd27: unqualified_cs 
	 = 32'b00001000_00000000_00000000_00000000;
         5'd28: unqualified_cs 
	 = 32'b00010000_00000000_00000000_00000000;
         5'd29: unqualified_cs 
	 = 32'b00100000_00000000_00000000_00000000;
         5'd30: unqualified_cs 
	 = 32'b01000000_00000000_00000000_00000000;
         5'd31: unqualified_cs 
	 = 32'b10000000_00000000_00000000_00000000;
     endcase

   //
   // SPRs System Group
   //

   //
   // What to write into SR
   //
   assign to_sr[   15:  12 ] 
	    = (except_started) ? {sr[   15:  14],dsx,1'b0} :
	      (branch_op ==   3'd6) ? 
	      esr[   15:  12 ] : (spr_we && sr_sel) ? 
	      {1'b1, spr_dat_o[   15-1:  12 ]} :
	      sr[   15:  12 ];
   assign to_sr[  16] 
	    = (except_started) ? 1'b1 :
	      (branch_op ==   3'd6) ? esr[  16] :
	      (spr_we && sr_sel) ? spr_dat_o[  16] :
	      sr[  16];
   assign to_sr[   11 ] 
	    = (except_started) ? sr[   11 ] :
	      (branch_op ==   3'd6) ? esr[   11 ] :
	      ov_we ? ovforw :
	      (spr_we && sr_sel) ? spr_dat_o[   11 ] :
	      sr[   11 ];
   assign to_sr[   10 ] 
	    = (except_started) ? sr[   10 ] :
	      (branch_op ==   3'd6) ? esr[   10 ] :
	      cy_we ? cyforw :
	      (spr_we && sr_sel) ? spr_dat_o[   10 ] :
	      sr[   10 ];
   assign to_sr[    9] 
	    = (except_started) ? sr[    9] :
	      (branch_op ==   3'd6) ? esr[    9] :
	      flag_we ? flagforw :
	      (spr_we && sr_sel) ? spr_dat_o[    9] :
	      sr[    9];
   
   assign to_sr[   8:   0] 
	    = (except_started) ? {sr[   8:  7], 2'b00, 
				  sr[  4:  3], 3'b001} :
	      (branch_op ==   3'd6) ? 
	      esr[   8:   0] : (spr_we && sr_sel) ? 
	      spr_dat_o[   8:   0] :
	      sr[   8:   0];

   //
   // Selects for system SPRs
   //
   assign cfgr_sel = (spr_cs[ 5'd00] && 
		      (spr_addr[10:4] ==   7'd0));
   assign rf_sel = (spr_cs[ 5'd00] && 
		    (spr_addr[10:5] ==   6'd32 ));
   assign npc_sel = (spr_cs[ 5'd00] && 
		     (spr_addr[10:0] ==   11'd16));
   assign ppc_sel = (spr_cs[ 5'd00] && 
		     (spr_addr[10:0] ==   11'd18));
   assign sr_sel = (spr_cs[ 5'd00] && 
		    (spr_addr[10:0] ==   11'd17));
   assign epcr_sel = (spr_cs[ 5'd00] && 
		      (spr_addr[10:0] ==   11'd32));
   assign eear_sel = (spr_cs[ 5'd00] && 
		      (spr_addr[10:0] ==   11'd48));
   assign esr_sel = (spr_cs[ 5'd00] && 
		     (spr_addr[10:0] ==   11'd64));
   assign fpcsr_sel = (spr_cs[ 5'd00] && 
		       (spr_addr[10:0] ==         11'd20));


   //
   // Write enables for system SPRs
   //
   assign sr_we = (spr_we && sr_sel) | (branch_op ==   3'd6) | 
		  flag_we | cy_we | ov_we;
   assign pc_we = (du_write && (npc_sel | ppc_sel));
   assign epcr_we = (spr_we && epcr_sel);
   assign eear_we = (spr_we && eear_sel);
   assign esr_we = (spr_we && esr_sel);
   assign fpcsr_we = (spr_we && fpcsr_sel);
   
   //
   // Output from system SPRs
   //
   assign sys_data = (spr_dat_cfgr & {32{cfgr_sel}}) |
		     (spr_dat_rf & {32{rf_sel}}) |
		     (spr_dat_npc & {32{npc_sel}}) |
		     (spr_dat_ppc & {32{ppc_sel}}) |
		     ({{32- 17{1'b0}},sr} & {32{sr_sel}}) |
		     (epcr & {32{epcr_sel}}) |
		     (eear & {32{eear_sel}}) |
		     ({{32- 12{1'b0}},fpcsr} & 
		      {32{fpcsr_sel}}) |
		     ({{32- 17{1'b0}},esr} & {32{esr_sel}});

   //
   // Flag alias
   //
   assign flag = sr[    9];

   //
   // Carry alias
   //
   assign carry = sr[   10 ];
   
   //
   // Supervision register
   //
   always @(posedge clk or       posedge rst)
     if (rst ==       (1'b1))
       sr_reg <=  {2'b01, // Fixed one.
		    1'b0, { 17-4{1'b0}}, 1'b1};
     else if (except_started)
       sr_reg <=  to_sr[ 17-1:0];
     else if (sr_we)
       sr_reg <=  to_sr[ 17-1:0];

   // EPH part of Supervision register
   always @(posedge clk or       posedge rst)
     // default value 
     if (rst ==       (1'b1)) begin
	sr_reg_bit_eph <=   1'b0;
	// select async. value due to reset state
	sr_reg_bit_eph_select <=  1'b1;	
     end
   // selected value (different from default) is written into FF after reset 
   // state
     else if (sr_reg_bit_eph_select) begin
	// dynamic value can only be assigned to FF out of reset!
	sr_reg_bit_eph <=  boot_adr_sel_i;
	sr_reg_bit_eph_select <=  1'b0;	// select FF value
     end
     else if (sr_we) begin
	sr_reg_bit_eph <=  to_sr[  14];
     end

   // select async. value of EPH bit after reset 
   assign	sr_reg_bit_eph_muxed = (sr_reg_bit_eph_select) ? 
				       boot_adr_sel_i : sr_reg_bit_eph;

   // EPH part joined together with rest of Supervision register
   always @(sr_reg or sr_reg_bit_eph_muxed)
     sr = {sr_reg[ 17-1: 17-2], sr_reg_bit_eph_muxed,
	   sr_reg[ 17-4:0]};

                
                                                                             
                                                                       
                

                          
                         
                                                
                        

                            
                         
                      
                          

                            
                         
                      
                          

                           
                         
                                                  
                         

      
   
   //
   // MTSPR/MFSPR interface
   //
   always @(spr_addr or sys_data or spr_dat_mac or spr_dat_pic or spr_dat_pm or
	    spr_dat_fpu or
	    spr_dat_dmmu or spr_dat_immu or spr_dat_du or spr_dat_tt) begin
      casez (spr_addr[ 15:11]) // synopsys parallel_case
	 5'd00:
	  to_wbmux = sys_data;
	 5'd10:
	  to_wbmux = spr_dat_tt;
	 5'd09:
	  to_wbmux = spr_dat_pic;
	 5'd08:
	  to_wbmux = spr_dat_pm;
	 5'd01:
	  to_wbmux = spr_dat_dmmu;
	 5'd02:
	  to_wbmux = spr_dat_immu;
	 5'd05:
	  to_wbmux = spr_dat_mac;
	    5'd11:
	  to_wbmux = spr_dat_fpu;
	default: //`OR1200_SPR_GROUP_DU:
	  to_wbmux = spr_dat_du;
      endcase
   end

endmodule

`line 1 "../../rtl/verilog/or1200_top.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200 Top Level                                            ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  OR1200 Top Level                                            ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_top.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 53 "../../rtl/verilog/or1200_top.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 54 "../../rtl/verilog/or1200_top.v" 2

module or1200_top(
	// System
	clk_i, rst_i, pic_ints_i, clmode_i,

	// Instruction WISHBONE INTERFACE
	iwb_clk_i, iwb_rst_i, iwb_ack_i, iwb_err_i, iwb_rty_i, iwb_dat_i,
	iwb_cyc_o, iwb_adr_o, iwb_stb_o, iwb_we_o, iwb_sel_o, iwb_dat_o,
                    
           
      
                   
	iwb_cti_o, iwb_bte_o,
      
	// Data WISHBONE INTERFACE
	dwb_clk_i, dwb_rst_i, dwb_ack_i, dwb_err_i, dwb_rty_i, dwb_dat_i,
	dwb_cyc_o, dwb_adr_o, dwb_stb_o, dwb_we_o, dwb_sel_o, dwb_dat_o,
                    
           
      
                   
	dwb_cti_o, dwb_bte_o,
      

	// External Debug Interface
	dbg_stall_i, dbg_ewt_i,	dbg_lss_o, dbg_is_o, dbg_wp_o, dbg_bp_o,
	dbg_stb_i, dbg_we_i, dbg_adr_i, dbg_dat_i, dbg_dat_o, dbg_ack_o,
	
                  
            
                                      
      
	// Power Management
	pm_cpustall_i,
	pm_clksd_o, pm_dc_gate_o, pm_ic_gate_o, pm_dmmu_gate_o, 
	pm_immu_gate_o, pm_tt_gate_o, pm_cpu_gate_o, pm_wakeup_o, pm_lvolt_o

,sig_tick		  

);

parameter dw =   32;
parameter aw =   32;
parameter ppic_ints =  20;
parameter boot_adr =  32'h00000100;

//
// I/O
//

//
// System
//
input			clk_i;
input			rst_i;
input	[1:0]		clmode_i;	// 00 WB=RISC, 01 WB=RISC/2, 10 N/A, 11 WB=RISC/4
input	[ppic_ints-1:0]	pic_ints_i;

//
// Instruction WISHBONE interface
//
input			iwb_clk_i;	// clock input
input			iwb_rst_i;	// reset input
input			iwb_ack_i;	// normal termination
input			iwb_err_i;	// termination w/ error
input			iwb_rty_i;	// termination w/ retry
input	[dw-1:0]	iwb_dat_i;	// input data bus
output			iwb_cyc_o;	// cycle valid output
output	[aw-1:0]	iwb_adr_o;	// address bus outputs
output			iwb_stb_o;	// strobe output
output			iwb_we_o;	// indicates write transfer
output	[3:0]		iwb_sel_o;	// byte select outputs
output	[dw-1:0]	iwb_dat_o;	// output data bus
                    
                                                          
      
                   
output	[2:0]		iwb_cti_o;	// cycle type identifier
output	[1:0]		iwb_bte_o;	// burst type extension
      

//
// Data WISHBONE interface
//
input			dwb_clk_i;	// clock input
input			dwb_rst_i;	// reset input
input			dwb_ack_i;	// normal termination
input			dwb_err_i;	// termination w/ error
input			dwb_rty_i;	// termination w/ retry
input	[dw-1:0]	dwb_dat_i;	// input data bus
output			dwb_cyc_o;	// cycle valid output
output	[aw-1:0]	dwb_adr_o;	// address bus outputs
output			dwb_stb_o;	// strobe output
output			dwb_we_o;	// indicates write transfer
output	[3:0]		dwb_sel_o;	// byte select outputs
output	[dw-1:0]	dwb_dat_o;	// output data bus
                    
                                                          
      
                   
output	[2:0]		dwb_cti_o;	// cycle type identifier
output	[1:0]		dwb_bte_o;	// burst type extension
      

//
// External Debug Interface
//
input			dbg_stall_i;	// External Stall Input
input			dbg_ewt_i;	// External Watchpoint Trigger Input
output	[3:0]		dbg_lss_o;	// External Load/Store Unit Status
output	[1:0]		dbg_is_o;	// External Insn Fetch Status
output	[10:0]		dbg_wp_o;	// Watchpoints Outputs
output			dbg_bp_o;	// Breakpoint Output
input			dbg_stb_i;      // External Address/Data Strobe
input			dbg_we_i;       // External Write Enable
input	[aw-1:0]	dbg_adr_i;	// External Address Input
input	[dw-1:0]	dbg_dat_i;	// External Data Input
output	[dw-1:0]	dbg_dat_o;	// External Data Output
output			dbg_ack_o;	// External Data Acknowledge (not WB compatible)

                  
  
           
  
                 
                                                    
                  
      

//
// Power Management
//
input			pm_cpustall_i;
output	[3:0]		pm_clksd_o;
output			pm_dc_gate_o;
output			pm_ic_gate_o;
output			pm_dmmu_gate_o;
output			pm_immu_gate_o;
output			pm_tt_gate_o;
output			pm_cpu_gate_o;
output			pm_wakeup_o;
output			pm_lvolt_o;


//
// Internal wires and regs
//

//
// DC to SB
//
wire	[dw-1:0]	dcsb_dat_dc;
wire	[aw-1:0]	dcsb_adr_dc;
wire			dcsb_cyc_dc;
wire			dcsb_stb_dc;
wire			dcsb_we_dc;
wire	[3:0]		dcsb_sel_dc;
wire			dcsb_cab_dc;
wire	[dw-1:0]	dcsb_dat_sb;
wire			dcsb_ack_sb;
wire			dcsb_err_sb;

//
// SB to BIU
//
wire	[dw-1:0]	sbbiu_dat_sb;
wire	[aw-1:0]	sbbiu_adr_sb;
wire			sbbiu_cyc_sb;
wire			sbbiu_stb_sb;
wire			sbbiu_we_sb;
wire	[3:0]		sbbiu_sel_sb;
wire			sbbiu_cab_sb;
wire	[dw-1:0]	sbbiu_dat_biu;
wire			sbbiu_ack_biu;
wire			sbbiu_err_biu;

//
// IC to BIU
//
wire	[dw-1:0]	icbiu_dat_ic;
wire	[aw-1:0]	icbiu_adr_ic;
wire	[aw-1:0]	icbiu_adr_ic_word;
wire			icbiu_cyc_ic;
wire			icbiu_stb_ic;
wire			icbiu_we_ic;
wire	[3:0]		icbiu_sel_ic;
wire	[3:0]		icbiu_tag_ic;
wire			icbiu_cab_ic;
wire	[dw-1:0]	icbiu_dat_biu;
wire			icbiu_ack_biu;
wire			icbiu_err_biu;
wire	[3:0]		icbiu_tag_biu;

//
// SR Interface (this signal can be connected to the input pin)
//
wire 			boot_adr_sel =  1'b0;

//
// CPU's SPR access to various RISC units (shared wires)
//
wire			supv;
wire	[aw-1:0]	spr_addr;
wire	[dw-1:0]	spr_dat_cpu;
wire	[31:0]		spr_cs;
wire			spr_we;
wire    		mtspr_dc_done;
   
//
// SB
//
wire			sb_en;

//
// DMMU and CPU
//
wire			dmmu_en;
wire	[31:0]		spr_dat_dmmu;

//
// DMMU and QMEM
//
wire			qmemdmmu_err_qmem;
wire	[3:0]		qmemdmmu_tag_qmem;
wire	[aw-1:0]	qmemdmmu_adr_dmmu;
wire			qmemdmmu_cycstb_dmmu;
wire			qmemdmmu_ci_dmmu;

//
// CPU and data memory subsystem
//
wire			dc_en;
wire	[31:0]		dcpu_adr_cpu;
wire			dcpu_cycstb_cpu;
wire			dcpu_we_cpu;
wire	[3:0]		dcpu_sel_cpu;
wire	[3:0]		dcpu_tag_cpu;
wire	[31:0]		dcpu_dat_cpu;
wire	[31:0]		dcpu_dat_qmem;
wire			dcpu_ack_qmem;
wire			dcpu_rty_qmem;
wire			dcpu_err_dmmu;
wire	[3:0]		dcpu_tag_dmmu;
wire    		dc_no_writethrough;
   
//
// IMMU and CPU
//
wire			immu_en;
wire	[31:0]		spr_dat_immu;

//
// CPU and insn memory subsystem
//
wire			ic_en;
wire	[31:0]		icpu_adr_cpu;
wire			icpu_cycstb_cpu;
wire	[3:0]		icpu_sel_cpu;
wire	[3:0]		icpu_tag_cpu;
wire	[31:0]		icpu_dat_qmem;
wire			icpu_ack_qmem;
wire	[31:0]		icpu_adr_immu;
wire			icpu_err_immu;
wire	[3:0]		icpu_tag_immu;
wire			icpu_rty_immu;

//
// IMMU and QMEM
//
wire	[aw-1:0]	qmemimmu_adr_immu;
wire			qmemimmu_rty_qmem;
wire			qmemimmu_err_qmem;
wire	[3:0]		qmemimmu_tag_qmem;
wire			qmemimmu_cycstb_immu;
wire			qmemimmu_ci_immu;

//
// QMEM and IC
//
wire	[aw-1:0]	icqmem_adr_qmem;
wire			icqmem_rty_ic;
wire			icqmem_err_ic;
wire	[3:0]		icqmem_tag_ic;
wire			icqmem_cycstb_qmem;
wire			icqmem_ci_qmem;
wire	[31:0]		icqmem_dat_ic;
wire			icqmem_ack_ic;

//
// QMEM and DC
//
wire	[aw-1:0]	dcqmem_adr_qmem;
wire			dcqmem_rty_dc;
wire			dcqmem_err_dc;
wire	[3:0]		dcqmem_tag_dc;
wire			dcqmem_cycstb_qmem;
wire			dcqmem_ci_qmem;
wire	[31:0]		dcqmem_dat_dc;
wire	[31:0]		dcqmem_dat_qmem;
wire			dcqmem_we_qmem;
wire	[3:0]		dcqmem_sel_qmem;
wire			dcqmem_ack_dc;

//
// Connection between CPU and PIC
//
wire	[dw-1:0]	spr_dat_pic;
wire			pic_wakeup;
wire			sig_int;

//
// Connection between CPU and PM
//
wire	[dw-1:0]	spr_dat_pm;

//
// CPU and TT
//
wire	[dw-1:0]	spr_dat_tt;
output wire			sig_tick; // jb

//
// Debug port and caches/MMUs
//
wire	[dw-1:0]	spr_dat_du;
wire			du_stall;
wire	[dw-1:0]	du_addr;
wire	[dw-1:0]	du_dat_du;
wire			du_read;
wire			du_write;
wire	[13:0]		du_except_trig;
wire	[13:0]		du_except_stop;
wire	[ 14-1:0]     du_dsr;
wire	[24:0]		du_dmr1;
wire	[dw-1:0]	du_dat_cpu;
wire	[dw-1:0]	du_lsu_store_dat;
wire	[dw-1:0]	du_lsu_load_dat;
wire			du_hwbkpt;
wire			du_hwbkpt_ls_r = 1'b0;
wire			flushpipe;
wire			ex_freeze;
wire			wb_freeze;
wire			id_void;
wire			ex_void;
wire	[31:0]		id_insn;
wire	[31:0]		ex_insn;
wire	[31:0]		wb_insn;
wire	[31:0]		id_pc;
wire	[31:0]		ex_pc;
wire	[31:0]		wb_pc;
wire	[  3-1:0]	branch_op;
wire	[31:0]		spr_dat_npc;
wire	[31:0]		rf_dataw;
wire			abort_ex;
wire			abort_mvspr;

                  
  
           
  
                     
                   
                     
                   
                     
                                  
                                   
                                   
                                     
                                   
                                  
      

wire  [3:0] icqmem_sel_qmem;
wire  [3:0] icqmem_tag_qmem;
wire  [3:0] dcqmem_tag_qmem;

//
// Instantiation of Instruction WISHBONE BIU
//
or1200_wb_biu
  #(.bl((1 << (  4-2))))
  iwb_biu(
	// RISC clk, rst and clock control
	.clk(clk_i),
	.rst(rst_i),
	.clmode(clmode_i),

	// WISHBONE interface
	.wb_clk_i(iwb_clk_i),
	.wb_rst_i(iwb_rst_i),
	.wb_ack_i(iwb_ack_i),
	.wb_err_i(iwb_err_i),
	.wb_rty_i(iwb_rty_i),
	.wb_dat_i(iwb_dat_i),
	.wb_cyc_o(iwb_cyc_o),
	.wb_adr_o(iwb_adr_o),
	.wb_stb_o(iwb_stb_o),
	.wb_we_o(iwb_we_o),
	.wb_sel_o(iwb_sel_o),
	.wb_dat_o(iwb_dat_o),
                    
                      
      
                   
	.wb_cti_o(iwb_cti_o),
	.wb_bte_o(iwb_bte_o),
      

	// Internal RISC bus
	.biu_dat_i(icbiu_dat_ic),
	.biu_adr_i(icbiu_adr_ic_word),
	.biu_cyc_i(icbiu_cyc_ic),
	.biu_stb_i(icbiu_stb_ic),
	.biu_we_i(icbiu_we_ic),
	.biu_sel_i(icbiu_sel_ic),
	.biu_cab_i(icbiu_cab_ic),
	.biu_dat_o(icbiu_dat_biu),
	.biu_ack_o(icbiu_ack_biu),
	.biu_err_o(icbiu_err_biu)
);
assign icbiu_adr_ic_word = {icbiu_adr_ic[31:2], 2'h0};

//
// Instantiation of Data WISHBONE BIU
//
or1200_wb_biu
  #(.bl((1 << (  4-2))))
  dwb_biu(
	// RISC clk, rst and clock control
	.clk(clk_i),
	.rst(rst_i),
	.clmode(clmode_i),

	// WISHBONE interface
	.wb_clk_i(dwb_clk_i),
	.wb_rst_i(dwb_rst_i),
	.wb_ack_i(dwb_ack_i),
	.wb_err_i(dwb_err_i),
	.wb_rty_i(dwb_rty_i),
	.wb_dat_i(dwb_dat_i),
	.wb_cyc_o(dwb_cyc_o),
	.wb_adr_o(dwb_adr_o),
	.wb_stb_o(dwb_stb_o),
	.wb_we_o(dwb_we_o),
	.wb_sel_o(dwb_sel_o),
	.wb_dat_o(dwb_dat_o),
                    
                      
      
                   
	.wb_cti_o(dwb_cti_o),
	.wb_bte_o(dwb_bte_o),
      

	// Internal RISC bus
	.biu_dat_i(sbbiu_dat_sb),
	.biu_adr_i(sbbiu_adr_sb),
	.biu_cyc_i(sbbiu_cyc_sb),
	.biu_stb_i(sbbiu_stb_sb),
	.biu_we_i(sbbiu_we_sb),
	.biu_sel_i(sbbiu_sel_sb),
	.biu_cab_i(sbbiu_cab_sb),
	.biu_dat_o(sbbiu_dat_biu),
	.biu_ack_o(sbbiu_ack_biu),
	.biu_err_o(sbbiu_err_biu)
);

//
// Instantiation of IMMU
//
or1200_immu_top
#(.boot_adr(boot_adr))
or1200_immu_top(
	// Rst and clk
	.clk(clk_i),
	.rst(rst_i),

                  
            
                            
                            
                             
      

	// CPU and IMMU
	.ic_en(ic_en),
	.immu_en(immu_en),
	.supv(supv),
	.icpu_adr_i(icpu_adr_cpu),
	.icpu_cycstb_i(icpu_cycstb_cpu),
	.icpu_adr_o(icpu_adr_immu),
	.icpu_tag_o(icpu_tag_immu),
	.icpu_rty_o(icpu_rty_immu),
	.icpu_err_o(icpu_err_immu),

	// SR Interface
	.boot_adr_sel_i(boot_adr_sel),

	// SPR access
	.spr_cs(spr_cs[ 5'd02]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_immu),

	// QMEM and IMMU
	.qmemimmu_rty_i(qmemimmu_rty_qmem),
	.qmemimmu_err_i(qmemimmu_err_qmem),
	.qmemimmu_tag_i(qmemimmu_tag_qmem),
	.qmemimmu_adr_o(qmemimmu_adr_immu),
	.qmemimmu_cycstb_o(qmemimmu_cycstb_immu),
	.qmemimmu_ci_o(qmemimmu_ci_immu)
);

//
// Instantiation of Instruction Cache
//
or1200_ic_top or1200_ic_top(
	.clk(clk_i),
	.rst(rst_i),

                  
            
                          
                          
                             
      

	// IC and QMEM
	.ic_en(ic_en),
	.icqmem_adr_i(icqmem_adr_qmem),
	.icqmem_cycstb_i(icqmem_cycstb_qmem),
	.icqmem_ci_i(icqmem_ci_qmem),
	.icqmem_sel_i(icqmem_sel_qmem),
	.icqmem_tag_i(icqmem_tag_qmem),
	.icqmem_dat_o(icqmem_dat_ic),
	.icqmem_ack_o(icqmem_ack_ic),
	.icqmem_rty_o(icqmem_rty_ic),
	.icqmem_err_o(icqmem_err_ic),
	.icqmem_tag_o(icqmem_tag_ic),

	// SPR access
	.spr_cs(spr_cs[ 5'd04]),
	.spr_write(spr_we),
	.spr_dat_i(spr_dat_cpu),

	// IC and BIU
	.icbiu_dat_o(icbiu_dat_ic),
	.icbiu_adr_o(icbiu_adr_ic),
	.icbiu_cyc_o(icbiu_cyc_ic),
	.icbiu_stb_o(icbiu_stb_ic),
	.icbiu_we_o(icbiu_we_ic),
	.icbiu_sel_o(icbiu_sel_ic),
	.icbiu_cab_o(icbiu_cab_ic),
	.icbiu_dat_i(icbiu_dat_biu),
	.icbiu_ack_i(icbiu_ack_biu),
	.icbiu_err_i(icbiu_err_biu)
);

//
// Instantiation of Instruction Cache
//
or1200_cpu
#(.boot_adr(boot_adr))
or1200_cpu(
	.clk(clk_i),
	.rst(rst_i),

	// Connection QMEM and IFETCHER inside CPU
	.ic_en(ic_en),
	.icpu_adr_o(icpu_adr_cpu),
	.icpu_cycstb_o(icpu_cycstb_cpu),
	.icpu_sel_o(icpu_sel_cpu),
	.icpu_tag_o(icpu_tag_cpu),
	.icpu_dat_i(icpu_dat_qmem),
	.icpu_ack_i(icpu_ack_qmem),
	.icpu_rty_i(icpu_rty_immu),
	.icpu_adr_i(icpu_adr_immu),
	.icpu_err_i(icpu_err_immu),
	.icpu_tag_i(icpu_tag_immu),

	// Connection CPU to external Debug port
	.id_void(id_void),
	.id_insn(id_insn),
	.ex_void(ex_void),
	.ex_insn(ex_insn),
	.ex_freeze(ex_freeze),
	.wb_insn(wb_insn),
	.wb_freeze(wb_freeze),
	.id_pc(id_pc),
	.ex_pc(ex_pc),
	.wb_pc(wb_pc),
	.branch_op(branch_op),
	.rf_dataw(rf_dataw),
	.ex_flushpipe(flushpipe),
	.du_stall(du_stall),
	.du_addr(du_addr),
	.du_dat_du(du_dat_du),
	.du_read(du_read),
	.du_write(du_write),
	.du_except_trig(du_except_trig),
	.du_except_stop(du_except_stop),
	.du_dsr(du_dsr),
	.du_dmr1(du_dmr1),
	.du_hwbkpt(du_hwbkpt),
	.du_hwbkpt_ls_r(du_hwbkpt_ls_r),
	.du_dat_cpu(du_dat_cpu),
	.du_lsu_store_dat(du_lsu_store_dat),
	.du_lsu_load_dat(du_lsu_load_dat),
	.abort_mvspr(abort_mvspr),
	.abort_ex(abort_ex),
	.du_flush_pipe(du_flush_pipe),

	// Connection IMMU and CPU internally
	.immu_en(immu_en),

	// Connection QMEM and CPU
	.dc_en(dc_en),
	.dcpu_adr_o(dcpu_adr_cpu),
	.dcpu_cycstb_o(dcpu_cycstb_cpu),
	.dcpu_we_o(dcpu_we_cpu),
	.dcpu_sel_o(dcpu_sel_cpu),
	.dcpu_tag_o(dcpu_tag_cpu),
	.dcpu_dat_o(dcpu_dat_cpu),
        .dcpu_dat_i(dcpu_dat_qmem),
	.dcpu_ack_i(dcpu_ack_qmem),
	.dcpu_rty_i(dcpu_rty_qmem),
	.dcpu_err_i(dcpu_err_dmmu),
	.dcpu_tag_i(dcpu_tag_dmmu),
	.dc_no_writethrough(dc_no_writethrough),

	// Connection DMMU and CPU internally
	.dmmu_en(dmmu_en),

	// SR Interface
	.boot_adr_sel_i(boot_adr_sel),

	// SB Enable
	.sb_en(sb_en),

	// Connection PIC and CPU's EXCEPT
	.sig_int(sig_int),
	.sig_tick(sig_tick),

	// SPRs
	.supv(supv),
	.spr_addr(spr_addr),
	.spr_dat_cpu(spr_dat_cpu),
	.spr_dat_pic(spr_dat_pic),
	.spr_dat_tt(spr_dat_tt),
	.spr_dat_pm(spr_dat_pm),
	.spr_dat_dmmu(spr_dat_dmmu),
	.spr_dat_immu(spr_dat_immu),
	.spr_dat_du(spr_dat_du),
	.spr_dat_npc(spr_dat_npc),
	.spr_cs(spr_cs),
	.spr_we(spr_we),
        .mtspr_dc_done(mtspr_dc_done)
);

//
// Instantiation of DMMU
//
or1200_dmmu_top or1200_dmmu_top(
	// Rst and clk
	.clk(clk_i),
	.rst(rst_i),

                  
            
                            
                            
                             
      

	// CPU i/f
	.dc_en(dc_en),
	.dmmu_en(dmmu_en),
	.supv(supv),
	.dcpu_adr_i(dcpu_adr_cpu),
	.dcpu_cycstb_i(dcpu_cycstb_cpu),
	.dcpu_we_i(dcpu_we_cpu),
	.dcpu_tag_o(dcpu_tag_dmmu),
	.dcpu_err_o(dcpu_err_dmmu),

	// SPR access
	.spr_cs(spr_cs[ 5'd01]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_dmmu),

	// QMEM and DMMU
	.qmemdmmu_err_i(qmemdmmu_err_qmem),
	.qmemdmmu_tag_i(qmemdmmu_tag_qmem),
	.qmemdmmu_adr_o(qmemdmmu_adr_dmmu),
	.qmemdmmu_cycstb_o(qmemdmmu_cycstb_dmmu),
	.qmemdmmu_ci_o(qmemdmmu_ci_dmmu)
);

//
// Instantiation of Data Cache
//
or1200_dc_top or1200_dc_top(
	.clk(clk_i),
	.rst(rst_i),

                  
            
                          
                          
                             
      

	// DC and QMEM
	.dc_en(dc_en),
	.dcqmem_adr_i(dcqmem_adr_qmem),
	.dcqmem_cycstb_i(dcqmem_cycstb_qmem),
	.dcqmem_ci_i(dcqmem_ci_qmem),
	.dcqmem_we_i(dcqmem_we_qmem),
	.dcqmem_sel_i(dcqmem_sel_qmem),
	.dcqmem_tag_i(dcqmem_tag_qmem),
	.dcqmem_dat_i(dcqmem_dat_qmem),
	.dcqmem_dat_o(dcqmem_dat_dc),
	.dcqmem_ack_o(dcqmem_ack_dc),
	.dcqmem_rty_o(dcqmem_rty_dc),
	.dcqmem_err_o(dcqmem_err_dc),
	.dcqmem_tag_o(dcqmem_tag_dc),

	.dc_no_writethrough(dc_no_writethrough),

	// SPR access
	.spr_cs(spr_cs[ 5'd03]),
	.spr_addr(spr_addr),
	.spr_write(spr_we),
	.spr_dat_i(spr_dat_cpu),
        .mtspr_dc_done(mtspr_dc_done),

	// DC and BIU
	.dcsb_dat_o(dcsb_dat_dc),
	.dcsb_adr_o(dcsb_adr_dc),
	.dcsb_cyc_o(dcsb_cyc_dc),
	.dcsb_stb_o(dcsb_stb_dc),
	.dcsb_we_o(dcsb_we_dc),
	.dcsb_sel_o(dcsb_sel_dc),
	.dcsb_cab_o(dcsb_cab_dc),
	.dcsb_dat_i(dcsb_dat_sb),
	.dcsb_ack_i(dcsb_ack_sb),
	.dcsb_err_i(dcsb_err_sb)
);

//
// Instantiation of embedded memory - qmem
//
or1200_qmem_top or1200_qmem_top(
	.clk(clk_i),
	.rst(rst_i),

                  
            
                            
                            
                             
      

	// QMEM and CPU/IMMU
	.qmemimmu_adr_i(qmemimmu_adr_immu),
	.qmemimmu_cycstb_i(qmemimmu_cycstb_immu),
	.qmemimmu_ci_i(qmemimmu_ci_immu),
	.qmemicpu_sel_i(icpu_sel_cpu),
	.qmemicpu_tag_i(icpu_tag_cpu),
	.qmemicpu_dat_o(icpu_dat_qmem),
	.qmemicpu_ack_o(icpu_ack_qmem),
	.qmemimmu_rty_o(qmemimmu_rty_qmem),
	.qmemimmu_err_o(qmemimmu_err_qmem),
	.qmemimmu_tag_o(qmemimmu_tag_qmem),

	// QMEM and IC
	.icqmem_adr_o(icqmem_adr_qmem),
	.icqmem_cycstb_o(icqmem_cycstb_qmem),
	.icqmem_ci_o(icqmem_ci_qmem),
	.icqmem_sel_o(icqmem_sel_qmem),
	.icqmem_tag_o(icqmem_tag_qmem),
	.icqmem_dat_i(icqmem_dat_ic),
	.icqmem_ack_i(icqmem_ack_ic),
	.icqmem_rty_i(icqmem_rty_ic),
	.icqmem_err_i(icqmem_err_ic),
	.icqmem_tag_i(icqmem_tag_ic),

	// QMEM and CPU/DMMU
	.qmemdmmu_adr_i(qmemdmmu_adr_dmmu),
	.qmemdmmu_cycstb_i(qmemdmmu_cycstb_dmmu),
	.qmemdmmu_ci_i(qmemdmmu_ci_dmmu),
	.qmemdcpu_we_i(dcpu_we_cpu),
	.qmemdcpu_sel_i(dcpu_sel_cpu),
	.qmemdcpu_tag_i(dcpu_tag_cpu),
	.qmemdcpu_dat_i(dcpu_dat_cpu),
	.qmemdcpu_dat_o(dcpu_dat_qmem),
	.qmemdcpu_ack_o(dcpu_ack_qmem),
	.qmemdcpu_rty_o(dcpu_rty_qmem),
	.qmemdmmu_err_o(qmemdmmu_err_qmem),
	.qmemdmmu_tag_o(qmemdmmu_tag_qmem),

	// QMEM and DC
	.dcqmem_adr_o(dcqmem_adr_qmem),
	.dcqmem_cycstb_o(dcqmem_cycstb_qmem),
	.dcqmem_ci_o(dcqmem_ci_qmem),
	.dcqmem_we_o(dcqmem_we_qmem),
	.dcqmem_sel_o(dcqmem_sel_qmem),
	.dcqmem_tag_o(dcqmem_tag_qmem),
	.dcqmem_dat_o(dcqmem_dat_qmem),
	.dcqmem_dat_i(dcqmem_dat_dc),
	.dcqmem_ack_i(dcqmem_ack_dc),
	.dcqmem_rty_i(dcqmem_rty_dc),
	.dcqmem_err_i(dcqmem_err_dc),
	.dcqmem_tag_i(dcqmem_tag_dc)
);

//
// Instantiation of Store Buffer
//
or1200_sb or1200_sb(
	// RISC clock, reset
	.clk(clk_i),
	.rst(rst_i),

	// Internal RISC bus (SB)
	.sb_en(sb_en),

	// Internal RISC bus (DC<->SB)
	.dcsb_dat_i(dcsb_dat_dc),
	.dcsb_adr_i(dcsb_adr_dc),
	.dcsb_cyc_i(dcsb_cyc_dc),
	.dcsb_stb_i(dcsb_stb_dc),
	.dcsb_we_i(dcsb_we_dc),
	.dcsb_sel_i(dcsb_sel_dc),
	.dcsb_cab_i(dcsb_cab_dc),
	.dcsb_dat_o(dcsb_dat_sb),
	.dcsb_ack_o(dcsb_ack_sb),
	.dcsb_err_o(dcsb_err_sb),

	// SB and BIU
	.sbbiu_dat_o(sbbiu_dat_sb),
	.sbbiu_adr_o(sbbiu_adr_sb),
	.sbbiu_cyc_o(sbbiu_cyc_sb),
	.sbbiu_stb_o(sbbiu_stb_sb),
	.sbbiu_we_o(sbbiu_we_sb),
	.sbbiu_sel_o(sbbiu_sel_sb),
	.sbbiu_cab_o(sbbiu_cab_sb),
	.sbbiu_dat_i(sbbiu_dat_biu),
	.sbbiu_ack_i(sbbiu_ack_biu),
	.sbbiu_err_i(sbbiu_err_biu)
);

//
// Instantiation of Debug Unit
//
or1200_du or1200_du(
	// RISC Internal Interface
	.clk(clk_i),
	.rst(rst_i),
	.dcpu_cycstb_i(dcpu_cycstb_cpu),
	.dcpu_we_i(dcpu_we_cpu),
	.dcpu_adr_i(dcpu_adr_cpu),
	.dcpu_dat_lsu(dcpu_dat_cpu),
	.dcpu_dat_dc(dcpu_dat_qmem),
	.icpu_cycstb_i(icpu_cycstb_cpu),
	.ex_freeze(ex_freeze),
	.branch_op(branch_op),
	.ex_insn(ex_insn),
	.id_pc(id_pc),
	.du_dsr(du_dsr),
	.du_dmr1(du_dmr1),
	.du_flush_pipe(du_flush_pipe),

	// For Trace buffer
	.spr_dat_npc(spr_dat_npc),
	.rf_dataw(rf_dataw),

	// DU's access to SPR unit
	.du_stall(du_stall),
	.du_addr(du_addr),
	.du_dat_i(du_dat_cpu),
	.du_dat_o(du_dat_du),
	.du_read(du_read),
	.du_write(du_write),
	.du_except_stop(du_except_stop),
	.du_hwbkpt(du_hwbkpt),

	// Access to DU's SPRs
	.spr_cs(spr_cs[ 5'd06]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_du),

	// External Debug Interface
	.dbg_stall_i(dbg_stall_i),
	.dbg_ewt_i(dbg_ewt_i),
	.dbg_lss_o(dbg_lss_o),
	.dbg_is_o(dbg_is_o),
	.dbg_wp_o(dbg_wp_o),
	.dbg_bp_o(dbg_bp_o),
	.dbg_stb_i(dbg_stb_i),
	.dbg_we_i(dbg_we_i),
	.dbg_adr_i(dbg_adr_i),
	.dbg_dat_i(dbg_dat_i),
	.dbg_dat_o(dbg_dat_o),
	.dbg_ack_o(dbg_ack_o)
);

//
// Programmable interrupt controller
//
or1200_pic or1200_pic(
	// RISC Internal Interface
	.clk(clk_i),
	.rst(rst_i),
	.spr_cs(spr_cs[ 5'd09]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_pic),
	.pic_wakeup(pic_wakeup),
	.intr(sig_int), 

	// PIC Interface
	.pic_int(pic_ints_i)
);

//
// Instantiation of Tick timer
//
or1200_tt or1200_tt(
	// RISC Internal Interface
	.clk(clk_i),
	.rst(rst_i),
	.du_stall(du_stall),
	.spr_cs(spr_cs[ 5'd10]),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_tt),
	.intr(sig_tick)
);

//
// Instantiation of Power Management
//
or1200_pm or1200_pm(
	// RISC Internal Interface
	.clk(clk_i),
	.rst(rst_i),
	.pic_wakeup(pic_wakeup),
	.spr_write(spr_we),
	.spr_addr(spr_addr),
	.spr_dat_i(spr_dat_cpu),
	.spr_dat_o(spr_dat_pm),

	// Power Management Interface
	.pm_cpustall(pm_cpustall_i),
	.pm_clksd(pm_clksd_o),
	.pm_dc_gate(pm_dc_gate_o),
	.pm_ic_gate(pm_ic_gate_o),
	.pm_dmmu_gate(pm_dmmu_gate_o),
	.pm_immu_gate(pm_immu_gate_o),
	.pm_tt_gate(pm_tt_gate_o),
	.pm_cpu_gate(pm_cpu_gate_o),
	.pm_wakeup(pm_wakeup_o),
	.pm_lvolt(pm_lvolt_o)
);


endmodule

`line 1 "../../rtl/verilog/or1200_tpram_32x32.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Generic Two-Port Synchronous RAM                            ////
////                                                              ////
////  This file is part of memory library available from          ////
////  http://www.opencores.org/cvsweb.shtml/generic_memories/     ////
////                                                              ////
////  Description                                                 ////
////  This block is a wrapper with common two-port                ////
////  synchronous memory interface for different                  ////
////  types of ASIC and FPGA RAMs. Beside universal memory        ////
////  interface it also provides behavioral model of generic      ////
////  two-port synchronous RAM.                                   ////
////  It should be used in all OPENCORES designs that want to be  ////
////  portable accross different target technologies and          ////
////  independent of target memory.                               ////
////                                                              ////
////  Supported ASIC RAMs are:                                    ////
////  - Artisan Double-Port Sync RAM                              ////
////  - Avant! Two-Port Sync RAM (*)                              ////
////  - Virage 2-port Sync RAM                                    ////
////                                                              ////
////  Supported FPGA RAMs are:                                    ////
////  - Xilinx Virtex RAMB16                                      ////
////  - Xilinx Virtex RAMB4                                       ////
////  - Altera LPM                                                ////
////                                                              ////
////  To Do:                                                      ////
////   - fix Avant!                                               ////
////   - xilinx rams need external tri-state logic                ////
////   - add additional RAMs (VS etc)                             ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_tpram_32x32.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Coding style changed.
//
// Revision 1.5  2005/10/19 11:37:56  jcastillo
// Added support for RAMB16 Xilinx4/Spartan3 primitives
//
// Revision 1.4  2004/06/08 18:15:48  lampret
// Changed behavior of the simulation generic models
//
// Revision 1.3  2004/04/05 08:29:57  lampret
// Merged branch_qmem into main tree.
//
// Revision 1.2.4.1  2003/07/08 15:36:37  lampret
// Added embedded memory QMEM.
//
// Revision 1.2  2003/04/07 01:19:07  lampret
// Added Altera LPM RAMs. Changed generic RAM output when OE inactive.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.7  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.6  2001/10/14 13:12:09  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
// Revision 1.2  2001/07/30 05:38:02  lampret
// Adding empty directories required by HDL coding guidelines
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 106 "../../rtl/verilog/or1200_tpram_32x32.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 107 "../../rtl/verilog/or1200_tpram_32x32.v" 2

module or1200_tpram_32x32(
	// Generic synchronous two-port RAM interface
	clk_a, rst_a, ce_a, we_a, oe_a, addr_a, di_a, do_a,
	clk_b, rst_b, ce_b, we_b, oe_b, addr_b, di_b, do_b
);

//
// Default address and data buses width
//
parameter aw = 5;
parameter dw = 32;

//
// Generic synchronous two-port RAM interface
//
input			clk_a;	// Clock
input			rst_a;	// Reset
input			ce_a;	// Chip enable input
input			we_a;	// Write enable input
input			oe_a;	// Output enable input
input 	[aw-1:0]	addr_a;	// address bus inputs
input	[dw-1:0]	di_a;	// input data bus
output	[dw-1:0]	do_a;	// output data bus
input			clk_b;	// Clock
input			rst_b;	// Reset
input			ce_b;	// Chip enable input
input			we_b;	// Write enable input
input			oe_b;	// Output enable input
input 	[aw-1:0]	addr_b;	// address bus inputs
input	[dw-1:0]	di_b;	// input data bus
output	[dw-1:0]	do_b;	// output data bus

//
// Internal wires and registers
//


                         

  
                                
  
                                              
  
             
                                            
     
                           
      
           
              
              
              
             
           
              
           
              
              
              
             
           
             
  

     

                       

  
                                
  
                                   
  
                    
           
        
           
         
         
           
           
         
          
  

     

                        

  
                                
  
                                    
  
                      
           
           

               
           
            
            
            
              

              
           
            
            
            
             
  

     

                          

  
                                
  
                  
  

  
          
  
                              
              
             
                
                  
            
            
                  

              
             
                
                  
            
            
                 
  

  
          
  
                              
              
             
                
                   
            
            
                   

              
             
                
                   
            
            
                  
  

     

                           

  
                                
  
                    
  
                   
  

                              
              
             
                          
            
             
            
            
            
         

              
             
                          
            
             
            
            
            
        
  

     

                            

  
                                
  
             
  
                        
  
                             
                       
                     
                       
                
                     
                
                  
                  
                    
                    
                
                
             
            
  

                                                               
                                       
                                         
                                          
                                      
                                        
                                         
                                       
                                         
                                          
                                      
                                        
                                         
                                               
                                                            
                                                
                                               
                                                            
                                                
                                               
                                                  
                                                  
                                                
                                           
                                              
                                              
                                                
                                            
                                                   

     

//
// Generic two-port synchronous RAM model
//

//
// Generic RAM's registers and wires
//
reg	[dw-1:0]	mem [(1<<aw)-1:0];	// RAM content
reg	[aw-1:0]	addr_a_reg;		// RAM read address register
reg	[aw-1:0]	addr_b_reg;		// RAM read address register

//
// Data output drivers
//
assign do_a = (oe_a) ? mem[addr_a_reg] : {dw{1'b0}};
assign do_b = (oe_b) ? mem[addr_b_reg] : {dw{1'b0}};

//
// RAM write
//
always @(posedge clk_a)
	if (ce_a && we_a)
		mem[addr_a] <=  di_a;

//
// RAM write
//
always @(posedge clk_b)
	if (ce_b && we_b)
		mem[addr_b] <=  di_b;

//
// RAM read address register
//
always @(posedge clk_a or       posedge rst_a)
	if (rst_a ==       (1'b1))
		addr_a_reg <=  {aw{1'b0}};
	else if (ce_a)
		addr_a_reg <=  addr_a;

//
// RAM read address register
//
always @(posedge clk_b or       posedge rst_b)
	if (rst_b ==       (1'b1))
		addr_b_reg <=  {aw{1'b0}};
	else if (ce_b)
		addr_b_reg <=  addr_b;

      	// !OR1200_ALTERA_LPM
      	// !OR1200_XILINX_RAMB16
      	// !OR1200_XILINX_RAMB4
      	// !OR1200_VIRAGE_STP
      	// !OR1200_AVANT_ATP
      	// !OR1200_ARTISAN_SDP

endmodule

`line 1 "../../rtl/verilog/or1200_tt.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Tick Timer                                         ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  TT according to OR1K architectural specification.           ////
////                                                              ////
////  To Do:                                                      ////
////   None                                                       ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 46 "../../rtl/verilog/or1200_tt.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 47 "../../rtl/verilog/or1200_tt.v" 2

module or1200_tt(
	// RISC Internal Interface
	clk, rst, du_stall,
	spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o,
	intr
);

//
// RISC Internal Interface
//
input		clk;		// Clock
input		rst;		// Reset
input		du_stall;	// DU stall
input		spr_cs;		// SPR CS
input		spr_write;	// SPR Write
input	[31:0]	spr_addr;	// SPR Address
input	[31:0]	spr_dat_i;	// SPR Write Data
output	[31:0]	spr_dat_o;	// SPR Read Data
output		intr;		// Interrupt output

                            

//
// TT Mode Register bits (or no register)
//
                     
reg	[31:0]	ttmr;	// TTMR bits
     
                                     
      

//
// TT Count Register bits (or no register)
//
                     
reg	[31:0]	ttcr;	// TTCR bits
     
                                     
      

//
// Internal wires & regs
//
wire		ttmr_sel;	// TTMR select
wire		ttcr_sel;	// TTCR select
wire		match;		// Asserted when TTMR[TP]
				// is equal to TTCR[27:0]
wire		restart;	// Restart counter when asserted
wire		stop;		// Stop counter when asserted
reg	[31:0] 	spr_dat_o;	// SPR data out

//
// TT registers address decoder
//
assign ttmr_sel = (spr_cs && (spr_addr[ 0] ==  1'd0)) ? 1'b1 : 1'b0;
assign ttcr_sel = (spr_cs && (spr_addr[ 0] ==  1'd1)) ? 1'b1 : 1'b0;

//
// Write to TTMR or update of TTMR[IP] bit
//
                     
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		ttmr <= 32'b0;
	else if (ttmr_sel && spr_write)
		ttmr <=  spr_dat_i;
	else if (ttmr[ 29])
		ttmr[ 28] <=  ttmr[ 28] | (match & ttmr[ 29]);
     
                                              
      

//
// Write to or increment of TTCR
//
                     
always @(posedge clk or       posedge rst)
	if (rst ==       (1'b1))
		ttcr <= 32'b0;
	else if (restart)
		ttcr <=  32'b0;
	else if (ttcr_sel && spr_write)
		ttcr <=  spr_dat_i;
	else if (!stop)
		ttcr <=  ttcr + 32'd1;
     
                    
      

//
// Read TT registers
//
always @(spr_addr or ttmr or ttcr)
	case (spr_addr[ 0])	// synopsys parallel_case
                         
		 1'd0: spr_dat_o = ttmr;
      
		default: spr_dat_o = ttcr;
	endcase

//
// A match when TTMR[TP] is equal to TTCR[27:0]
//
assign match = (ttmr[ 27:0] == ttcr[27:0]) ? 1'b1 : 1'b0;

//
// Restart when match and TTMR[M]==0x1
//
assign restart = match && (ttmr[ 31:30] == 2'b01);

//
// Stop when match and TTMR[M]==0x2 or when TTMR[M]==0x0 or when RISC is stalled by debug unit
//
assign stop = match & (ttmr[ 31:30] == 2'b10) | (ttmr[ 31:30] == 2'b00) | du_stall;

//
// Generate an interrupt request
//
assign intr = ttmr[ 28];

     

  
                                                                             
  
                   

  
                    
  
                         
                         
      

      

endmodule

`line 1 "../../rtl/verilog/or1200_wb_biu.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's WISHBONE BIU                                       ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Implements WISHBONE interface                               ////
////                                                              ////
////  To Do:                                                      ////
////   - if biu_cyc/stb are deasserted and wb_ack_i is asserted   ////
////   and this happens even before aborted_r is asssrted,        ////
////   wb_ack_i will be delivered even though transfer is         ////
////   internally considered already aborted. However most        ////
////   wb_ack_i are externally registered and delayed. Normally   ////
////   this shouldn't cause any problems.                         ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_wb_biu.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Major update: 
// Structure reordered and bugs fixed. 
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 57 "../../rtl/verilog/or1200_wb_biu.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 58 "../../rtl/verilog/or1200_wb_biu.v" 2

module or1200_wb_biu(
		     // RISC clock, reset and clock control
		     clk, rst, clmode,

		     // WISHBONE interface
		     wb_clk_i, wb_rst_i, wb_ack_i, wb_err_i, wb_rty_i, wb_dat_i,
		     wb_cyc_o, wb_adr_o, wb_stb_o, wb_we_o, wb_sel_o, wb_dat_o,
                    
                
      
                   
		     wb_cti_o, wb_bte_o,
      

		     // Internal RISC bus
		     biu_dat_i, biu_adr_i, biu_cyc_i, biu_stb_i, biu_we_i, biu_sel_i, biu_cab_i,
		     biu_dat_o, biu_ack_o, biu_err_o
		     );

   parameter dw =   32;
   parameter aw =   32;
   parameter bl = 4; /* Can currently be either 4 or 8 - the two optional line
		      sizes for the OR1200. */
		      
   
   //
   // RISC clock, reset and clock control
   //
   input				clk;		// RISC clock
   input				rst;		// RISC reset
   input [1:0] 				clmode;		// 00 WB=RISC, 01 WB=RISC/2, 10 N/A, 11 WB=RISC/4

   //
   // WISHBONE interface
   //
   input				wb_clk_i;	// clock input
   input				wb_rst_i;	// reset input
   input				wb_ack_i;	// normal termination
   input				wb_err_i;	// termination w/ error
   input				wb_rty_i;	// termination w/ retry
   input [dw-1:0] 			wb_dat_i;	// input data bus
   output				wb_cyc_o;	// cycle valid output
   output [aw-1:0] 			wb_adr_o;	// address bus outputs
   output				wb_stb_o;	// strobe output
   output				wb_we_o;	// indicates write transfer
   output [3:0] 			wb_sel_o;	// byte select outputs
   output [dw-1:0] 			wb_dat_o;	// output data bus
                    
                                                   
      
                   
   output [2:0] 			wb_cti_o;	// cycle type identifier
   output [1:0] 			wb_bte_o;	// burst type extension
      

   //
   // Internal RISC interface
   //
   input [dw-1:0] 			biu_dat_i;	// input data bus
   input [aw-1:0] 			biu_adr_i;	// address bus
   input				biu_cyc_i;	// WB cycle
   input				biu_stb_i;	// WB strobe
   input				biu_we_i;	// WB write enable
   input				biu_cab_i;	// CAB input
   input [3:0] 				biu_sel_i;	// byte selects
   output [31:0] 			biu_dat_o;	// output data bus
   output				biu_ack_o;	// ack output
   output				biu_err_o;	// err output

   //
   // Registers
   //
   wire 				wb_ack;		// normal termination
   reg [aw-1:0] 			wb_adr_o;	// address bus outputs
   reg 					wb_cyc_o;	// cycle output
   reg 					wb_stb_o;	// strobe output
   reg 					wb_we_o;	// indicates write transfer
   reg [3:0] 				wb_sel_o;	// byte select outputs
                    
                                   
      
                   
   reg [2:0] 				wb_cti_o;	// cycle type identifier
   reg [1:0] 				wb_bte_o;	// burst type extension
      
                      
                                               
        
   assign wb_dat_o = biu_dat_i;    // No register on this - straight from DCRAM
      
   
                      
                                                           
     
   wire 				retry_cnt;
   assign retry_cnt = 1'b0;
      
                   
   reg [3:0] 				burst_len;	// burst counter
      

   reg  				biu_stb_reg;	// WB strobe
   wire  				biu_stb;	// WB strobe
   reg 					wb_cyc_nxt;	// next WB cycle value
   reg 					wb_stb_nxt;	// next WB strobe value
   reg [2:0] 				wb_cti_nxt;	// next cycle type identifier value

   reg 					wb_ack_cnt;	// WB ack toggle counter
   reg 					wb_err_cnt;	// WB err toggle counter
   reg 					wb_rty_cnt;	// WB rty toggle counter
   reg 					biu_ack_cnt;	// BIU ack toggle counter
   reg 					biu_err_cnt;	// BIU err toggle counter
   reg 					biu_rty_cnt;	// BIU rty toggle counter
   wire 				biu_rty;	// BIU rty indicator

   reg [1:0] 				wb_fsm_state_cur;	// WB FSM - surrent state
   reg [1:0] 				wb_fsm_state_nxt;	// WB FSM - next state
   wire [1:0] 				wb_fsm_idle	= 2'h0;	// WB FSM state - IDLE
   wire [1:0] 				wb_fsm_trans	= 2'h1;	// WB FSM state - normal TRANSFER
   wire [1:0] 				wb_fsm_last	= 2'h2;	// EB FSM state - LAST transfer

   //
   // WISHBONE I/F <-> Internal RISC I/F conversion
   //
   //assign wb_ack = wb_ack_i;
   assign wb_ack = wb_ack_i & !wb_err_i & !wb_rty_i;

   //
   // WB FSM - register part
   // 
   always @(posedge wb_clk_i or       posedge wb_rst_i) begin
      if (wb_rst_i ==       (1'b1)) 
	wb_fsm_state_cur <=  wb_fsm_idle;
      else 
	wb_fsm_state_cur <=  wb_fsm_state_nxt;
   end

   //
   // WB burst tength counter
   // 
   always @(posedge wb_clk_i or       posedge wb_rst_i) begin
      if (wb_rst_i ==       (1'b1)) begin
	 burst_len <= 0;
      end
      else begin
	 // burst counter
	 if (wb_fsm_state_cur == wb_fsm_idle)
	   burst_len <=  bl[3:0] - 2;
	 else if (wb_stb_o & wb_ack)
	   burst_len <=  burst_len - 1;
      end
   end

   // 
   // WB FSM - combinatorial part
   // 
   always @(wb_fsm_state_cur or burst_len or wb_err_i or wb_rty_i or wb_ack or 
	    wb_cti_o or wb_sel_o or wb_stb_o or wb_we_o or biu_cyc_i or 
	    biu_stb or biu_cab_i or biu_sel_i or biu_we_i) begin
      // States of WISHBONE Finite State Machine
      case(wb_fsm_state_cur)
	// IDLE 
	wb_fsm_idle : begin
	   wb_cyc_nxt = biu_cyc_i & biu_stb;
	   wb_stb_nxt = biu_cyc_i & biu_stb;
	   wb_cti_nxt = {!biu_cab_i, 1'b1, !biu_cab_i};
	   if (biu_cyc_i & biu_stb)
	     wb_fsm_state_nxt = wb_fsm_trans;
	   else
	     wb_fsm_state_nxt = wb_fsm_idle;
	end
	// normal TRANSFER
	wb_fsm_trans : begin
	   wb_cyc_nxt = !wb_stb_o | !wb_err_i & !wb_rty_i & 
			!(wb_ack & wb_cti_o == 3'b111);
	   
	   wb_stb_nxt = !wb_stb_o | !wb_err_i & !wb_rty_i & !wb_ack | 
			!wb_err_i & !wb_rty_i & wb_cti_o == 3'b010 ;
	   wb_cti_nxt[2] = wb_stb_o & wb_ack & burst_len == 'h0 | wb_cti_o[2];
	   wb_cti_nxt[1] = 1'b1  ;
	   wb_cti_nxt[0] = wb_stb_o & wb_ack & burst_len == 'h0 | wb_cti_o[0];

	   if ((!biu_cyc_i | !biu_stb | !biu_cab_i | biu_sel_i != wb_sel_o | 
		biu_we_i != wb_we_o) & wb_cti_o == 3'b010)
	     wb_fsm_state_nxt = wb_fsm_last;
	   else if ((wb_err_i | wb_rty_i | wb_ack & wb_cti_o==3'b111) & 
		    wb_stb_o)
	     wb_fsm_state_nxt = wb_fsm_idle;
	   else
	     wb_fsm_state_nxt = wb_fsm_trans;
	end
	// LAST transfer
	wb_fsm_last : begin
	   wb_cyc_nxt = !wb_stb_o | !wb_err_i & !wb_rty_i & 
			!(wb_ack & wb_cti_o == 3'b111);
	   wb_stb_nxt = !wb_stb_o | !wb_err_i & !wb_rty_i & 
			!(wb_ack & wb_cti_o == 3'b111);
	   wb_cti_nxt[2] = wb_ack & wb_stb_o | wb_cti_o[2];
	   wb_cti_nxt[1] = 1'b1                  ;
	   wb_cti_nxt[0] = wb_ack & wb_stb_o | wb_cti_o[0];
	   if ((wb_err_i | wb_rty_i | wb_ack & wb_cti_o == 3'b111) & wb_stb_o)
	     wb_fsm_state_nxt = wb_fsm_idle;
	   else
	     wb_fsm_state_nxt = wb_fsm_last;
	end
	// default state
	default:begin
	   wb_cyc_nxt = 1'bx;
	   wb_stb_nxt = 1'bx;
	   wb_cti_nxt = 3'bxxx;
	   wb_fsm_state_nxt = 2'bxx;
	end
      endcase
   end

   //
   // WB FSM - output signals
   // 
   always @(posedge wb_clk_i or       posedge wb_rst_i) begin
      if (wb_rst_i ==       (1'b1)) begin
	 wb_cyc_o	<=  1'b0;
	 wb_stb_o	<=  1'b0;
	 wb_cti_o	<=  3'b111;
	 wb_bte_o	<=  (bl==8) ? 2'b10 : (bl==4) ? 2'b01 : 2'b00;
                    
                    
      
	 wb_we_o		<=  1'b0;
	 wb_sel_o	<=  4'hf;
	 wb_adr_o	<=  {aw{1'b0}};
                     
                          
      	 
      end
      else begin
	 wb_cyc_o	<=  wb_cyc_nxt;

         if (wb_ack & wb_cti_o == 3'b111) 
           wb_stb_o        <=  1'b0;
         else
           wb_stb_o        <=  wb_stb_nxt;
                        
	 wb_cti_o	<=  wb_cti_nxt;
      	 
	 wb_bte_o	<=  (bl==8) ? 2'b10 : (bl==4) ? 2'b01 : 2'b00;
                    
                         
      
	 // we and sel - set at beginning of access 
	 if (wb_fsm_state_cur == wb_fsm_idle) begin
	    wb_we_o		<=  biu_we_i;
	    wb_sel_o	<=  biu_sel_i;
	 end
	 // adr - set at beginning of access and changed at every termination 
	 if (wb_fsm_state_cur == wb_fsm_idle) begin
	    wb_adr_o	<=  biu_adr_i;
	 end 
	 else if (wb_stb_o & wb_ack) begin
	    if (bl==4) begin
	       wb_adr_o[3:2]	<=  wb_adr_o[3:2] + 1;
	    end
	    if (bl==8) begin
	       wb_adr_o[4:2]	<=  wb_adr_o[4:2] + 1;
	    end
	 end
                     
                                                                 
                      
                             
     
      	 
      end
   end

   //
   // WB & BIU termination toggle counters
   // 
   always @(posedge wb_clk_i or       posedge wb_rst_i) begin
      if (wb_rst_i ==       (1'b1)) begin
	 wb_ack_cnt	<=  1'b0;
	 wb_err_cnt	<=  1'b0;
	 wb_rty_cnt	<=  1'b0;
      end
      else begin
	 // WB ack toggle counter
	 if (wb_fsm_state_cur == wb_fsm_idle | !(|clmode))
	   wb_ack_cnt	<=  1'b0;
	 else if (wb_stb_o & wb_ack)
	   wb_ack_cnt	<=  !wb_ack_cnt;
	 // WB err toggle counter
	 if (wb_fsm_state_cur == wb_fsm_idle | !(|clmode))
	   wb_err_cnt	<=  1'b0;
	 else if (wb_stb_o & wb_err_i)
	   wb_err_cnt	<=  !wb_err_cnt;
	 // WB rty toggle counter
	 if (wb_fsm_state_cur == wb_fsm_idle | !(|clmode))
	   wb_rty_cnt	<=  1'b0;
	 else if (wb_stb_o & wb_rty_i)
	   wb_rty_cnt	<=  !wb_rty_cnt;
      end
   end

   always @(posedge clk or       posedge rst) begin
      if (rst ==       (1'b1)) begin
         biu_stb_reg	<=  1'b0;
	 biu_ack_cnt	<=  1'b0;
	 biu_err_cnt	<=  1'b0;
	 biu_rty_cnt	<=  1'b0;
                      
                                        
      
      end
      else begin
	 // BIU strobe
	 if (biu_stb_i & !biu_cab_i & biu_ack_o)
	   biu_stb_reg	<=  1'b0;
	 else
	   biu_stb_reg	<=  biu_stb_i;
	 // BIU ack toggle counter
	 if (wb_fsm_state_cur == wb_fsm_idle | !(|clmode))
	   biu_ack_cnt	<=  1'b0 ;
	 else if (biu_ack_o)
	   biu_ack_cnt	<=  !biu_ack_cnt ;
	 // BIU err toggle counter
	 if (wb_fsm_state_cur == wb_fsm_idle | !(|clmode))
	   biu_err_cnt	<=  1'b0 ;
	 else if (wb_err_i & biu_err_o)
	   biu_err_cnt	<=  !biu_err_cnt ;
	 // BIU rty toggle counter
	 if (wb_fsm_state_cur == wb_fsm_idle | !(|clmode))
	   biu_rty_cnt	<=  1'b0 ;
	 else if (biu_rty)
	   biu_rty_cnt	<=  !biu_rty_cnt ;
                      
                            
                                           
                   
                                   
      
      end
   end

   assign biu_stb = biu_stb_i & biu_stb_reg;

   //
   // Input BIU data bus
   //
   assign	biu_dat_o	= wb_dat_i;

   //
   // Input BIU termination signals 
   //
   assign	biu_rty		= (wb_fsm_state_cur == wb_fsm_trans) & wb_rty_i & wb_stb_o & (wb_rty_cnt ~^ biu_rty_cnt);
   assign	biu_ack_o	= (wb_fsm_state_cur == wb_fsm_trans) & wb_ack & wb_stb_o & (wb_ack_cnt ~^ biu_ack_cnt);
   assign	biu_err_o	= (wb_fsm_state_cur == wb_fsm_trans) & wb_err_i & wb_stb_o & (wb_err_cnt ~^ biu_err_cnt)
                      
                                               
     
   ;
      


endmodule

`line 1 "../../rtl/verilog/or1200_wbmux.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's Write-back Mux                                     ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  CPU's write-back stage of the pipeline                      ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//
// $Log: or1200_wbmux.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 50 "../../rtl/verilog/or1200_wbmux.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 51 "../../rtl/verilog/or1200_wbmux.v" 2

module or1200_wbmux(
	// Clock and reset
	clk, rst,

	// Internal i/f
	wb_freeze, rfwb_op,
	muxin_a, muxin_b, muxin_c, muxin_d, muxin_e,
	muxout, muxreg, muxreg_valid
);

parameter width =   32;

//
// I/O
//

//
// Clock and reset
//
input				clk;
input				rst;

//
// Internal i/f
//
input				wb_freeze;
input	[  4-1:0]	rfwb_op;
input	[width-1:0]		muxin_a;
input	[width-1:0]		muxin_b;
input	[width-1:0]		muxin_c;
input	[width-1:0]		muxin_d;
input	[width-1:0]		muxin_e;   
output	[width-1:0]		muxout;
output	[width-1:0]		muxreg;
output				muxreg_valid;

//
// Internal wires and regs
//
reg	[width-1:0]		muxout;
reg	[width-1:0]		muxreg;
reg				muxreg_valid;

//
// Registered output from the write-back multiplexer
//
always @(posedge clk or       posedge rst) begin
	if (rst ==       (1'b1)) begin
		muxreg <=  32'd0;
		muxreg_valid <=  1'b0;
	end
	else if (!wb_freeze) begin
		muxreg <=  muxout;
		muxreg_valid <=  rfwb_op[0];
	end
end

//
// Write-back multiplexer
//
always @(muxin_a or muxin_b or muxin_c or muxin_d or muxin_e or rfwb_op) begin
                                            
                                                                             
     
	casez(rfwb_op[  4-1:1]) // synopsys parallel_case
      
		  3'b000: muxout = muxin_a;
		  3'b001: begin
			muxout = muxin_b;
                     
                         
                                            
                        
      
		end
		  3'b010: begin
			muxout = muxin_c;
                     
                         
                                            
                        
      
		end
		  3'b011: begin
			muxout = muxin_d + 32'h8;
                     
                         
                                                   
                        
      
		end
                             
                                   
                             
                      
                         
                                            
                        
      
                   
      
	  default : begin
	     muxout = 0;
	  end
	  
	endcase
end

endmodule

`line 1 "../../rtl/verilog/or1200_xcv_ram32x8d.v" 0
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  Xilinx Virtex RAM 32x8D                                     ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/cores/or1k/                        ////
////                                                              ////
////  Description                                                 ////
////  Virtex dual-port memory                                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: or1200_xcv_ram32x8d.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 
//
// Revision 1.2  2002/07/14 22:17:17  lampret
// Added simple trace buffer [only for Xilinx Virtex target]. Fixed instruction fetch abort when new exception is recognized.
//
// Revision 1.1  2002/01/03 08:16:15  lampret
// New prefixes for RTL files, prefixed module names. Updated cache controllers and MMUs.
//
// Revision 1.7  2001/10/21 17:57:16  lampret
// Removed params from generic_XX.v. Added translate_off/on in sprs.v and id.v. Removed spr_addr from dc.v and ic.v. Fixed CR+LF.
//
// Revision 1.6  2001/10/14 13:12:10  lampret
// MP3 version.
//
// Revision 1.1.1.1  2001/10/06 10:18:36  igorm
// no message
//
// Revision 1.1  2001/08/09 13:39:33  lampret
// Major clean-up.
//
//

// synopsys translate_off
`line 1 "timescale.v" 1
`timescale 1ps/1ps

`line 71 "../../rtl/verilog/or1200_xcv_ram32x8d.v" 2
// synopsys translate_on
`line 1 "or1200_defines.v" 1
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's definitions                                        ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Defines for the OR1200 core                                 ////
////                                                              ////
////  To Do:                                                      ////
////   - add parameters that are missing                          ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_defines.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// Minor update: 
// Defines added, bugs fixed. 

//
// Dump VCD
//
//`define OR1200_VCD_DUMP

//
// Generate debug messages during simulation
//
//`define OR1200_VERBOSE

//  `define OR1200_ASIC
////////////////////////////////////////////////////////
//
// Typical configuration for an ASIC
//
                  

  
                       
  
                            
                            
                            
                                 
                                      
                                      

  
                              
  
                      

  
                              
  
                      

  
                            
  
                        

  
                            
  
                        

  
                                                       
  
                                  
                                   

  
                                              
  
                            
                           
                        
                           
                        

     


/////////////////////////////////////////////////////////
//
// Typical configuration for an FPGA
//

//
// Target FPGA memories
//
//`define OR1200_ALTERA_LPM
//`define OR1200_XILINX_RAMB16
//`define OR1200_XILINX_RAMB4
//`define OR1200_XILINX_RAM32X1D
//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D
// Generic models should infer RAM blocks at synthesis time (not only effects 
// single port ram.)
                      

//
// Do not implement Data cache
//
//`define OR1200_NO_DC

//
// Do not implement Insn cache
//
//`define OR1200_NO_IC

//
// Do not implement Data MMU
//
//`define OR1200_NO_DMMU

//
// Do not implement Insn MMU
//
//`define OR1200_NO_IMMU

//
// Select between ASIC and generic multiplier
//
// (Generic seems to trigger a bug in the Cadence Ncsim simulator)
//
//`define OR1200_ASIC_MULTP2_32X32
                                   

//
// Size/type of insn/data cache if implemented
// (consider available FPGA memory resources)
//
//`define OR1200_IC_1W_512B
//`define OR1200_IC_1W_4KB
                        
//`define OR1200_IC_1W_16KB
//`define OR1200_IC_1W_32KB
//`define OR1200_DC_1W_4KB
                        
//`define OR1200_DC_1W_16KB
//`define OR1200_DC_1W_32KB

      


//////////////////////////////////////////////////////////
//
// Do not change below unless you know what you are doing
//

//
// Reset active low
//
//`define OR1200_RST_ACT_LOW

//
// Enable RAM BIST
//
// At the moment this only works for Virtual Silicon
// single port RAMs. For other RAMs it has not effect.
// Special wrapper for VS RAMs needs to be provided
// with scan flops to facilitate bist scan.
//
//`define OR1200_BIST

//
// Register OR1200 WISHBONE outputs
// (must be defined/enabled)
//
                                 

//
// Register OR1200 WISHBONE inputs
//
// (must be undefined/disabled)
//
//`define OR1200_REGISTERED_INPUTS

//
// Disable bursts if they are not supported by the
// memory subsystem (only affect cache line fill)
//
//`define OR1200_NO_BURSTS
//

//
// WISHBONE retry counter range
//
// 2^value range for retry counter. Retry counter
// is activated whenever *wb_rty_i is asserted and
// until retry counter expires, corresponding
// WISHBONE interface is deactivated.
//
// To disable retry counters and *wb_rty_i all together,
// undefine this macro.
//
//`define OR1200_WB_RETRY 7

//
// WISHBONE Consecutive Address Burst
//
// This was used prior to WISHBONE B3 specification
// to identify bursts. It is no longer needed but
// remains enabled for compatibility with old designs.
//
// To remove *wb_cab_o ports undefine this macro.
//
//`define OR1200_WB_CAB

//
// WISHBONE B3 compatible interface
//
// This follows the WISHBONE B3 specification.
// It is not enabled by default because most
// designs still don't use WB b3.
//
// To enable *wb_cti_o/*wb_bte_o ports,
// define this macro.
//
                    

//
// LOG all WISHBONE accesses
//
                            

//
// Enable additional synthesis directives if using
// _Synopsys_ synthesis tool
//
//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES

//
// Enables default statement in some case blocks
// and disables Synopsys synthesis directive full_case
//
// By default it is enabled. When disabled it
// can increase clock frequency.
//
                           

//
// Operand width / register file address width
//
// (DO NOT CHANGE)
//
                                
                                   

//
// l.add/l.addi/l.and and optional l.addc/l.addic
// also set (compare) flag when result of their
// operation equals zero
//
// At the time of writing this, default or32
// C/C++ compiler doesn't generate code that
// would benefit from this optimization.
//
// By default this optimization is disabled to
// save area.
//
//`define OR1200_ADDITIONAL_FLAG_MODIFIERS

//
// Implement l.addc/l.addic instructions
//
// By default implementation of l.addc/l.addic
// instructions is enabled in case you need them.
// If you don't use them, then disable implementation
// to save area.
//
                        

//
// Implement l.sub instruction
//
// By default implementation of l.sub instructions
// is enabled to be compliant with the simulator.
// If you don't use carry bit, then disable
// implementation to save area.
//
                       

//
// Implement carry bit SR[CY]
//
//
// By default implementation of SR[CY] is enabled
// to be compliant with the simulator. However SR[CY]
// is explicitly only used by l.addc/l.addic/l.sub
// instructions and if these three insns are not
// implemented there is not much point having SR[CY].
//
                      

//
// Implement carry bit SR[OV]
//
// Compiler doesn't use this, but other code may like
// to.
//
                      

//
// Implement carry bit SR[OVE]
//
// Overflow interrupt indicator. When enabled, SR[OV] flag
// does not remain asserted after exception.
//
                       


//
// Implement rotate in the ALU
//
// At the time of writing this, or32
// C/C++ compiler doesn't generate rotate
// instructions. However or32 assembler
// can assemble code that uses rotate insn.
// This means that rotate instructions
// must be used manually inserted.
//
// By default implementation of rotate
// is disabled to save area and increase
// clock frequency.
//
//`define OR1200_IMPL_ALU_ROTATE

//
// Type of ALU compare to implement
//
// Try to find which synthesizes with
// most efficient logic use or highest speed.
//
//`define OR1200_IMPL_ALU_COMP1
//`define OR1200_IMPL_ALU_COMP2
                             

//
// Implement Find First/Last '1'
//
                            

//
// Implement l.cust5 ALU instruction
//
//`define OR1200_IMPL_ALU_CUST5

//
// Implement l.extXs and l.extXz instructions
//
                           

//
// Implement multiplier
//
// By default multiplier is implemented
//
                               

//
// Implement multiply-and-accumulate
//
// By default MAC is implemented. To
// implement MAC, multiplier (non-serial) needs to be
// implemented.
//
//`define OR1200_MAC_IMPLEMENTED

//
// Implement optional l.div/l.divu instructions
//
// By default divide instructions are not implemented
// to save area.
//
//
                              

//
// Serial multiplier.
//
//`define OR1200_MULT_SERIAL

//
// Serial divider.
// Uncomment to use a serial divider, otherwise will
// be a generic parallel implementation.
//
                         

//
// Implement HW Single Precision FPU
//
//`define OR1200_FPU_IMPLEMENTED

//
// Clock ratio RISC clock versus WB clock
//
// If you plan to run WB:RISC clock fixed to 1:1, disable
// both defines
//
// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED
// and use clmode to set ratio
//
// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use
// clmode to set ratio
//
//`define OR1200_CLKDIV_2_SUPPORTED
//`define OR1200_CLKDIV_4_SUPPORTED

//
// Type of register file RAM
//
// Memory macro w/ two ports (see or1200_tpram_32x32.v)
//`define OR1200_RFRAM_TWOPORT
//
// Memory macro dual port (see or1200_dpram.v)
                             

//
// Generic (flip-flop based) register file (see or1200_rfram_generic.v)
//`define OR1200_RFRAM_GENERIC
//  Generic register file supports - 16 registers 
                           
                                
      

//
// Type of mem2reg aligner to implement.
//
// Once OR1200_IMPL_MEM2REG2 yielded faster
// circuit, however with today tools it will
// most probably give you slower circuit.
//
                            
//`define OR1200_IMPL_MEM2REG2

//
// Reset value and event
//
                         
                                      
                                       
     
                                      
                                       
      

//
// ALUOPs
//
                            
                                  
/* LS-nibble encodings correspond to bits [3:0] of instruction */
                                       
                                        
                                       
                                       
                                       
                                       
                                       
                                            
                                         
                                       
                                        
                                        
                                         
                                        
                                        
                                        

/* Values sent to ALU from decode unit - not defined by ISA */
                                                       
                                                      
                                               

// ALU instructions second opcode field
                             
                             

//
// MACOPs
//
                            
                               
                               
                               

//
// Shift/rotate ops
//
                              
                               
                               
                               
                               
                               

//
// Zero/Sign Extend ops
//
                                   
                                      
                                      
                                      
                                      
                                   
                                      
                                      

// Execution cycles per instruction
                                 
                              
                               

// Execution control which will "wait on" a module to finish
                              
                                                          
                                                          
                                                          
                                                          


// Operand MUX selects
                           
                            
                             
                                
                                

//
// BRANCHOPs
//
                                
                                 
                               
                                
                                 
                                
                                 
                                 

//
// LSUOPs
//
// Bit 0: sign extend
// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword
// Bit 3: 0 load, 1 store
                             
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 

// Number of bits of load/store EA precalculated in ID stage
// for balancing ID and EX stages.
//
// Valid range: 2,3,...,30,31
                               

// FETCHOPs
                               
                                
                               

//
// Register File Write-Back OPs
//
// Bit 0: register file write enable
// Bits 3-1: write-back mux selects
//
                              
                                  
                                 
                                 
                                  
                                
                                 

// Compare instructions
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                 
                             

//
// FP OPs
//
// MSbit indicates FPU operation valid
//
                            
// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles
                                
// FP instruction is double precision if bit 4 is set. We're a 32-bit 
// implementation thus do not support double precision FP 
                                 
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                           
// FP Compare instructions
                                      
                                      
                                      
                                      
                                      
                                      

//
// TAGs for instruction bus
//
                                         
                                           
                                                   
                                                    
                                                  

//
// TAGs for data bus
//
                                         
                                           
                                                   
                                                   
                                                    
                                                  


//////////////////////////////////////////////
//
// ORBIS32 ISA specifics
//

// SHROT_OP position in machine word
                               

//
// Instruction opcode groups (basic)
//
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                            
                                               
/* */
                                               
                                               
                                               
/* */
                                               
                                               
                                               
                                               
                                               
                                               

/////////////////////////////////////////////////////
//
// Exceptions
//

//
// Exception vectors per OR1K architecture:
// 0xPPPPP100 - reset
// 0xPPPPP200 - bus error
// ... etc
// where P represents exception prefix.
//
// Exception vectors can be customized as per
// the following formula:
// 0xPPPPPNVV - exception N
//
// P represents exception prefix
// N represents exception N
// VV represents length of the individual vector space,
//   usually it is 8 bits wide and starts with all bits zero
//

//
// PPPPP and VV parts
//
// Sum of these two defines needs to be 28
//
                                         
                                         
                                  

//
// N part width
//
                             

//
// Definition of exception vectors
//
// To avoid implementation of a certain exception,
// simply comment out corresponding line
//
                                                     
                                                   
                                                    
                                                      
                                                    
                                                       
                                                       
                                                  
                                                      
                                                    
                                                   
                                                  
                                                  
                                                     
                                                    
                                                   


/////////////////////////////////////////////////////
//
// SPR groups
//

// Bits that define the group
                                   

// Width of the group bits
                                 

// Bits that define offset inside the group
                                

// List of groups
                                  
                                   
                                   
                                 
                                 
                                  
                                 
                                 
                                  
                                 
                                     

/////////////////////////////////////////////////////
//
// System group
//

//
// System registers
//
                             
                                         
                              
                             
                              
                                      
                               
                               
                              

//
// SR bits
//
                          
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                                     
                                     
                                     
                                   
                         
                         
                         
                                             

//
// Bits that define offset inside the group
//
                               

//
// Default Exception Prefix
//
// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)
// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)
//
                              


//
// FPCSR bits
//
                             
                            
                              
                            
                            
                            
                            
                            
                            
                            
                             
                             
                                

/////////////////////////////////////////////////////
//
// Power Management (PM)
//

// Define it if you want PM implemented
//`define OR1200_PM_IMPLEMENTED

// Bit positions inside PMR (don't change)
                             
                           
                           
                            
                                 

// PMR offset inside PM group of registers
                               

// PM group
                             

// Define if PMR can be read/written at any address inside PM group
                                  

// Define if reading PMR is allowed
                          

// Define if unused PMR bits should be zero
                             


/////////////////////////////////////////////////////
//
// Debug Unit (DU)
//

// Define it if you want DU implemented
                             

//
// Define if you want HW Breakpoints
// (if HW breakpoints are not implemented
// only default software trapping is
// possible with l.trap insn - this is
// however already enough for use
// with or32 gdb)
//
//`define OR1200_DU_HWBKPTS

// Number of DVR/DCR pairs if HW breakpoints enabled
//	Comment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! 
//	DU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS 
                                

// Define if you want trace buffer
//	(for now only available for Xilinx Virtex FPGAs)
//`define OR1200_DU_TB_IMPLEMENTED


//
// Address offsets of DU registers inside DU group
//
// To not implement a register, doq not define its address
//
                        
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                              
                              
                              
                              
                              
                              
      
                              
                        
                              
                               
                               
      
                             
                             
                               
                                
                               
                               
                               
                               
      

// Position of offset bits inside SPR address
                              

// DCR bits
                          
                            
                          
                            

// DMR1 bits
                              
                              
                              
                              
                              
                                
                                
                                
                                
                                
                                 
                            
                            
                              
                             

// DMR2 bits
                             
                             
                                
                                

// DWCR bits
                                 
                                  

// DSR bits
                              
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// DRR bits
                            
                             
                            
                            
                           
                          
                           
                          
                           
                           
                           
                            
                            
                           

// Define if reading DU regs is allowed
                          

// Define if unused DU registers bits should be zero
                             

// Define if IF/LSU status is not needed by devel i/f
                                      

/////////////////////////////////////////////////////
//
// Programmable Interrupt Controller (PIC)
//

// Define it if you want PIC implemented
                              

// Define number of interrupt inputs (2-31)
                          

// Address offsets of PIC registers inside PIC group
                                 
                                 

// Position of offset bits inside SPR address
                              

// Define if you want these PIC registers to be implemented
                        
                        

// Define if reading PIC registers is allowed
                           

// Define if unused PIC register bits should be zero
                              


/////////////////////////////////////////////////////
//
// Tick Timer (TT)
//

// Define it if you want TT implemented
                             

// Address offsets of TT registers inside TT group
                               
                               

// Position of offset bits inside SPR group
                           

// Define if you want these TT registers to be implemented
                      
                      

// TTMR bits
                              
                            
                            
                              

// Define if reading TT registers is allowed
                          


//////////////////////////////////////////////
//
// MAC
//
                                                                
                                                                    

//
// Shift {MACHI,MACLO} into destination register when executing l.macrc
//
// According to architecture manual there is no shift, so default value is 0.
// However the implementation has deviated in this from the arch manual and had
// hard coded shift by 28 bits which is a useful optimization for MP3 decoding 
// (if using libmad fixed point library). Shifts are no longer default setup, 
// but if you need to remain backward compatible, define your shift bits, which
// were normally
// dest_GPR = {MACHI,MACLO}[59:28]
                                                                                                  


//////////////////////////////////////////////
//
// Data MMU (DMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// DTLBMR fields
//
                              
                                  
                                   
                                    

//
// DTLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                
                                
                                    
                                    

//
// DTLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while DMMU is not enabled/implemented
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!dcpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!dcpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	dcpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	dcpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                                       


//////////////////////////////////////////////
//
// Insn MMU (IMMU)
//

//
// Address that selects between TLB TR and MR
//
                             

//
// ITLBMR fields
//
                              
                                  
                                   
                                    

//
// ITLBTR fields
//
                               
                               
                                
                                
                              
                              
                                
                                
                                   
                                    

//
// ITLB configuration
//
                                                      
                                                                        
                                                       
                                                                         
                                                                              
                                                                         
                                                          
                                                               
                                                                    
                                                                                      

//
// Cache inhibit while IMMU is not enabled/implemented
// Note: all combinations that use icpu_adr_i cause async loop
//
// cache inhibited 0GB-4GB		1'b1
// cache inhibited 0GB-2GB		!icpu_adr_i[31]
// cache inhibited 0GB-1GB 2GB-3GB	!icpu_adr_i[30]
// cache inhibited 1GB-2GB 3GB-4GB	icpu_adr_i[30]
// cache inhibited 2GB-4GB (default)	icpu_adr_i[31]
// cached 0GB-4GB			1'b0
//
                             


/////////////////////////////////////////////////
//
// Insn cache (IC)
//

// 4 for 16 byte line, 5 for 32 byte lines.
                        
                       
     
                       
      

//
// IC configurations
//
                        
                                                                      
                                                                    
                                                                    
                                                                    
                                                                        
                                          
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Data cache (DC)
//

// 4 for 16 bytes, 5 for 32 bytes
                        
                       
     
                       
      

// Define to enable default behavior of cache as write through
// Turning this off enabled write back statergy
//
                              

// Define to enable stores from the stack not doing writethrough.
// EXPERIMENTAL
//`define OR1200_DC_NOSTACKWRITETHROUGH

// Data cache SPR definitions
                                    
// Data cache group SPR addresses
                                                      
                                                       
                                    
                                    
                                                       
                                                       

//
// DC configurations
//
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                       
                                    
                                              
                                               
                                               
                                                       
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      
                        
                                     
                                              
                                               
                                               
                                                        
                           
      


/////////////////////////////////////////////////
//
// Store buffer (SB)
//

//
// Store buffer
//
// It will improve performance by "caching" CPU stores
// using store buffer. This is most important for function
// prologues because DC can only work in write though mode
// and all stores would have to complete external WB writes
// to memory.
// Store buffer is between DC and data BIU.
// All stores will be stored into store buffer and immediately
// completed by the CPU, even though actual external writes
// will be performed later. As a consequence store buffer masks
// all data bus errors related to stores (data bus errors
// related to loads are delivered normally).
// All pending CPU loads will wait until store buffer is empty to
// ensure strict memory model. Right now this is necessary because
// we don't make destinction between cached and cache inhibited
// address space, so we simply empty store buffer until loads
// can begin.
//
// It makes design a bit bigger, depending what is the number of
// entries in SB FIFO. Number of entries can be changed further
// down.
//
//`define OR1200_SB_IMPLEMENTED

//
// Number of store buffer entries
//
// Verified number of entries are 4 and 8 entries
// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must
// always match 2**OR1200_SB_LOG.
// To disable store buffer, undefine
// OR1200_SB_IMPLEMENTED.
//
                                  
                                     


/////////////////////////////////////////////////
//
// Quick Embedded Memory (QMEM)
//

//
// Quick Embedded Memory
//
// Instantiation of dedicated insn/data memory (RAM or ROM).
// Insn fetch has effective throughput 1insn / clock cycle.
// Data load takes two clock cycles / access, data store
// takes 1 clock cycle / access (if there is no insn fetch)).
// Memory instantiation is shared between insn and data,
// meaning if insn fetch are performed, data load/store
// performance will be lower.
//
// Main reason for QMEM is to put some time critical functions
// into this memory and to have predictable and fast access
// to these functions. (soft fpu, context switch, exception
// handlers, stack, etc)
//
// It makes design a bit bigger and slower. QMEM sits behind
// IMMU/DMMU so all addresses are physical (so the MMUs can be
// used with QMEM and QMEM is seen by the CPU just like any other
// memory in the system). IC/DC are sitting behind QMEM so the
// whole design timing might be worse with QMEM implemented.
//
//`define OR1200_QMEM_IMPLEMENTED

//
// Base address and mask of QMEM
//
// Base address defines first address of QMEM. Mask defines
// QMEM range in address space. Actual size of QMEM is however
// determined with instantiated RAM/ROM. However bigger
// mask will reserve more address space for QMEM, but also
// make design faster, while more tight mask will take
// less address space but also make design slower. If
// instantiated RAM/ROM is smaller than space reserved with
// the mask, instatiated RAM/ROM will also be shadowed
// at higher addresses in reserved space.
//
                                       
                                                            
                                       
                                                            

//
// QMEM interface byte-select capability
//
// To enable qmem_sel* ports, define this macro.
//
//`define OR1200_QMEM_BSEL

//
// QMEM interface acknowledge
//
// To enable qmem_ack port, define this macro.
//
//`define OR1200_QMEM_ACK

/////////////////////////////////////////////////////
//
// VR, UPR and Configuration Registers
//
//
// VR, UPR and configuration registers are optional. If 
// implemented, operating system can automatically figure
// out how to use the processor because it knows 
// what units are available in the processor and how they
// are configured.
//
// This section must be last in or1200_defines.v file so
// that all units are already configured and thus
// configuration registers are properly set.
// 

// Define if you want configuration registers implemented
                               

// Define if you want full address decode inside SYS group
                              

// Offsets of VR, UPR and CFGR registers
                                  
                                   
                                      
                                       
                                       
                                     
                                     
                                    

// VR fields
                               
                                 
                                 
                                 

// VR values
                             
                                
                             
                             

// UPR fields
                             
                              
                              
                              
                              
                             
                              
                               
                              
                               
                               
                               
                                   
                                  

// UPR values
                            
                   
                             
     
                             
      
                   
                             
     
                             
      
                     
                             
     
                             
      
                     
                             
     
                             
      
                             
                            
     
                            
      
                            
                             
     
                             
      
                                                                  
                            
                             
     
                             
      
                             
                              
     
                              
      
                            
                             
     
                             
      
                             
                             
     
                             
      
                                 
                              

// CPUCFGR fields
                                    
                                     
                                   
                                   
                                   
                                   
                                   
                                      

// CPUCFGR values
                                     
                         
                                      
     
                                      
      
                                  
                                  
                             
                                   
     
                                   
      

                                  
                                  
                                       

// DMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// DMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                   
                                                        
                                                      
                                                                  
                                                     
                                       
      

// IMMUCFGR fields
                                    
                                    
                                    
                                  
                                  
                                     
                                   
                                       

// IMMUCFGR values
                     
                                               
                                               
                                               
                                               
                                               
                                                 
                                               
                                       
     
                                              
                                                                 
                                                 
                                                   
                                                      
                                                                 
                                                     
                                       
      

// DCCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// DCCFGR values
                   
                                             
                                             
                                             
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                              
                             
                                                          
     
                                                       
      
                                                           
                                                              
                                                                       
                                                                   
                                                                
                             
                                                                   
     
                                                               
      
                                     
      

// ICCFGR fields
                                   
                                   
                                 
                                 
                                  
                                   
                                   
                                   
                                   
                                    
                                     

// ICCFGR values
                   
                                             
                                              
                                              
                                             
                                              
                                               
                                               
                                               
                                               
                                                
                                     
     
                                              
                                                           
                                                                             
                                             
                                                           
                                                              
                                                                       
                                                                   
                                                                
                                                
                                     
      

// DCFGR fields
                                  
                                 
                                    

// DCFGR values
                        
                                                                          
                      
                               
     
                                                        
      
     
                                                    
                                                        
      
                                

///////////////////////////////////////////////////////////////////////////////
// Boot Address Selection                                                    //
//                                                                           //
// Allows a definable boot address, potentially different to the usual reset //
// vector to allow for power-on code to be run, if desired.                  //
//                                                                           //
// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //
//                                                                           //
// For default reset behavior uncomment the settings under the "Boot 0x100"  //
// comment below.                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// Boot from 0xf0000100
//`define OR1200_BOOT_ADR 32'hf0000100
// Boot from 0x100
                                     

`line 72 "../../rtl/verilog/or1200_xcv_ram32x8d.v" 2

                             
                                       
                          
 
        
        
      
      
         
         
      
  
                    
                    
                  
                     
                  
                     
                   

                      
                      

                      
                      

                      
                      

                                      
                                   

                           
                           

                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  

  
                           
  
                      
                
                
           
           
           
           
          
                 
                 
                 
                 
             
          
  
         

     

                                                            

  
      
  
                 
                 
              
                 
              
            
          

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

  
                           
  
                    
              
              
           
           
           
           
           
          
                 
                 
                 
                 
                 
             
        
  

         
      
      

