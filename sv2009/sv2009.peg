implicit_class_handle <- 
  THIS_K DOT SUPER_K
/ THIS_K 
/ SUPER_K 

bit_select   <- ( LBRACK expression RBRACK )*

scoped_prefix <-
  (DS_UNIT_K / identifier)? (COLON2 identifier parameter_value_assignment? bit_select)*

selected_suffix <- 
  (DOT identifier bit_select)* bit_select? ( LBRACK part_select_range RBRACK )?

selected_ident <- 
  LOCAL_K (COLON2 (implicit_class_handle / identifier) parameter_value_assignment? bit_select)+ selected_suffix
/ &((DS_UNIT_K / identifier) COLON2) scoped_prefix selected_suffix
/ (implicit_class_handle / DS_ROOT_K / (identifier bit_select?)) selected_suffix

Grammar <- source_text

source_text <- timeunits_declaration? description* EOF

description <-
module_declaration
/ udp_declaration
/ interface_declaration
/ program_declaration
/ package_declaration
/ attribute_instance* package_item
/ attribute_instance* bind_directive
/ config_declaration

//just keep ansi, since it subsumes non-ansi
module_declaration <-
module_ansi_header timeunits_declaration? module_item* ENDMODULE_K (COLON identifier)?
/ attribute_instance* module_keyword lifetime? identifier ( DOT_STAR ) SEMI 
  timeunits_declaration? module_item* ENDMODULE_K (COLON identifier)?
/ EXTERN_K module_ansi_header

module_ansi_header <-
attribute_instance* module_keyword lifetime? identifier package_import_declaration* parameter_port_list? 
  list_of_port_declarations? SEMI

module_keyword <- MODULE_K / MACROMODULE_K

interface_declaration <-
interface_ansi_header timeunits_declaration? interface_item* ENDINTERFACE_K (COLON identifier)?
/ attribute_instance* INTERFACE_K identifier ( DOT_STAR ) SEMI timeunits_declaration? interface_item* ENDINTERFACE_K 
  (COLON identifier)?
/ EXTERN_K interface_ansi_header

interface_ansi_header <-
attribute_instance* INTERFACE_K lifetime? identifier package_import_declaration* parameter_port_list? 
  list_of_port_declarations? SEMI

program_declaration <-
program_ansi_header timeunits_declaration? program_item* ENDPROGRAM_K (COLON identifier)?
/ attribute_instance* PROGRAM_K identifier ( DOT_STAR ) SEMI timeunits_declaration? program_item* ENDPROGRAM_K 
  (COLON identifier)?
/ EXTERN_K program_ansi_header

program_ansi_header <-
attribute_instance* PROGRAM_K lifetime? identifier package_import_declaration* parameter_port_list? 
  list_of_port_declarations? SEMI

checker_declaration <-
CHECKER_K identifier (LPAREN checker_port_list? RPAREN)? SEMI checker_or_generate_item* ENDCHECKER_K 
  (COLON identifier)?

class_declaration <-
VIRTUAL_K? CLASS_K lifetime? identifier parameter_port_list?  
  (EXTENDS_K selected_ident (LPAREN list_of_arguments RPAREN)? )? SEMI
  class_item*
  ENDCLASS_K (COLON identifier)?

package_declaration <-
attribute_instance* PACKAGE_K lifetime? identifier SEMI
  timeunits_declaration? (attribute_instance* package_item)*
  ENDPACKAGE_K (COLON identifier)?

timeunits_declaration <-
TIMEUNIT_K TIME_LITERAL SEMI TIMEPRECISION_K TIME_LITERAL SEMI
/ TIMEUNIT_K TIME_LITERAL (DIV TIME_LITERAL)? SEMI
/ TIMEPRECISION_K TIME_LITERAL SEMI TIMEUNIT_K TIME_LITERAL SEMI
/ TIMEPRECISION_K TIME_LITERAL SEMI

parameter_port_list <-
POUND LPAREN list_of_param_assignments (COMMA parameter_port_declaration)* RPAREN
/ POUND LPAREN parameter_port_declaration (COMMA parameter_port_declaration)* RPAREN
/ POUND LPAREN RPAREN

parameter_port_declaration <-
local_parameter_declaration
/ TYPE_K list_of_type_assignments
/ parameter_declaration
/ data_type list_of_param_assignments

list_of_port_declarations <-
LPAREN ( attribute_instance* ansi_port_declaration (COMMA attribute_instance* ansi_port_declaration)* )? RPAREN

port_declaration <-
attribute_instance* interface_port_declaration
/ attribute_instance* inout_declaration
/ attribute_instance* input_declaration
/ attribute_instance* output_declaration
/ attribute_instance* ref_declaration

port <-
DOT identifier LPAREN port_expression? RPAREN
/ port_expression?

port_expression <-
LCURLY port_reference (COMMA port_reference)* RCURLY
/ port_reference

port_reference <- selected_ident

port_direction <- INPUT_K / OUTPUT_K / INOUT_K / REF_K

net_port_header <- port_direction? net_port_type

variable_port_header <- port_direction? variable_port_type

interface_port_header <-
INTERFACE_K (DOT identifier)?
/ identifier (DOT identifier)?

ansi_port_declaration <-
//since we dont track types, first(net_port_header)==ident which also matches
//port_identifier.  Eeek, lots of ambiguities
//TODO: fix all these ambiguities
  port_direction? DOT identifier LPAREN expression? RPAREN
/ port_direction? !net_type identifier !DOT unpacked_dimension* ( EQ expression )?
//since port_header expands to port_type which is a very complex prefix
//with tail of identifier: let it match the 1st identifier here
//so identifier? is here
/ (net_port_header / interface_port_header)? identifier? unpacked_dimension* ( EQ expression )?
/ variable_port_header? identifier? variable_dimension* (EQ expression )?

elaboration_system_task <-
// $fatal $error $warning $info
DS_FATAL_K (LPAREN UNSIGNED_NUMBER (COMMA list_of_arguments)? RPAREN)? SEMI
/ DS_ERROR_K (LPAREN list_of_arguments RPAREN)? SEMI
/ DS_WARNING_K (LPAREN list_of_arguments RPAREN)? SEMI
/ DS_INFO_K (LPAREN list_of_arguments RPAREN)? SEMI

module_common_item <-
initial_construct
/ always_construct
/ interface_instantiation
/ program_instantiation
/ assertion_item
/ bind_directive
/ continuous_assign
/ net_alias
/ final_construct
/ loop_generate_construct
/ conditional_generate_construct
/ elaboration_system_task
/ module_or_generate_item_declaration

module_item <-
port_declaration SEMI
/ non_port_module_item

module_or_generate_item <-
attribute_instance* module_instantiation
/ attribute_instance* gate_instantiation
/ attribute_instance* udp_instantiation
/ attribute_instance* module_common_item
/ attribute_instance* parameter_override

module_or_generate_item_declaration <-
package_or_generate_item_declaration
/ genvar_declaration
/ clocking_declaration
/ DEFAULT_K CLOCKING_K identifier SEMI
/ DEFAULT_K DISABLE_K IFF_K expression_or_dist SEMI

non_port_module_item <-
generate_region
/ module_or_generate_item
/ specify_block
/ attribute_instance* specparam_declaration
/ program_declaration
/ module_declaration
/ interface_declaration
/ timeunits_declaration

parameter_override <- DEFPARAM_K list_of_defparam_assignments SEMI

bind_directive <-
BIND_K bind_target_scope (COLON bind_target_instance_list)? bind_instantiation SEMI
/ BIND_K bind_target_instance bind_instantiation SEMI

bind_target_scope <-
identifier

bind_target_instance <-
selected_ident

bind_target_instance_list <-
bind_target_instance (COMMA bind_target_instance)*

bind_instantiation <-
program_instantiation
/ module_instantiation
/ interface_instantiation
/ checker_instantiation


//A.1.5 Configuration source text
config_declaration <-
CONFIG_K identifier SEMI (local_parameter_declaration SEMI)* design_statement config_rule_statement*
  ENDCONFIG_K (COLON identifier)?

design_statement <- DESIGN_K ((identifier DOT)? identifier)* SEMI

config_rule_statement <-
default_clause liblist_clause SEMI
/ inst_clause liblist_clause SEMI
/ inst_clause use_clause SEMI
/ cell_clause liblist_clause SEMI
/ cell_clause use_clause SEMI

default_clause <- DEFAULT_K

inst_clause <- INSTANCE_K inst_name

inst_name <- identifier (DOT identifier)*

cell_clause <- CELL_K (identifier DOT)? identifier

liblist_clause <- LIBLIST_K identifier*

use_clause <- 
  USE_K (identifier DOT)? identifier named_parameter_assignment (COMMA named_parameter_assignment)* (COLON CONFIG_K)?
/ USE_K named_parameter_assignment (COMMA named_parameter_assignment)* (COLON CONFIG_K)?
/ USE_K (identifier DOT)? identifier (COLON CONFIG_K)?


//A.1.6 Interface items
interface_or_generate_item <-
attribute_instance* module_common_item
/ attribute_instance* modport_declaration
/ attribute_instance* extern_tf_declaration

//NOT USED: extern <-
//NOT USED: EXTERN_K method_prototype SEMI
//NOT USED: / EXTERN_K FORKJOIN_K task_prototype SEMI

interface_item <-
port_declaration SEMI
/ non_port_interface_item

non_port_interface_item <-
generate_region
/ interface_or_generate_item
/ program_declaration
/ interface_declaration
/ timeunits_declaration

//A.1.7 Program items
program_item <-
port_declaration SEMI
/ non_port_program_item

non_port_program_item <-
attribute_instance* continuous_assign
/ attribute_instance* module_or_generate_item_declaration
/ attribute_instance* initial_construct
/ attribute_instance* final_construct
/ attribute_instance* concurrent_assertion_item
/ attribute_instance* timeunits_declaration
/ program_generate_item

program_generate_item <-
loop_generate_construct
/ conditional_generate_construct
/ generate_region
/ elaboration_system_task

//A.1.8 Checker items
checker_port_list <- checker_port_item (COMMA checker_port_item)*

checker_port_item <-
attribute_instance* property_formal_type identifier variable_dimension* (EQ property_actual_arg)?

checker_or_generate_item <-
checker_or_generate_item_declaration
/ initial_construct
/ checker_always_construct
/ final_construct
/ assertion_item
/ checker_generate_item

checker_or_generate_item_declaration <-
RAND_K? data_declaration
/ function_declaration
/ assertion_item_declaration
/ covergroup_declaration
/ overload_declaration
/ genvar_declaration
/ clocking_declaration
/ DEFAULT_K CLOCKING_K identifier SEMI
/ DEFAULT_K DISABLE_K IFF_K expression_or_dist SEMI
/ SEMI

checker_generate_item <-
loop_generate_construct
/ conditional_generate_construct
/ generate_region
/ elaboration_system_task

checker_always_construct <- ALWAYS_K statement

//A.1.9 Class items
class_item <-
  local_parameter_declaration SEMI
/ parameter_declaration SEMI
/ SEMI
/ attribute_instance* class_property
/ attribute_instance* class_method
/ attribute_instance* class_constraint
/ attribute_instance* class_declaration
/ attribute_instance* covergroup_declaration

class_property <-
CONST_K class_item_qualifier* data_type identifier (EQ expression)? SEMI
/ property_qualifier* data_declaration

class_method <-
method_qualifier* task_declaration
/ method_qualifier* function_declaration
/ method_qualifier* class_constructor_declaration
/ EXTERN_K? method_qualifier* class_constructor_prototype
/ EXTERN_K? method_qualifier* method_prototype SEMI

class_constructor_prototype <-
FUNCTION_K NEW_K LPAREN tf_port_list? RPAREN SEMI

class_constraint <-
constraint_prototype
/ constraint_declaration

class_item_qualifier <-
STATIC_K
/ PROTECTED_K
/ LOCAL_K

property_qualifier <-
random_qualifier
/ class_item_qualifier

random_qualifier <-
RAND_K
/ RANDC_K

method_qualifier <-
PURE_K? VIRTUAL_K
/ class_item_qualifier

method_prototype <-
task_prototype
/ function_prototype

new_class_scope <- (!NEW_K identifier COLON2)*

class_constructor_declaration <-
FUNCTION_K new_class_scope NEW_K (LPAREN tf_port_list? RPAREN)? SEMI
  block_item_declaration*
  (SUPER_K DOT NEW_K (LPAREN list_of_arguments RPAREN)? SEMI )?
  function_statement_or_null*
  ENDFUNCTION_K (COLON NEW_K)?

//A.1.10 Constraints
constraint_declaration <- STATIC_K? CONSTRAINT_K identifier constraint_block

constraint_block <- LCURLY constraint_block_item* RCURLY

constraint_block_item <-
SOLVE_K solve_before_list BEFORE_K solve_before_list SEMI
/ constraint_expression

solve_before_list <- solve_before_primary (COMMA solve_before_primary)*

solve_before_primary <- selected_ident

constraint_expression <-
expression_or_dist SEMI
/ expression MINUS_GT constraint_set
/ IF_K LPAREN expression RPAREN constraint_set (ELSE_K constraint_set)?
/ FOREACH_K LPAREN selected_ident LBRACK loop_variables RBRACK RPAREN constraint_set

constraint_set <-
constraint_expression
/ LCURLY constraint_expression* RCURLY

dist_list <- dist_item (COMMA dist_item)*

dist_item <- value_range dist_weight?

dist_weight <-
COLON_EQ expression
/ COLON_DIV expression

constraint_prototype <- constraint_prototype_qualifier? STATIC_K? CONSTRAINT_K identifier SEMI

constraint_prototype_qualifier <- EXTERN_K / PURE_K

extern_constraint_declaration <-
STATIC_K? CONSTRAINT_K selected_ident identifier constraint_block

identifier_list <- identifier (COMMA identifier)*

//A.1.11 Package items
package_item <-
package_or_generate_item_declaration
/ anonymous_program
/ package_export_declaration
/ timeunits_declaration

package_or_generate_item_declaration <-
  task_declaration
/ function_declaration
/ checker_declaration
/ dpi_import_export
/ extern_constraint_declaration
/ class_declaration
/ local_parameter_declaration SEMI
/ parameter_declaration SEMI
/ covergroup_declaration
/ overload_declaration
/ assertion_item_declaration
/ class_constructor_declaration
/ net_declaration
/ data_declaration
/ SEMI

anonymous_program <- PROGRAM_K SEMI anonymous_program_item* ENDPROGRAM_K

anonymous_program_item <-
task_declaration
/ function_declaration
/ class_declaration
/ covergroup_declaration
/ class_constructor_declaration
/ SEMI

//A.2 Declarations
//A.2.1 Declaration types
//A.2.1.1 Module parameter declarations
local_parameter_declaration <-
  LOCALPARAM_K !TYPE_K data_type_or_implicit list_of_param_assignments
/ LOCALPARAM_K !TYPE_K list_of_param_assignments
/ LOCALPARAM_K TYPE_K list_of_type_assignments

parameter_declaration <-
  PARAMETER_K !TYPE_K data_type_or_implicit list_of_param_assignments
/ PARAMETER_K !TYPE_K list_of_param_assignments
/ PARAMETER_K TYPE_K list_of_type_assignments

specparam_declaration <-
SPECPARAM_K packed_dimension? list_of_specparam_assignments SEMI

//A.2.1.2 Port declarations
inout_declaration <-
  INOUT_K list_of_port_identifiers
/ INOUT_K net_type list_of_port_identifiers
/ INOUT_K net_port_type list_of_port_identifiers

input_declaration <-
  INPUT_K list_of_port_identifiers
/ INPUT_K net_type list_of_port_identifiers
/ INPUT_K net_port_type list_of_port_identifiers
/ INPUT_K variable_port_type list_of_variable_identifiers

output_declaration <-
  OUTPUT_K list_of_port_identifiers
/ OUTPUT_K net_type list_of_port_identifiers
/ OUTPUT_K net_port_type list_of_port_identifiers
/ OUTPUT_K variable_port_type list_of_variable_port_identifiers

interface_port_declaration <-
  identifier DOT identifier list_of_interface_identifiers
/ identifier list_of_interface_identifiers

ref_declaration <- REF_K variable_port_type list_of_port_identifiers

//A.2.1.3 Type declarations
data_declaration <-
CONST_K? VAR_K? lifetime? data_type_or_implicit list_of_variable_decl_assignments SEMI
/ type_declaration
/ package_import_declaration
/ virtual_interface_declaration

package_import_declaration <-
IMPORT_K package_import_item (COMMA package_import_item)* SEMI

package_import_item <-
identifier COLON2 identifier
/ identifier COLON2 STAR

package_export_declaration <-
EXPORT_K STAR_COLON2_STAR SEMI
/ EXPORT_K package_import_item (COMMA package_import_item)* SEMI

genvar_declaration <- GENVAR_K list_of_genvar_identifiers SEMI

net_declaration <-
net_type (drive_strength / charge_strength)? (VECTORED_K / SCALARED_K)?  
  // Since 'ident' can be first(data_type_or_implicit) or
  // first(list_of_net_decl_assignments), we need to disambiguate.
  //ORIG: data_type_or_implicit delay3? list_of_net_decl_assignments 
  ( list_of_net_decl_assignments
  / data_type_or_implicit delay3? list_of_net_decl_assignments
  )
  SEMI

type_declaration <-
  TYPEDEF_K (ENUM_K / STRUCT_K / UNION_K / CLASS_K)? selected_ident SEMI
/ TYPEDEF_K data_type identifier variable_dimension* SEMI

lifetime <- STATIC_K / AUTOMATIC_K

//A.2.2 Declaration data types
//A.2.2.1 Net and variable types
//casting_type <- simple_type / primary / signing / STRING_K / CONST_K

data_type <-
  integer_vector_type signing? packed_dimension*
/ integer_atom_type signing?
/ non_integer_type
/ struct_union (PACKED_K signing?)? LCURLY struct_union_member struct_union_member* RCURLY packed_dimension*
/ ENUM_K enum_base_type? LCURLY enum_name_declaration (COMMA enum_name_declaration)* RCURLY packed_dimension*
/ STRING_K
/ CHANDLE_K
/ VIRTUAL_K INTERFACE_K? identifier (DOT identifier)?
/ EVENT_K
/ type_reference
/ selected_ident packed_dimension*
/ ps_covergroup_identifier

/*
 *  NOTE: Since data_type 1st set has ident which could also match
 *  follow-set, get ambiguity: since we dont do semantic predicate
 *  (i.e., scope/type of ident --- which could be type).
 *  Perhaps add predicate here where it only matches 1st set ident
 *  if more follows.
 *  data_type <- &(ident ...) 
 */
data_type_or_implicit <-
data_type
/ implicit_data_type

implicit_data_type <- signing? packed_dimension*

enum_base_type <-
integer_atom_type signing?
/ integer_vector_type signing? packed_dimension?
/ identifier packed_dimension?

enum_name_declaration <- identifier (LBRACK number (COLON number)? RBRACK)? (EQ expression)?


integer_type <- integer_vector_type / integer_atom_type

integer_atom_type <- BYTE_K / SHORTINT_K / INT_K / LONGINT_K / INTEGER_K / TIME_K

integer_vector_type <- BIT_K / LOGIC_K / REG_K

non_integer_type <- SHORTREAL_K / REAL_K / REALTIME_K

net_type <- SUPPLY0_K / SUPPLY1_K / TRI_K / TRIAND_K / TRIOR_K / TRIREG_K/ TRI0_K / TRI1_K / UWIRE_K/ WIRE_K / WAND_K / WOR_K

net_port_type <- net_type? data_type_or_implicit

variable_port_type <- var_data_type

var_data_type <- 
  VAR_K data_type_or_implicit
/ data_type 

signing <- SIGNED_K / UNSIGNED_K

simple_type <- integer_type / non_integer_type / ps_type_identifier / ps_parameter_identifier

struct_union_member <- attribute_instance* random_qualifier? data_type_or_void list_of_variable_decl_assignments SEMI

data_type_or_void <- data_type / VOID_K

struct_union <- STRUCT_K / UNION_K TAGGED_K?

type_reference <-
TYPE_K LPAREN expression RPAREN
/ TYPE_K LPAREN data_type RPAREN

//A.2.2.2 Strengths
drive_strength <-
LPAREN strength0 COMMA strength1 RPAREN
/ LPAREN strength1 COMMA strength0 RPAREN
/ LPAREN strength0 COMMA HIGHZ1_K RPAREN
/ LPAREN strength1 COMMA HIGHZ0_K RPAREN
/ LPAREN HIGHZ0_K COMMA strength1 RPAREN
/ LPAREN HIGHZ1_K COMMA strength0 RPAREN

strength0 <- SUPPLY0_K / STRONG0_K / PULL0_K / WEAK0_K

strength1 <- SUPPLY1_K / STRONG1_K / PULL1_K / WEAK1_K

charge_strength <- LPAREN SMALL_K RPAREN / LPAREN MEDIUM_K RPAREN / LPAREN LARGE_K RPAREN

//A.2.2.3 Delays
delay3 <- 
  POUND LPAREN mintypmax_expression (COMMA mintypmax_expression (COMMA mintypmax_expression)? )? RPAREN
/ POUND delay_value 

delay2 <- 
  POUND LPAREN mintypmax_expression (COMMA mintypmax_expression)? RPAREN
/ POUND delay_value 

delay_value <-
  W1STEP_K //1step
/ number
/ ps_identifier
/ TIME_LITERAL

//A.2.3 Declaration lists
list_of_defparam_assignments <- defparam_assignment (COMMA defparam_assignment)*

list_of_genvar_identifiers <- identifier (COMMA identifier)*

list_of_interface_identifiers <- identifier param_assignment* (COMMA identifier param_assignment*)*
list_of_port_identifiers      <- identifier param_assignment* (COMMA identifier param_assignment*)*

list_of_net_decl_assignments <- net_decl_assignment (COMMA net_decl_assignment)*

list_of_param_assignments <- param_assignment (COMMA param_assignment)*

list_of_udp_port_identifiers <- identifier (COMMA identifier)*

list_of_specparam_assignments <- specparam_assignment (COMMA specparam_assignment)*

list_of_tf_variable_identifiers <- 
//since data_type is greedy and matches this identifier too; we;ll make optional here.
identifier? variable_dimension* (EQ expression)?  (COMMA identifier variable_dimension* (EQ expression)?)*

list_of_type_assignments <- type_assignment (COMMA type_assignment)*

list_of_variable_decl_assignments <- variable_decl_assignment (COMMA variable_decl_assignment)*

list_of_variable_identifiers <- identifier variable_dimension* (COMMA identifier variable_dimension*)*

list_of_variable_port_identifiers <- 
identifier variable_dimension* (EQ expression)?  (COMMA identifier variable_dimension* (EQ expression)?)*

list_of_virtual_interface_decl <-
identifier (EQ identifier)?  (COMMA identifier (EQ identifier)?)*

//A.2.4 Declaration assignments
defparam_assignment <- selected_ident EQ mintypmax_expression

net_decl_assignment <- identifier unpacked_dimension* (EQ expression)?

param_assignment <- identifier unpacked_dimension* (EQ param_expression)?

specparam_assignment <-
identifier EQ mintypmax_expression
/ pulse_control_specparam

type_assignment <-
identifier (EQ data_type)?

pulse_control_specparam <-
//PATHPULSE$
PATHPULSE_K EQ LPAREN reject_limit_value (COMMA error_limit_value)? RPAREN
//TODO<- what the heck is this? / PATHPULSE$specify_input_terminal_descriptor$specify_output_terminal_descriptor
//= ( reject_limit_value (COMMA error_limit_value)? )

error_limit_value <- limit_value

reject_limit_value <- limit_value

limit_value <- mintypmax_expression

variable_decl_assignment <-
  identifier unsized_dimension variable_dimension?  (EQ dynamic_array_new)?
/ identifier variable_dimension? (EQ expression)?
/ identifier (EQ class_new)?

class_new <- NEW_K (LPAREN list_of_arguments RPAREN / expression)?

dynamic_array_new <- NEW_K expression? ( LPAREN expression RPAREN )?

//A.2.5 Declaration ranges
unpacked_dimension <-
LBRACK range RBRACK
/ LBRACK expression RBRACK

packed_dimension <-
LBRACK range RBRACK
/ unsized_dimension

associative_dimension <-
LBRACK data_type RBRACK
/ LBRACK STAR RBRACK

variable_dimension <-
unsized_dimension
/ unpacked_dimension
/ associative_dimension
/ queue_dimension

queue_dimension <- LBRACK DOLLAR ( COLON expression )? RBRACK

unsized_dimension <- LBRACK RBRACK

//A.2.6 Function declarations
function_data_type_or_implicit <-
data_type_or_void
/ implicit_data_type

function_declaration <- FUNCTION_K ( lifetime )? function_body_declaration

function_body_declaration <-
  function_data_type_or_implicit
  selected_ident LPAREN ( tf_port_list )? RPAREN SEMI
  ( block_item_declaration )*
  ( function_statement_or_null )*
  ENDFUNCTION_K ( COLON identifier )?
/ function_data_type_or_implicit
  selected_ident SEMI
  ( tf_item_declaration )*
  ( function_statement_or_null )*
  ENDFUNCTION_K ( COLON identifier )?

function_prototype <- FUNCTION_K data_type_or_void identifier LPAREN ( tf_port_list )? RPAREN

dpi_import_export <-
  IMPORT_K dpi_spec_string ( dpi_function_import_property )? ( c_identifier EQ )? dpi_function_proto SEMI
/ IMPORT_K dpi_spec_string ( dpi_task_import_property )? ( c_identifier EQ )? dpi_task_proto SEMI
/ EXPORT_K dpi_spec_string ( c_identifier EQ )? FUNCTION_K identifier SEMI
/ EXPORT_K dpi_spec_string ( c_identifier EQ )? TASK_K identifier SEMI

dpi_spec_string <- STRING_LITERAL

dpi_function_import_property <- CONTEXT_K / PURE_K

dpi_task_import_property <- CONTEXT_K

dpi_function_proto <- function_prototype

dpi_task_proto <- task_prototype

//A.2.7 Task declarations
task_declaration <- TASK_K ( lifetime )? task_body_declaration

task_body_declaration <-
  selected_ident LPAREN ( tf_port_list )? RPAREN SEMI
    ( block_item_declaration )*
    ( statement_or_null )*
    ENDTASK_K ( COLON identifier )?
/ selected_ident SEMI
    ( tf_item_declaration )*
    ( statement_or_null )*
    ENDTASK_K ( COLON identifier )?

tf_item_declaration <-
block_item_declaration
/ tf_port_declaration

tf_port_list <- tf_port_item ( COMMA tf_port_item )*

tf_port_item <- 
( attribute_instance )* ( tf_port_direction )? ( VAR_K )? data_type_or_implicit 
//since data_type is greedy and matches this identifier too; we;ll make optional here.
  ( identifier? ( variable_dimension )* ( EQ expression )? )?

tf_port_direction <- port_direction / CONST_K REF_K

tf_port_declaration <- 
  ( attribute_instance )* tf_port_direction ( VAR_K )? 
//since data_type is greedy and matches this identifier too; we;ll make optional here.
  data_type_or_implicit list_of_tf_variable_identifiers SEMI

task_prototype <- TASK_K identifier LPAREN ( tf_port_list )? RPAREN

//A.2.8 Block item declarations
block_item_declaration <-
  ( attribute_instance )* local_parameter_declaration SEMI
/ ( attribute_instance )* let_declaration
/ ( attribute_instance )* parameter_declaration SEMI
/ ( attribute_instance )* overload_declaration
/ ( attribute_instance )* data_declaration

overload_declaration <-
BIND_K overload_operator FUNCTION_K data_type identifier LPAREN overload_proto_formals RPAREN SEMI

overload_operator <- PLUS / PLUS2 / MINUS / MINUS2 / STAR / STAR2 / DIV / MOD / EQ2 / NOT_EQ / LT / LT_EQ / GT / GT_EQ / EQ

overload_proto_formals <- data_type (COMMA data_type)*

//A.2.9 Interface declarations
virtual_interface_declaration <-
VIRTUAL_K ( INTERFACE_K )? identifier ( parameter_value_assignment)? (DOT identifier)?
  list_of_virtual_interface_decl SEMI

modport_declaration <- MODPORT_K modport_item ( COMMA modport_item )* SEMI

modport_item <- identifier LPAREN modport_ports_declaration ( COMMA modport_ports_declaration )* RPAREN

modport_ports_declaration <-
( attribute_instance )* modport_simple_ports_declaration
/ ( attribute_instance )* modport_tf_ports_declaration
/ ( attribute_instance )* modport_clocking_declaration

modport_clocking_declaration <- CLOCKING_K identifier

modport_simple_ports_declaration <-
port_direction modport_simple_port ( COMMA modport_simple_port )*

modport_simple_port <-
  DOT identifier LPAREN ( expression )? RPAREN
/ identifier

modport_tf_ports_declaration <- import_export modport_tf_port ( COMMA modport_tf_port )*

modport_tf_port <-
method_prototype
/ identifier

import_export <- IMPORT_K / EXPORT_K

//A.2.10 Assertion declarations
concurrent_assertion_item <-
( identifier COLON )? concurrent_assertion_statement
/ checker_instantiation

concurrent_assertion_statement <-
assert_property_statement
/ assume_property_statement
/ cover_property_statement
/ cover_sequence_statement
/ restrict_property_statement

assert_property_statement<- ASSERT_K PROPERTY_K LPAREN property_spec RPAREN action_block

assume_property_statement<- ASSUME_K PROPERTY_K LPAREN property_spec RPAREN action_block

cover_property_statement<- COVER_K PROPERTY_K LPAREN property_spec RPAREN statement_or_null

expect_property_statement <- EXPECT_K LPAREN property_spec RPAREN action_block

cover_sequence_statement<-
COVER_K SEQUENCE_K LPAREN (clocking_event )? ( DISABLE_K IFF_K LPAREN expression_or_dist RPAREN )?
  sequence_expr RPAREN statement_or_null

restrict_property_statement<- RESTRICT_K PROPERTY_K LPAREN property_spec RPAREN SEMI

property_instance <- selected_ident ( LPAREN ( property_list_of_arguments )? RPAREN )?

property_list_of_arguments <-
  DOT identifier LPAREN (property_actual_arg)? RPAREN ( COMMA DOT identifier LPAREN (property_actual_arg)? RPAREN )*
/ (property_actual_arg)? ( COMMA (property_actual_arg)? )* ( COMMA DOT identifier LPAREN (property_actual_arg)? RPAREN )*

property_actual_arg <-
property_expr
/ sequence_actual_arg

assertion_item_declaration <-
property_declaration
/ sequence_declaration
/ let_declaration

property_declaration <-
PROPERTY_K identifier ( LPAREN ( property_port_list )? RPAREN )? SEMI
  ( assertion_variable_declaration )*
  property_statement_spec
  ENDPROPERTY_K ( COLON identifier )?

property_port_list <- property_port_item (COMMA property_port_item)*

property_port_item <-
( attribute_instance )* ( LOCAL_K ( property_lvar_port_direction )? )? property_formal_type
  identifier (variable_dimension)* ( EQ property_actual_arg )?

property_lvar_port_direction <- INPUT_K

property_formal_type <-
sequence_formal_type
/ PROPERTY_K

property_spec <- (clocking_event )? ( DISABLE_K IFF_K LPAREN expression_or_dist RPAREN )? property_expr

property_statement_spec <- ( clocking_event )? ( DISABLE_K IFF_K LPAREN expression_or_dist RPAREN )? property_statement

property_statement <-
  CASE_K LPAREN expression_or_dist RPAREN property_case_item ( property_case_item )* ENDCASE_K
/ IF_K LPAREN expression_or_dist RPAREN property_expr ( ELSE_K property_expr )?
/ property_expr SEMI

property_case_item<-
  DEFAULT_K ( COLON )? property_statement
/ expression_or_dist ( COMMA expression_or_dist )* COLON property_statement

property_expr <-
property_expr OR_K property_expr
/ property_expr UNTIL_K property_expr
/ property_expr S_UNTIL_K property_expr
/ property_expr UNTIL_WITH_K property_expr
/ property_expr S_UNTIL_WITH_K property_expr
/ property_expr IMPLIES_K property_expr
/ property_expr IFF_K property_expr
/ property_expr AND_K property_expr
//NOTE: causes left recursion.  Not clear where this is need.  / property_statement
/ sequence_expr BAR_MINUS_GT property_expr
/ sequence_expr BAR_EQ_GT property_expr
/ sequence_expr POUND_MINUS_POUND property_expr
/ sequence_expr POUND_EQ_POUND property_expr
/ sequence_expr
/ STRONG_K LPAREN sequence_expr RPAREN
/ WEAK_K LPAREN sequence_expr RPAREN
/ LPAREN property_expr RPAREN
/ NOT_K property_expr
/ NEXTTIME_K property_expr
/ NEXTTIME_K ( expression )? property_expr
/ S_NEXTTIME_K property_expr
/ S_NEXTTIME_K ( expression )? property_expr
/ ALWAYS_K property_expr
/ ALWAYS_K ( cycle_delay_const_range_expression )? property_expr
/ S_ALWAYS_K ( range)? property_expr
/ S_EVENTUALLY_K property_expr
/ EVENTUALLY_K ( range )? property_expr
/ S_EVENTUALLY_K ( cycle_delay_const_range_expression )? property_expr
/ ACCEPT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ REJECT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ SYNC_ACCEPT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ SYNC_REJECT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ property_instance
/ clocking_event property_expr

sequence_declaration <-
SEQUENCE_K identifier ( LPAREN ( sequence_port_list )? RPAREN )? SEMI
  ( assertion_variable_declaration )*
  sequence_expr SEMI
  ENDSEQUENCE_K ( COLON identifier )?

sequence_port_list <- sequence_port_item (COMMA sequence_port_item)*

sequence_port_item <-
( attribute_instance )* ( LOCAL_K ( sequence_lvar_port_direction )? )? sequence_formal_type
  identifier (variable_dimension)* ( EQ sequence_actual_arg )?

sequence_lvar_port_direction <- INPUT_K / INOUT_K / OUTPUT_K

sequence_formal_type <-
  SEQUENCE_K
/ EVENT_K
/ UNTYPED_K
/ data_type_or_implicit

sequence_expr <-
//NOTE: covered by right recursion: 
//sequence_expr cycle_delay_range sequence_expr ( cycle_delay_range sequence_expr )*
sequence_expr cycle_delay_range sequence_expr
/ sequence_expr AND_K sequence_expr
/ sequence_expr INTERSECT_K sequence_expr
/ sequence_expr OR_K sequence_expr
/ sequence_expr WITHIN_K sequence_expr
/ cycle_delay_range sequence_expr ( cycle_delay_range sequence_expr )*
/ expression_or_dist ( boolean_abbrev )?
/ sequence_instance ( sequence_abbrev )?
/ LPAREN sequence_expr (COMMA sequence_match_item )* RPAREN ( sequence_abbrev )?
/ FIRST_MATCH_K LPAREN sequence_expr (COMMA sequence_match_item)* RPAREN
/ expression_or_dist THROUGHOUT_K sequence_expr
/ clocking_event sequence_expr

cycle_delay_range <-
  POUND2 LBRACK cycle_delay_const_range_expression RBRACK
/ POUND2 LBRACK STAR RBRACK
/ POUND2 LBRACK PLUS RBRACK
/ POUND2 primary

sequence_method_call <- sequence_instance DOT identifier

sequence_match_item <-
operator_assignment
/ inc_or_dec_expression
/ subroutine_call

sequence_instance <- selected_ident ( LPAREN ( sequence_list_of_arguments )? RPAREN )?

sequence_list_of_arguments <-
  DOT identifier LPAREN (sequence_actual_arg)? RPAREN ( COMMA DOT identifier LPAREN (sequence_actual_arg)? RPAREN )*
/ (sequence_actual_arg)? ( COMMA (sequence_actual_arg)? )* ( COMMA DOT identifier LPAREN (sequence_actual_arg)? RPAREN )*

sequence_actual_arg <-
event_expression
/ sequence_expr

boolean_abbrev <-
consecutive_repetition
/ non_consecutive_repetition
/ goto_repetition

sequence_abbrev <- consecutive_repetition

consecutive_repetition <-
LBRACK STAR const_or_range_expression RBRACK
/ LBRACK STAR RBRACK
/ LBRACK PLUS RBRACK

non_consecutive_repetition <- LBRACK EQ const_or_range_expression RBRACK

goto_repetition <- LBRACK MINUS_GT const_or_range_expression RBRACK

const_or_range_expression <-
  expression
/ cycle_delay_const_range_expression

cycle_delay_const_range_expression <-
  expression COLON expression
/ expression COLON DOLLAR

expression_or_dist <- expression ( DIST_K LCURLY dist_list RCURLY )?

assertion_variable_declaration <- var_data_type list_of_variable_decl_assignments SEMI

let_declaration <- LET_K selected_ident ( LPAREN ( let_port_list )? RPAREN )? EQ expression SEMI

let_port_list <- let_port_item (COMMA let_port_item)*

let_port_item <- ( attribute_instance )* let_formal_type identifier ( variable_dimension )* ( EQ expression )?

let_formal_type <- data_type_or_implicit

let_expression <- selected_ident ( LPAREN ( let_list_of_arguments )? RPAREN )?

let_list_of_arguments <-
  DOT identifier LPAREN ( let_actual_arg )? RPAREN ( COMMA DOT identifier LPAREN ( let_actual_arg )? RPAREN )*
/ ( let_actual_arg )? (COMMA ( let_actual_arg )? )* (COMMA DOT identifier LPAREN ( let_actual_arg )? RPAREN )*

let_actual_arg <- expression

//A.2.11 Covergroup declarations
covergroup_declaration <-
COVERGROUP_K identifier ( LPAREN ( tf_port_list )? RPAREN )? ( coverage_event )? SEMI
  ( coverage_spec_or_option )*
  ENDGROUP_K ( COLON identifier )?

coverage_spec_or_option <-
  (attribute_instance)* coverage_option SEMI
/ (attribute_instance)* coverage_spec

coverage_option <-
//option
IDENT DOT identifier EQ expression
//option_type
/ IDENT DOT identifier EQ expression

coverage_spec <-
cover_point
/ cover_cross

coverage_event <-
  WITH_K FUNCTION_K IDENT LPAREN ( tf_port_list )? RPAREN
/ AT2 LPAREN block_event_expression RPAREN
/ clocking_event  //IDENT ==> sample (but not a keyword)

block_event_expression <-
  block_event_expression OR_K block_event_expression
/ BEGIN_K selected_ident
/ END_K selected_ident

cover_point <- ( identifier COLON )? COVERPOINT_K expression ( IFF_K LPAREN expression RPAREN )? bins_or_empty

bins_or_empty <-
LCURLY (attribute_instance)* ( bins_or_options SEMI )* RCURLY
/ SEMI

bins_or_options <-
coverage_option
/ bins_keyword identifier EQ DEFAULT_K SEQUENCE_K ( IFF_K LPAREN expression RPAREN )?
/ ( WILDCARD_K )? bins_keyword identifier ( LBRACK ( expression )? RBRACK )? EQ 
  LCURLY open_range_list RCURLY ( IFF_K LPAREN expression RPAREN )?
/ ( WILDCARD_K )? bins_keyword identifier ( RBRACK RBRACK )? EQ trans_list ( IFF_K LPAREN expression RPAREN )?
/ bins_keyword identifier ( LBRACK ( expression )? RBRACK )? EQ DEFAULT_K ( IFF_K LPAREN expression RPAREN )?

bins_keyword<- BINS_K / ILLEGAL_BINS_K / IGNORE_BINS_K

range_list <- value_range ( COMMA value_range )*

trans_list <- LPAREN trans_set RPAREN ( COMMA LPAREN trans_set RPAREN )*

trans_set <- trans_range_list ( EQ_GT trans_range_list )*

trans_range_list <-
  trans_item LBRACK STAR repeat_range RBRACK
/ trans_item LBRACK MINUS_GT repeat_range RBRACK
/ trans_item LBRACK EQ repeat_range RBRACK
/ trans_item

trans_item <- range_list

repeat_range <-
  expression COLON expression
/ expression

cover_cross <- ( identifier COLON )? CROSS_K list_of_coverpoints ( IFF_K LPAREN expression RPAREN )? select_bins_or_empty

list_of_coverpoints <- cross_item COMMA cross_item ( COMMA cross_item )*

cross_item <-
identifier

select_bins_or_empty <-
LCURLY ( bins_selection_or_option SEMI )* RCURLY
/ SEMI

bins_selection_or_option <-
( attribute_instance )* coverage_option
/ ( attribute_instance )* bins_selection

bins_selection <- bins_keyword identifier EQ select_expression ( IFF_K LPAREN expression RPAREN )?

select_expression <-
select_expression AND2 select_expression
/ select_expression OR2 select_expression
/ select_condition
/ NOT select_condition
/ LPAREN select_expression RPAREN

select_condition <- BINSOF_K LPAREN bins_expression RPAREN ( INTERSECT_K LCURLY open_range_list RCURLY )?

bins_expression <-
  identifier ( DOT identifier )?
/ identifier

open_range_list <- open_value_range ( COMMA open_value_range )*

open_value_range <- value_range

//A.3 Primitive instances
//A.3.1 Primitive instantiation and instances

//Greatly simplified this rather archaic/arcane detail
gate_instantiation <-
  ( cmos_switchtype / enable_gatetype / mos_switchtype / n_input_gatetype 
  /   n_output_gatetype / pass_en_switchtype / pass_switchtype
  / PULLDOWN_K / PULLUP_K
  )
  (drive_strength)? (delay3)?
  gate_instance (COMMA gate_instance)* SEMI

gate_instance <-
  ( name_of_instance )? LPAREN gate_terminal ( COMMA gate_terminal )* RPAREN

gate_terminal <-
  expression
/ net_lvalue

//A.3.2 Primitive strengths

//A.3.3 Primitive terminals
input_terminal <- expression

output_terminal <- net_lvalue

//A.3.4 Primitive gate and switch types
cmos_switchtype <- CMOS_K / RCMOS_K

enable_gatetype <- BUFIF0_K / BUFIF1_K / NOTIF0_K / NOTIF1_K

mos_switchtype <- NMOS_K / PMOS_K / RNMOS_K / RPMOS_K

n_input_gatetype <- AND_K / NAND_K / OR_K / NOR_K / XOR_K / XNOR_K

n_output_gatetype <- BUF_K / NOT_K

pass_en_switchtype <- TRANIF0_K / TRANIF1_K / RTRANIF1_K / RTRANIF0_K

pass_switchtype <- TRAN_K / RTRAN_K

//A.4 Instantiations
//A.4.1 Instantiation
//A.4.1.1 Module instantiation
module_instantiation <-
identifier ( parameter_value_assignment )? hierarchical_instance ( COMMA hierarchical_instance )* SEMI

parameter_value_assignment <- POUND LPAREN ( list_of_parameter_assignments )? RPAREN

list_of_parameter_assignments <-
  named_parameter_assignment ( COMMA named_parameter_assignment )*
/ ordered_parameter_assignment ( COMMA ordered_parameter_assignment )*

ordered_parameter_assignment <- param_expression

named_parameter_assignment <- DOT identifier LPAREN ( param_expression )? RPAREN

hierarchical_instance <- name_of_instance LPAREN ( list_of_port_connections )? RPAREN

name_of_instance <- identifier ( unpacked_dimension )*

list_of_port_connections <-
  named_port_connection ( COMMA named_port_connection )*
/ ordered_port_connection ( COMMA ordered_port_connection )*

ordered_port_connection <- ( attribute_instance )* ( expression )?

named_port_connection <-
( attribute_instance )* DOT identifier ( LPAREN ( expression )? RPAREN )?
/ ( attribute_instance )* DOT_STAR

//A.4.1.2 Interface instantiation
interface_instantiation <-
identifier ( parameter_value_assignment )? hierarchical_instance ( COMMA hierarchical_instance )* SEMI

//A.4.1.3 Program instantiation
program_instantiation <-
identifier ( parameter_value_assignment )? hierarchical_instance ( COMMA hierarchical_instance )* SEMI

//A.4.1.4 Checker instantiation
checker_instantiation <-
identifier name_of_instance LPAREN (list_of_checker_port_connections)? RPAREN SEMI

list_of_checker_port_connections <-
ordered_checker_port_connection ( COMMA ordered_checker_port_connection )*
/ named_checker_port_connection ( COMMA named_checker_port_connection )*

ordered_checker_port_connection <- ( attribute_instance )* ( property_actual_arg )?

named_checker_port_connection <-
( attribute_instance )* DOT identifier ( LPAREN ( property_actual_arg )? RPAREN )?
/ ( attribute_instance )* DOT_STAR

//A.4.2 Generated instantiation
generate_region <-
GENERATE_K ( generate_item )* ENDGENERATE_K

loop_generate_construct <-
FOR_K LPAREN genvar_initialization SEMI genvar_expression SEMI genvar_iteration RPAREN
generate_block

genvar_initialization <-
( GENVAR_K )? identifier EQ expression

genvar_iteration <-
identifier assignment_operator genvar_expression
/ inc_or_dec_operator identifier
/ identifier inc_or_dec_operator

conditional_generate_construct <-
if_generate_construct
/ case_generate_construct

if_generate_construct <-
IF_K LPAREN expression RPAREN generate_block ( ELSE_K generate_block )?

case_generate_construct <-
CASE_K LPAREN expression RPAREN case_generate_item ( case_generate_item )* ENDCASE_K

case_generate_item <-
  DEFAULT_K ( COLON )? generate_block
/ expression ( COMMA expression )* COLON generate_block

generate_block <-
  ( identifier COLON )? BEGIN_K ( COLON identifier )?
  ( generate_item )*
  END_K ( COLON identifier )?
/ generate_item

generate_item <-
module_or_generate_item
/ interface_or_generate_item
/ checker_or_generate_item

//A.5 UDP declaration and instantiation
//A.5.1 UDP declaration
udp_ansi_declaration <- ( attribute_instance )* PRIMITIVE_K identifier LPAREN udp_declaration_port_list RPAREN SEMI

udp_declaration <-
  udp_ansi_declaration udp_body ENDPRIMITIVE_K ( COLON identifier )?
/ EXTERN_K udp_ansi_declaration
/ ( attribute_instance )* PRIMITIVE_K identifier LPAREN DOT_STAR RPAREN SEMI
  ( udp_port_declaration )*
  udp_body
  ENDPRIMITIVE_K ( COLON identifier )?

//A.5.2 UDP ports
udp_port_list <- identifier COMMA identifier ( COMMA identifier )*

udp_declaration_port_list <- udp_output_declaration COMMA udp_input_declaration ( COMMA udp_input_declaration )*

udp_port_declaration <-
udp_output_declaration SEMI
/ udp_input_declaration SEMI
/ udp_reg_declaration SEMI

udp_output_declaration <-
  ( attribute_instance )* OUTPUT_K REG_K identifier ( EQ expression )?
/ ( attribute_instance )* OUTPUT_K identifier

udp_input_declaration <- ( attribute_instance )* INPUT_K list_of_udp_port_identifiers

udp_reg_declaration <- ( attribute_instance )* REG_K identifier

//A.5.3 UDP body
udp_body <- combinational_body / sequential_body

combinational_body <- TABLE_K combinational_entry ( combinational_entry )* ENDTABLE_K

combinational_entry <- level_input_list COLON output_symbol SEMI

sequential_body <- ( udp_initial_statement )? TABLE_K sequential_entry ( sequential_entry )* ENDTABLE_K

udp_initial_statement <- INITIAL_K identifier EQ init_val SEMI

init_val <- number; //("1'" [bB] [01xX]) / [01]

sequential_entry <- seq_input_list COLON current_state COLON next_state SEMI

seq_input_list <- level_input_list / edge_input_list

level_input_list <- level_symbol ( level_symbol )*

edge_input_list <- ( level_symbol )* edge_indicator ( level_symbol )*

edge_indicator <- LPAREN level_symbol level_symbol RPAREN / edge_symbol

current_state <- level_symbol

next_state <- output_symbol / MINUS

output_symbol <- number; //[01xX]

level_symbol <- number / IDENT; //[01xX?bB]

edge_symbol <- IDENT / STAR; //[rRfFpPnN*]

//A.5.4 UDP instantiation
udp_instantiation <- identifier ( drive_strength )? ( delay2 )? udp_instance ( COMMA udp_instance )* SEMI

udp_instance <- ( name_of_instance )? LPAREN output_terminal COMMA input_terminal ( COMMA input_terminal )* RPAREN

//A.6 Behavioral statements
//A.6.1 Continuous assignment and net alias statements
continuous_assign <-
ASSIGN_K ( drive_strength )? ( delay3 )? list_of_net_assignments SEMI
/ ASSIGN_K ( delay_control )? list_of_variable_assignments SEMI

list_of_net_assignments <- net_assignment ( COMMA net_assignment )*

list_of_variable_assignments <- variable_assignment ( COMMA variable_assignment )*

net_alias <- ALIAS_K net_lvalue EQ net_lvalue ( EQ net_lvalue )* SEMI

net_assignment <- net_lvalue EQ expression

//A.6.2 Procedural blocks and assignments
initial_construct <- INITIAL_K statement_or_null

always_construct <- always_keyword statement

always_keyword <- 
ALWAYS_COMB_K 
/ ALWAYS_LATCH_K 
/ ALWAYS_FF_K
/ ALWAYS_K 

final_construct <- FINAL_K function_statement

blocking_assignment <-
variable_lvalue EQ delay_or_event_control expression
/ selected_ident EQ class_new
/ nonrange_variable_lvalue EQ dynamic_array_new
/ operator_assignment

operator_assignment <- variable_lvalue assignment_operator expression

assignment_operator <-
EQ / PLUS_EQ / MINUS_EQ / STAR_EQ / DIV_EQ / MOD_EQ / AND_EQ / OR_EQ / XOR_EQ / LT2_EQ / GT2_EQ / LT3_EQ / GT3_EQ

nonblocking_assignment <-
variable_lvalue LT_EQ ( delay_or_event_control )? expression

procedural_continuous_assignment <-
ASSIGN_K variable_assignment
/ DEASSIGN_K variable_lvalue
/ FORCE_K variable_assignment
/ FORCE_K net_assignment
/ RELEASE_K variable_lvalue
/ RELEASE_K net_lvalue

variable_assignment <- variable_lvalue EQ expression

//A.6.3 Parallel and sequential blocks
action_block <-
  ( statement )? ELSE_K statement_or_null
/ statement_or_null

seq_block <-
BEGIN_K ( COLON identifier )? ( block_item_declaration )* ( statement_or_null )* END_K ( COLON identifier )?

par_block <-
FORK_K ( COLON identifier )? ( block_item_declaration )* ( statement_or_null )* join_keyword ( COLON identifier )?

join_keyword <- JOIN_K / JOIN_ANY_K / JOIN_NONE_K

//A.6.4 Statements
statement_or_null <-
statement
/ ( attribute_instance )* SEMI

statement <- ( identifier COLON )? ( attribute_instance )* statement_item

statement_item <-
blocking_assignment SEMI
/ nonblocking_assignment SEMI
/ procedural_continuous_assignment SEMI
/ case_statement
/ conditional_statement
/ inc_or_dec_expression SEMI
/ subroutine_call_statement
/ disable_statement
/ event_trigger
/ loop_statement
/ jump_statement
/ par_block
/ procedural_timing_control_statement
/ seq_block
/ wait_statement
/ procedural_assertion_statement
/ clocking_drive SEMI
/ randsequence_statement
/ randcase_statement
/ expect_property_statement

function_statement <- statement

function_statement_or_null <-
function_statement
/ ( attribute_instance )* SEMI

variable_identifier_list <- identifier ( COMMA identifier )*

//A.6.5 Timing control statements
procedural_timing_control_statement <- procedural_timing_control statement_or_null

delay_or_event_control <-
  REPEAT_K LPAREN expression RPAREN event_control
/ delay_control
/ event_control

delay_control <-
  POUND LPAREN mintypmax_expression RPAREN
/ POUND delay_value

event_control <-
  AT LPAREN event_expression RPAREN
/ AT_STAR / (AT STAR)
/ AT LPAREN STAR RPAREN
/ AT LPAREN_STAR RPAREN
/ AT LPAREN STAR_RPAREN
/ AT selected_ident

event_expression <-
  event_expression OR_K event_expression
/ event_expression COMMA event_expression
/ LPAREN event_expression RPAREN
/ ( edge_identifier )? expression ( IFF_K expression )?
/ sequence_instance ( IFF_K expression )?

procedural_timing_control <-
delay_control
/ event_control
/ cycle_delay

jump_statement <-
RETURN_K ( expression )? SEMI
/ BREAK_K SEMI
/ CONTINUE_K SEMI

wait_statement <-
  WAIT_ORDER_K LPAREN selected_ident ( COMMA selected_ident)* RPAREN action_block
/ WAIT_K LPAREN expression RPAREN statement_or_null
/ WAIT_K FORK_K SEMI

event_trigger <-
  MINUS_GT2 ( delay_or_event_control )? selected_ident SEMI
/ MINUS_GT  selected_ident SEMI

disable_statement <-
  DISABLE_K FORK_K SEMI
/ DISABLE_K selected_ident SEMI

//A.6.6 Conditional statements
conditional_statement <-
( unique_priority )? IF_K LPAREN cond_predicate RPAREN statement_or_null
  ( ELSE_K IF_K LPAREN cond_predicate RPAREN statement_or_null )*
  ( ELSE_K statement_or_null )?

unique_priority <- UNIQUE_K / UNIQUE0_K/ PRIORITY_K

cond_predicate <- expression_or_cond_pattern ( AND3 expression_or_cond_pattern )*

// FIXED
// Error: cond_pattern: rule is indirect left-recursive: path 'cond_pattern->expression->conditional_expression->cond_predicate->expression_or_cond_pattern->cond_pattern'.  (LR-2)
// expression_or_cond_pattern <-
// expression / cond_pattern
// cond_pattern <- expression MATCHES_K pattern
expression_or_cond_pattern <- expression (MATCHES_K pattern)?
// / expression 

//A.6.7 Case statements
case_statement <-
  ( unique_priority )? case_keyword LPAREN case_expression RPAREN MATCHES_K case_pattern_item ( case_pattern_item )* ENDCASE_K
/ ( unique_priority )? CASE_K LPAREN case_expression RPAREN INSIDE_K case_inside_item ( case_inside_item )* ENDCASE_K
/ ( unique_priority )? case_keyword LPAREN case_expression RPAREN case_item ( case_item )* ENDCASE_K

case_keyword <- CASEZ_K / CASEX_K / CASE_K

case_expression <- expression

case_item <-
case_item_expression ( COMMA case_item_expression )* COLON statement_or_null
/ DEFAULT_K ( COLON )? statement_or_null

case_pattern_item <-
pattern ( AND3 expression )? COLON statement_or_null
/ DEFAULT_K ( COLON )? statement_or_null

case_inside_item <-
open_range_list COLON statement_or_null
/ DEFAULT_K ( COLON )? statement_or_null

case_item_expression <- expression

randcase_statement <- RANDCASE_K randcase_item ( randcase_item )* ENDCASE_K

randcase_item <- expression COLON statement_or_null

//A.6.7.1 Patterns
pattern <-
  DOT_STAR
/ TAGGED_K identifier ( pattern )?
/ SQUOTE LCURLY identifier COLON pattern ( COMMA identifier COLON pattern )* RCURLY
/ SQUOTE LCURLY pattern ( COMMA pattern )* RCURLY
/ DOT identifier
/ expression

assignment_pattern <-
  SQUOTE LCURLY structure_pattern_key COLON expression ( COMMA structure_pattern_key COLON expression )* RCURLY
/ SQUOTE LCURLY array_pattern_key COLON expression ( COMMA array_pattern_key COLON expression )* RCURLY
/ SQUOTE LCURLY expression LCURLY expression ( COMMA expression )* RCURLY RCURLY
/ SQUOTE LCURLY expression ( COMMA expression )* RCURLY

structure_pattern_key <- identifier / assignment_pattern_key

array_pattern_key <- expression / assignment_pattern_key

assignment_pattern_key <- simple_type / DEFAULT_K

assignment_pattern_expression <- ( assignment_pattern_expression_type )? assignment_pattern

assignment_pattern_expression_type <-
ps_type_identifier
/ ps_parameter_identifier
/ integer_atom_type
/ type_reference

constant_assignment_pattern_expression <- assignment_pattern_expression

assignment_pattern_net_lvalue <- SQUOTE LCURLY net_lvalue (COMMA net_lvalue )* RCURLY

assignment_pattern_variable_lvalue <- SQUOTE LCURLY variable_lvalue (COMMA variable_lvalue )* RCURLY

//A.6.8 Looping statements
loop_statement <-
FOREVER_K statement_or_null
/ REPEAT_K LPAREN expression RPAREN statement_or_null
/ WHILE_K LPAREN expression RPAREN statement_or_null
/ FOR_K LPAREN for_initialization SEMI expression SEMI for_step RPAREN statement_or_null
/ DO_K statement_or_null WHILE_K LPAREN expression RPAREN SEMI
/ FOREACH_K LPAREN ps_or_hierarchical_array_identifier LBRACK loop_variables RBRACK RPAREN statement

for_initialization <-
list_of_variable_assignments
/ for_variable_declaration ( COMMA for_variable_declaration )*

for_variable_declaration <-
data_type identifier EQ expression ( COMMA identifier EQ expression )*

for_step <- for_step_assignment ( COMMA for_step_assignment )*

for_step_assignment <-
operator_assignment
/ inc_or_dec_expression
// / function_subroutine_call
/ subroutine_call

loop_variables <- ( identifier )? ( COMMA ( identifier )? )*

//A.6.9 Subroutine call statements
subroutine_call_statement <-
  VOID_K SQUOTE LPAREN 
    //function_subroutine_call 
    subroutine_call
    RPAREN SEMI
/ subroutine_call SEMI

//A.6.10 Assertion statements
assertion_item <-
concurrent_assertion_item
/ deferred_immediate_assertion_item

deferred_immediate_assertion_item <- ( identifier COLON )? deferred_immediate_assertion_statement

procedural_assertion_statement <-
concurrent_assertion_statement
/ immediate_assertion_statement
/ checker_instantiation

immediate_assertion_statement <-
simple_immediate_assertion_statement
/ deferred_immediate_assertion_statement

simple_immediate_assertion_statement <-
simple_immediate_assert_statement
/ simple_immediate_assume_statement
/ simple_immediate_cover_statement

simple_immediate_assert_statement <- ASSERT_K LPAREN expression RPAREN action_block

simple_immediate_assume_statement <- ASSUME_K LPAREN expression RPAREN action_block

simple_immediate_cover_statement <- COVER_K LPAREN expression RPAREN statement_or_null

deferred_immediate_assertion_statement <-
deferred_immediate_assert_statement
/ deferred_immediate_assume_statement
/ deferred_immediate_cover_statement

deferred_immediate_assert_statement <- ASSERT_K POUND UNSIGNED_NUMBER LPAREN expression RPAREN action_block

deferred_immediate_assume_statement <- ASSUME_K POUND UNSIGNED_NUMBER LPAREN expression RPAREN action_block

deferred_immediate_cover_statement <- COVER_K POUND UNSIGNED_NUMBER LPAREN expression RPAREN statement_or_null

//A.6.11 Clocking block
clocking_declaration <- 
  GLOBAL_K CLOCKING_K ( identifier )? clocking_event SEMI ENDCLOCKING_K ( COLON identifier )?
/ (DEFAULT_K)? CLOCKING_K ( identifier )? clocking_event SEMI ( clocking_item )* ENDCLOCKING_K ( COLON identifier )?

clocking_event <-
  AT LPAREN event_expression RPAREN
/ AT identifier

clocking_item <-
DEFAULT_K default_skew SEMI
/ clocking_direction list_of_clocking_decl_assign SEMI
/ ( attribute_instance )* assertion_item_declaration

default_skew <-
  INPUT_K clocking_skew OUTPUT_K clocking_skew
/ INPUT_K clocking_skew
/ OUTPUT_K clocking_skew

clocking_direction <-
  INPUT_K ( clocking_skew )? OUTPUT_K ( clocking_skew )?
/ INPUT_K ( clocking_skew )?
/ OUTPUT_K ( clocking_skew )?
/ INOUT_K

list_of_clocking_decl_assign <- clocking_decl_assign ( COMMA clocking_decl_assign )*

clocking_decl_assign <- identifier ( EQ expression )?

clocking_skew <-
edge_identifier ( delay_control )?
/ delay_control

clocking_drive <- clockvar_expression LT_EQ ( cycle_delay )? expression

cycle_delay <-
  POUND2 LPAREN expression RPAREN
/ POUND2 number
/ POUND2 identifier

clockvar <- selected_ident

clockvar_expression <- clockvar

//A.6.12 Randsequence
randsequence_statement <- RANDSEQUENCE_K LPAREN ( identifier )? RPAREN production ( production )* ENDSEQUENCE_K

production <- ( data_type_or_void )? identifier ( LPAREN tf_port_list RPAREN )? COLON rs_rule ( OR rs_rule )* SEMI

rs_rule <- rs_production_list ( COLON_EQ weight_specification ( rs_code_block )? )?

rs_production_list <-
  RAND_K JOIN_K ( LPAREN expression RPAREN )? production_item production_item ( production_item )*
/ rs_prod ( rs_prod )*

weight_specification <-
number
/ ps_identifier
/ LPAREN expression RPAREN

rs_code_block <- LCURLY ( data_declaration )* ( statement_or_null )* RCURLY

rs_prod <-
  rs_code_block
/ rs_if_else
/ rs_repeat
/ rs_case
/ production_item

production_item <- identifier ( LPAREN list_of_arguments RPAREN )?

rs_if_else <- IF_K LPAREN expression RPAREN production_item ( ELSE_K production_item )?

rs_repeat <- REPEAT_K LPAREN expression RPAREN production_item

rs_case <- CASE_K LPAREN case_expression RPAREN rs_case_item ( rs_case_item )* ENDCASE_K

rs_case_item <-
  DEFAULT_K ( COLON )? production_item SEMI
/ case_item_expression ( COMMA case_item_expression )* COLON production_item SEMI

//A.7 Specify section
//A.7.1 Specify block declaration
specify_block <- SPECIFY_K ( specify_item )* ENDSPECIFY_K

specify_item <-
specparam_declaration
/ pulsestyle_declaration
/ showcancelled_declaration
/ path_declaration
/ system_timing_check

pulsestyle_declaration <-
PULSESTYLE_ONEVENT_K list_of_path_outputs SEMI
/ PULSESTYLE_ONDETECT_K list_of_path_outputs SEMI

showcancelled_declaration <-
SHOWCANCELLED_K list_of_path_outputs SEMI
/ NOSHOWCANCELLED_K list_of_path_outputs SEMI

//A.7.2 Specify path declarations
path_declaration <-
simple_path_declaration SEMI
/ edge_sensitive_path_declaration SEMI
/ state_dependent_path_declaration SEMI

simple_path_declaration <-
parallel_path_description EQ path_delay_value
/ full_path_description EQ path_delay_value

parallel_path_description <-
LPAREN specify_input_terminal_descriptor ( polarity_operator )? EQ_GT specify_output_terminal_descriptor RPAREN

full_path_description <- LPAREN list_of_path_inputs ( polarity_operator )? STAR_GT list_of_path_outputs RPAREN

list_of_path_inputs <- specify_input_terminal_descriptor ( COMMA specify_input_terminal_descriptor )*

list_of_path_outputs <- specify_output_terminal_descriptor ( COMMA specify_output_terminal_descriptor )*

//A.7.3 Specify block terminals
specify_input_terminal_descriptor <- input_identifier ( LBRACK constant_range_expression RBRACK )?

specify_output_terminal_descriptor <- output_identifier ( LBRACK constant_range_expression RBRACK )?

input_identifier <- 
  identifier (DOT identifier)?

output_identifier <- 
  identifier (DOT identifier)?

//A.7.4 Specify path delays
path_delay_value <-
  LPAREN list_of_path_delay_expressions RPAREN
/ list_of_path_delay_expressions

list_of_path_delay_expressions <-
  t01_path_delay_expression COMMA t10_path_delay_expression COMMA t0z_path_delay_expression COMMA
  tz1_path_delay_expression COMMA t1z_path_delay_expression COMMA tz0_path_delay_expression COMMA
  t0x_path_delay_expression COMMA tx1_path_delay_expression COMMA t1x_path_delay_expression COMMA
  tx0_path_delay_expression COMMA txz_path_delay_expression COMMA tzx_path_delay_expression
/ t01_path_delay_expression COMMA t10_path_delay_expression COMMA t0z_path_delay_expression COMMA
  tz1_path_delay_expression COMMA t1z_path_delay_expression COMMA tz0_path_delay_expression
/ trise_path_delay_expression COMMA tfall_path_delay_expression COMMA tz_path_delay_expression
/ trise_path_delay_expression COMMA tfall_path_delay_expression
/ t_path_delay_expression

t_path_delay_expression <- path_delay_expression

trise_path_delay_expression <- path_delay_expression

tfall_path_delay_expression <- path_delay_expression

tz_path_delay_expression <- path_delay_expression

t01_path_delay_expression <- path_delay_expression

t10_path_delay_expression <- path_delay_expression

t0z_path_delay_expression <- path_delay_expression

tz1_path_delay_expression <- path_delay_expression

t1z_path_delay_expression <- path_delay_expression

tz0_path_delay_expression <- path_delay_expression

t0x_path_delay_expression <- path_delay_expression

tx1_path_delay_expression <- path_delay_expression

t1x_path_delay_expression <- path_delay_expression

tx0_path_delay_expression <- path_delay_expression

txz_path_delay_expression <- path_delay_expression

tzx_path_delay_expression <- path_delay_expression

path_delay_expression <- constant_mintypmax_expression

edge_sensitive_path_declaration <-
parallel_edge_sensitive_path_description EQ path_delay_value
/ full_edge_sensitive_path_description EQ path_delay_value

parallel_edge_sensitive_path_description <-
LPAREN ( edge_identifier )? specify_input_terminal_descriptor ( polarity_operator )? EQ_GT
LPAREN specify_output_terminal_descriptor ( polarity_operator )? COLON data_source_expression RPAREN RPAREN

full_edge_sensitive_path_description <-
LPAREN ( edge_identifier )? list_of_path_inputs ( polarity_operator )? STAR_GT
  LPAREN list_of_path_outputs ( polarity_operator )? COLON data_source_expression RPAREN RPAREN

data_source_expression <- expression

edge_identifier <- POSEDGE_K / NEGEDGE_K / EDGE_K

state_dependent_path_declaration <-
  IF_K LPAREN module_path_expression RPAREN edge_sensitive_path_declaration
/ IF_K LPAREN module_path_expression RPAREN simple_path_declaration
/ IFNONE_K simple_path_declaration

polarity_operator <- PLUS / MINUS

//A.7.5 System timing checks
//A.7.5.1 System timing check commands
//NOTE<- rules starting w/ $ were changed to ds_  (dollar sign)
system_timing_check <-
ds_setup_timing_check
/ ds_hold_timing_check
/ ds_setuphold_timing_check
/ ds_recovery_timing_check
/ ds_removal_timing_check
/ ds_recrem_timing_check
/ ds_skew_timing_check
/ ds_timeskew_timing_check
/ ds_fullskew_timing_check
/ ds_period_timing_check
/ ds_width_timing_check
/ ds_nochange_timing_check

ds_setup_timing_check <-
DS_SETUP_K LPAREN data_event COMMA reference_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_hold_timing_check <-
DS_HOLD_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_setuphold_timing_check <-
DS_SETUPHOLD_K LPAREN reference_event COMMA data_event COMMA timing_check_limit COMMA timing_check_limit
  ( COMMA ( notifier )? ( COMMA ( timestamp_condition )? ( COMMA ( timecheck_condition )?
  ( COMMA ( delayed_reference )? ( COMMA ( delayed_data )? )? )? )? )? )? RPAREN SEMI

ds_recovery_timing_check <-
DS_RECOVERY_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_removal_timing_check <-
DS_REMOVAL_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_recrem_timing_check <-
DS_RECREM_K LPAREN reference_event COMMA data_event COMMA timing_check_limit COMMA timing_check_limit
  ( COMMA ( notifier )? ( COMMA ( timestamp_condition )? ( COMMA ( timecheck_condition )?
  ( COMMA ( delayed_reference )? ( COMMA ( delayed_data )? )? )? )? )? )? RPAREN SEMI

ds_skew_timing_check <- DS_SKEW_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_timeskew_timing_check <-
DS_TIMESKEW_K LPAREN reference_event COMMA data_event COMMA timing_check_limit
  ( COMMA ( notifier )? ( COMMA ( event_based_flag )? ( COMMA ( remain_active_flag )? )? )? )? RPAREN SEMI

ds_fullskew_timing_check <-
DS_FULLSKEW_K LPAREN reference_event COMMA data_event COMMA timing_check_limit COMMA timing_check_limit
  ( COMMA ( notifier )? ( COMMA ( event_based_flag )? ( COMMA ( remain_active_flag )? )? )? )? RPAREN SEMI

ds_period_timing_check <-
DS_PERIOD_K LPAREN controlled_reference_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_width_timing_check <-
DS_WIDTH_K LPAREN controlled_reference_event COMMA timing_check_limit COMMA threshold ( COMMA ( notifier )? )? RPAREN SEMI

ds_nochange_timing_check <-
DS_NOCHANGE_K LPAREN reference_event COMMA data_event COMMA start_edge_offset COMMA 
  end_edge_offset ( COMMA ( notifier )? )? RPAREN SEMI

//A.7.5.2 System timing check command arguments
timecheck_condition <- mintypmax_expression

controlled_reference_event <- controlled_timing_check_event

data_event <- timing_check_event

delayed_data <- identifier (LBRACK constant_mintypmax_expression RBRACK)? // / identifier

delayed_reference <- identifier (LBRACK constant_mintypmax_expression RBRACK)?  // / identifier

end_edge_offset <- mintypmax_expression

event_based_flag <- expression

notifier <- identifier

reference_event <- timing_check_event

remain_active_flag <- constant_mintypmax_expression

timestamp_condition <- mintypmax_expression

start_edge_offset <- mintypmax_expression

threshold <- expression

timing_check_limit <- expression

//A.7.5.3 System timing check event definitions
timing_check_event <- (timing_check_event_control)? specify_terminal_descriptor ( AND3 timing_check_condition )?

controlled_timing_check_event <- timing_check_event_control specify_terminal_descriptor ( AND3 timing_check_condition )?

timing_check_event_control <-
POSEDGE_K
/ NEGEDGE_K
/ EDGE_K
/ edge_control_specifier

specify_terminal_descriptor <-
specify_input_terminal_descriptor
/ specify_output_terminal_descriptor

edge_control_specifier <- EDGE_K LBRACK edge_descriptor ( COMMA edge_descriptor )* RBRACK

//edge_descriptor <- "01" / "10" / [01][xX] / [xX][01]
edge_descriptor <- STRING_LITERAL / IDENT / NUMBER

timing_check_condition <-
  LPAREN scalar_timing_check_condition RPAREN
/ scalar_timing_check_condition

scalar_timing_check_condition <-
  expression EQ2 scalar_constant
/ expression EQ3 scalar_constant
/ expression NOT_EQ scalar_constant
/ expression NOT_EQ2 scalar_constant
/ TILDE? expression

scalar_constant <- number; //('1'? [bB])? [01]

//A.8 Expressions
//A.8.1 Concatenations
concatenation <-
LCURLY expression ( COMMA expression )* RCURLY

constant_concatenation <- LCURLY expression ( COMMA expression )* RCURLY

constant_multiple_concatenation <- LCURLY expression constant_concatenation RCURLY

module_path_concatenation <- LCURLY module_path_expression ( COMMA module_path_expression )* RCURLY

module_path_multiple_concatenation <- LCURLY expression module_path_concatenation RCURLY

multiple_concatenation <- LCURLY expression concatenation RCURLY

streaming_concatenation <- LCURLY stream_operator ( slice_size )? stream_concatenation RCURLY

stream_operator <- GT2 / LT2

slice_size <- simple_type / expression

stream_concatenation <- LCURLY stream_expression ( COMMA stream_expression )* RCURLY

stream_expression <- expression ( WITH_K LBRACK array_range_expression RBRACK )?

array_range_expression <-
expression COLON expression
/ expression PLUS_COLON expression
/ expression MINUS_COLON expression
/ expression

empty_queue <- LCURLY RCURLY

//A.8.2 Subroutine calls
//NOTE: indirect left recursion.  inline.
//constant_function_call <- function_subroutine_call

tf_call <- selected_ident ( attribute_instance )* ( LPAREN list_of_arguments RPAREN )?

system_tf_call <-
system_tf_identifier LPAREN data_type ( COMMA expression )? RPAREN
/ system_tf_identifier ( LPAREN list_of_arguments RPAREN )?

subroutine_call <-
  (STD_K COLON2)? randomize_call
//method_call: matches tf_call
/ system_tf_call
/ tf_call

//NOTE{ mitigate ILR
//method_call <- method_call_root DOT method_call_body
//method_call_root <- primary / implicit_class_handle
//}
//NOTE: inline above: method_call <- (primary / implicit_class_handle) DOT method_call_body

std_colon2<- IDENT COLON2

//ILR: inline: function_subroutine_call <- subroutine_call

list_of_arguments <-
  DOT identifier LPAREN ( expression )? RPAREN ( COMMA DOT identifier LPAREN ( expression )? RPAREN )*
/ ( expression )? ( COMMA ( expression )? )* ( COMMA DOT identifier LPAREN ( expression )? RPAREN )*

method_call_body <-
identifier ( attribute_instance )* ( LPAREN list_of_arguments RPAREN )?
/ built_in_method_call

built_in_method_call <-
array_manipulation_call
/ randomize_call

array_manipulation_call <-
array_method_name ( attribute_instance )* ( LPAREN list_of_arguments RPAREN )?  ( WITH_K LPAREN expression RPAREN )?

randomize_call <-
//NOTE<- "randomize" is not a keyword, so no RANDOMIZE_K
//I think that is a mistake.  should be keyword
RANDOMIZE_K ( attribute_instance )* ( LPAREN ( variable_identifier_list / NULL_K )? RPAREN )?
  ( WITH_K ( LPAREN ( identifier_list )? RPAREN )? constraint_block )?

array_method_name <- identifier / UNIQUE_K / AND_K / OR_K / XOR_K

//A.8.3 Expressions
inc_or_dec_expression <-
inc_or_dec_operator ( attribute_instance )* variable_lvalue
/ variable_lvalue ( attribute_instance )* inc_or_dec_operator

//NOT USED: conditional_expression <- 
//NOT USED: //ILR{ cond_predicate 
//NOT USED: //ILR{ expression_or_cond_pattern 
//NOT USED: expression (MATCHES_K pattern)?
//NOT USED: //}
//NOT USED: //}
//NOT USED:   ( AND3 
//NOT USED:     //ILR{ expression_or_cond_pattern 
//NOT USED:     expression (MATCHES_K pattern)?
//NOT USED:     //}
//NOT USED:   )*
//NOT USED:   QMARK ( attribute_instance )* expression COLON expression

constant_mintypmax_expression <- expression (COLON expression COLON expression)?

constant_param_expression <-
constant_mintypmax_expression / data_type / DOLLAR

param_expression <- mintypmax_expression / data_type

constant_range_expression <-
  constant_part_select_range
/ expression

constant_part_select_range <-
  expression (COLON / PLUS_COLON / MINUS_COLON) expression

range <- expression COLON expression

expression <-
//ILR{ / conditional_expression
expression (MATCHES_K pattern)?  ( AND3 expression (MATCHES_K pattern)?)* QMARK ( attribute_instance )* expression COLON expression
//}
/ expression binary_operator ( attribute_instance )* expression
//ILR{ / inside_expression
/ expression INSIDE_K LCURLY open_range_list RCURLY
//}
/ unary_operator ( attribute_instance )* primary
/ inc_or_dec_expression
/ LPAREN operator_assignment RPAREN
/ tagged_union_expression
/ primary

tagged_union_expression <- TAGGED_K identifier ( expression )?

value_range <-
  LBRACK expression COLON expression RBRACK
/ expression

mintypmax_expression <-
  expression COLON expression COLON expression
/ expression

//module_path_conditional_expression <- 
//module_path_expression QMARK ( attribute_instance )* module_path_expression COLON module_path_expression

module_path_expression <-
//ILR{ / module_path_conditional_expression
  module_path_expression QMARK ( attribute_instance )* module_path_expression COLON module_path_expression
//}
/ module_path_expression binary_module_path_operator ( attribute_instance )*
/ unary_module_path_operator ( attribute_instance )* module_path_primary module_path_expression
/ module_path_primary

module_path_mintypmax_expression <-
  module_path_expression COLON module_path_expression COLON module_path_expression
/ module_path_expression

part_select_range <- range / indexed_range

indexed_range <-
expression PLUS_COLON expression
/ expression MINUS_COLON expression

genvar_expression <- expression

//constant_cast <-
//casting_type SQUOTE LPAREN expression RPAREN
//casting_type <- simple_type / constant_primary / signing / STRING_K /CONST_K 

//A.8.4 Primaries
constant_primary <-
//NOTE replace to mitigate ILR{ / constant_cast
//ILR{ / casting_type 
constant_primary SQUOTE LPAREN expression RPAREN
/ (simple_type / signing / STRING_K / CONST_K) SQUOTE LPAREN expression RPAREN
//}
//}
/ constant_multiple_concatenation ( LBRACK constant_range_expression RBRACK )?
/ constant_concatenation ( LBRACK constant_range_expression RBRACK )?
/ constant_let_expression
/ LPAREN constant_mintypmax_expression RPAREN
//NOTE{ / constant_function_call
// / function_subroutine_call
/ subroutine_call
//}
/ selected_ident
/ constant_assignment_pattern_expression
/ type_reference
/ primary_literal

module_path_primary <-
  LPAREN module_path_mintypmax_expression RPAREN
/ module_path_multiple_concatenation
/ module_path_concatenation
// / function_subroutine_call
/ subroutine_call
/ number
/ identifier

primary <-
  multiple_concatenation ( LBRACK range_expression RBRACK )?
/ concatenation ( LBRACK range_expression RBRACK )?
/ empty_queue
// / function_subroutine_call
/ subroutine_call
/ let_expression
/ LPAREN mintypmax_expression RPAREN
/ cast
/ assignment_pattern_expression
/ streaming_concatenation
/ sequence_method_call
/ THIS_K
/ DOLLAR
/ NULL_K
/ selected_ident
/ primary_literal


range_expression <-
expression
/ part_select_range

primary_literal <- number / TIME_LITERAL / UNBASED_UNSIZED_LITERAL / STRING_LITERAL ;

// constant_cast <-
//casting_type SQUOTE LPAREN expression RPAREN

constant_let_expression <- let_expression

cast <-
//ILR{ casting_type 
(simple_type / constant_primary / signing / STRING_K / CONST_K)
//}
  SQUOTE LPAREN expression RPAREN

//A.8.5 Expression left-side values
net_lvalue <-
  LCURLY net_lvalue ( COMMA net_lvalue )* RCURLY
/ selected_ident
/ ( assignment_pattern_expression_type )? assignment_pattern_net_lvalue

variable_lvalue <-
  LCURLY variable_lvalue ( COMMA variable_lvalue )* RCURLY
/ selected_ident
/ ( assignment_pattern_expression_type )? assignment_pattern_variable_lvalue
/ streaming_concatenation

nonrange_variable_lvalue <- selected_ident

//A.8.6 Operators
unary_operator <-
TILDE_AND 
/ TILDE_OR 
/ TILDE_XOR 
/ XOR_TILDE 
/ PLUS 
/ MINUS 
/ NOT 
/ TILDE 
/ AND 
/ OR 
/ XOR

binary_operator <-
LT_MINUS_GT
/ NOT_EQ_QMARK 
/ MINUS_GT 
/ GT3 
/ LT3
/ GT2 
/ LT2 
/ EQ3 
/ EQ2_QMARK 
/ EQ2 
/ NOT_EQ2 
/ NOT_EQ 
/ LT_EQ 
/ GT_EQ 
/ AND2 
/ OR2 
/ STAR2
/ XOR_TILDE 
/ TILDE_XOR 
/ PLUS 
/ MINUS 
/ STAR 
/ DIV 
/ MOD 
/ LT 
/ GT 
/ AND 
/ OR 
/ XOR 

inc_or_dec_operator <- PLUS2 / MINUS2

unary_module_path_operator <- 
TILDE_AND 
/ TILDE_OR 
/ TILDE_XOR 
/ XOR_TILDE
/ NOT 
/ TILDE 
/ AND 
/ OR 
/ XOR 

binary_module_path_operator <- 
EQ2 
/ NOT_EQ 
/ AND2 
/ OR2 
/ XOR_TILDE 
/ TILDE_XOR
/ AND 
/ OR 
/ XOR 

//A.8.7 Numbers
number <- NUMBER / UNSIGNED_NUMBER ;

//A.8.8 Strings
string_literal <- STRING_LITERAL //" ( Any_ASCII_Characters )* "

//A.9 General
//A.9.1 Attributes
attribute_instance <- LPAREN_STAR attr_spec ( COMMA attr_spec )* STAR_RPAREN

attr_spec <- attr_name ( EQ expression )?

attr_name <- identifier


//A.9.3 Identifiers
c_identifier <- identifier //TODO<- ( a-zA-Z_ )? ( ( a-zA-Z0-9_ )? )*

escaped_identifier <- ESC_IDENT //TODO<- \ (any_ASCII_character_except_white_space)* white_space


identifier <-
simple_identifier
/ escaped_identifier

ps_covergroup_identifier <- selected_ident

ps_identifier <- selected_ident

ps_or_hierarchical_array_identifier <-
selected_ident

ps_or_hierarchical_identifier <- 
selected_ident

ps_parameter_identifier <-
selected_ident

ps_type_identifier <- selected_ident

simple_identifier <- IDENT

system_tf_identifier <- SYSTEM_IDENT

extern_tf_declaration <- 
  EXTERN_K FORKJOIN_K task_prototype SEMI
/ EXTERN_K method_prototype SEMI
;

ACCEPT_ON_K.
ALIAS_K.
ALWAYS_COMB_K.
ALWAYS_FF_K.
ALWAYS_K.
ALWAYS_LATCH_K.
AND_K.
ASSERT_K.
ASSIGN_K.
ASSUME_K.
AUTOMATIC_K.
BEFORE_K.
BEGIN_K.
BIND_K.
BINSOF_K.
BINS_K.
BIT_K.
BREAK_K.
BUFIF0_K.
BUFIF1_K.
BUF_K.
BYTE_K.
CASEX_K.
CASEZ_K.
CASE_K.
CELL_K.
CHANDLE_K.
CHECKER_K.
CLASS_K.
CLOCKING_K.
CMOS_K.
CONFIG_K.
CONSTRAINT_K.
CONST_K.
CONTEXT_K.
CONTINUE_K.
COVERGROUP_K.
COVERPOINT_K.
COVER_K.
CROSS_K.
DEASSIGN_K.
DEFAULT_K.
DEFPARAM_K.
DESIGN_K.
DISABLE_K.
DIST_K.
DO_K.
EDGE_K.
ELSE_K.
ENDCASE_K.
ENDCHECKER_K.
ENDCLASS_K.
ENDCLOCKING_K.
ENDCONFIG_K.
ENDFUNCTION_K.
ENDGENERATE_K.
ENDGROUP_K.
ENDINTERFACE_K.
ENDMODULE_K.
ENDPACKAGE_K.
ENDPRIMITIVE_K.
ENDPROGRAM_K.
ENDPROPERTY_K.
ENDSEQUENCE_K.
ENDSPECIFY_K.
ENDTABLE_K.
ENDTASK_K.
END_K.
ENUM_K.
EVENTUALLY_K.
EVENT_K.
EXPECT_K.
EXPORT_K.
EXTENDS_K.
EXTERN_K.
FINAL_K.
FIRST_MATCH_K.
FORCE_K.
FOREACH_K.
FOREVER_K.
FORKJOIN_K.
FORK_K.
FOR_K.
FUNCTION_K.
GENERATE_K.
GENVAR_K.
GLOBAL_K.
HIGHZ0_K.
HIGHZ1_K.
IFF_K.
IFNONE_K.
IF_K.
IGNORE_BINS_K.
ILLEGAL_BINS_K.
IMPLIES_K.
IMPORT_K.
INCDIR_K.
INCLUDE_K.
INITIAL_K.
INOUT_K.
INPUT_K.
INSIDE_K.
INSTANCE_K.
INTEGER_K.
INTERFACE_K.
INTERSECT_K.
INT_K.
JOIN_ANY_K.
JOIN_K.
JOIN_NONE_K.
LARGE_K.
LET_K.
LIBLIST_K.
LIBRARY_K.
LOCALPARAM_K.
LOCAL_K.
LOGIC_K.
LONGINT_K.
MACROMODULE_K.
MATCHES_K.
MEDIUM_K.
MODPORT_K.
MODULE_K.
NAND_K.
NEGEDGE_K.
NEW_K.
NEXTTIME_K.
NMOS_K.
NOR_K.
NOSHOWCANCELLED_K.
NOTIF0_K.
NOTIF1_K.
NOT_K.
NULL_K.
OR_K.
OUTPUT_K.
PACKAGE_K.
PACKED_K.
PARAMETER_K.
PMOS_K.
POSEDGE_K.
PRIMITIVE_K.
PRIORITY_K.
PROGRAM_K.
PROPERTY_K.
PROTECTED_K.
PULL0_K.
PULL1_K.
PULLDOWN_K.
PULLUP_K.
PULSESTYLE_ONDETECT_K.
PULSESTYLE_ONEVENT_K.
PURE_K.
RANDCASE_K.
RANDC_K.
RANDSEQUENCE_K.
RAND_K.
RANDOMIZE_K.
RCMOS_K.
REALTIME_K.
REAL_K.
REF_K.
REG_K.
REJECT_ON_K.
RELEASE_K.
REPEAT_K.
RESTRICT_K.
RETURN_K.
RNMOS_K.
RPMOS_K.
RTRANIF0_K.
RTRANIF1_K.
RTRAN_K.
SCALARED_K.
SEQUENCE_K.
SHORTINT_K.
SHORTREAL_K.
SHOWCANCELLED_K.
SIGNED_K.
SMALL_K.
SOLVE_K.
SPECIFY_K.
SPECPARAM_K.
STATIC_K.
STD_K.
STRING_K.
STRONG0_K.
STRONG1_K.
STRONG_K.
STRUCT_K.
SUPER_K.
SUPPLY0_K.
SUPPLY1_K.
SYNC_ACCEPT_ON_K.
SYNC_REJECT_ON_K.
S_ALWAYS_K.
S_EVENTUALLY_K.
S_NEXTTIME_K.
S_UNTIL_K.
S_UNTIL_WITH_K.
TABLE_K.
TAGGED_K.
TASK_K.
THIS_K.
THROUGHOUT_K.
TIMEPRECISION_K.
TIMEUNIT_K.
TIME_K.
TRANIF0_K.
TRANIF1_K.
TRAN_K.
TRI0_K.
TRI1_K.
TRIAND_K.
TRIOR_K.
TRIREG_K.
TRI_K.
TYPEDEF_K.
TYPE_K.
UNION_K.
UNIQUE0_K.
UNIQUE_K.
UNSIGNED_K.
UNTIL_K.
UNTIL_WITH_K.
UNTYPED_K.
USE_K.
UWIRE_K.
VAR_K.
VECTORED_K.
VIRTUAL_K.
VOID_K.
WAIT_K.
WAIT_ORDER_K.
WAND_K.
WEAK0_K.
WEAK1_K.
WEAK_K.
WHILE_K.
WILDCARD_K.
WIRE_K.
WITHIN_K.
WITH_K.
WOR_K.
XNOR_K.
XOR_K.
W1STEP_K.
PATHPULSE_K.
DS_SETUP_K.
DS_REMOVAL_K.
DS_PERIOD_K.
DS_RECREM_K.
DS_SETUPHOLD_K.
DS_RECOVERY_K.
DS_HOLD_K.
DS_WIDTH_K.
DS_SKEW_K.
DS_FULLSKEW_K.
DS_TIMESKEW_K.
DS_NOCHANGE_K.
DS_FATAL_K.
DS_ERROR_K.
DS_WARNING_K.
DS_INFO_K.
DS_UNIT_K.
DS_ROOT_K.
AND.
AND2.
AND3.
AND_EQ.
AT.
AT2.
AT_STAR.
BAR_EQ_GT.
BAR_MINUS_GT.
COLON2.
COLON.
COLON_DIV.
COLON_EQ.
COMMA.
DIV.
DIV_EQ.
DOLLAR.
DOT.
DOT_STAR.
EQ2.
EQ2_QMARK.
EQ3.
EQ.
EQ_GT.
GT2.
GT2_EQ.
GT3_EQ.
GT.
GT3.
GT_EQ.
LBRACK.
LCURLY.
LPAREN.
LPAREN_STAR.
LT2.
LT2_EQ.
LT3_EQ.
LT.
LT3.
LT_EQ.
LT_MINUS_GT.
MINUS2.
MINUS.
MINUS_COLON.
MINUS_EQ.
MINUS_GT2.
MINUS_GT.
MOD.
MOD_EQ.
NOT.
NOT_EQ2.
NOT_EQ.
NOT_EQ_QMARK.
OR2.
OR.
OR_EQ.
PLUS2.
PLUS.
PLUS_COLON.
PLUS_EQ.
POUND2.
POUND.
POUND_EQ_POUND.
POUND_MINUS_POUND.
QMARK.
RBRACK.
RCURLY.
RPAREN.
SEMI.
STAR2.
STAR.
STAR_COLON2_STAR.
STAR_EQ.
STAR_GT.
STAR_RPAREN.
TILDE.
TILDE_AND.
TILDE_OR.
TILDE_XOR.
XOR.
XOR_EQ.
XOR_TILDE.
IDENT.
ESC_IDENT.
UNSIGNED_NUMBER.
UNBASED_UNSIZED_LITERAL.
NUMBER.
TIME_LITERAL.
SYSTEM_IDENT.
SQUOTE.
STRING_LITERAL.
