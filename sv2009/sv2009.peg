Grammar <- source_text

source_text <- timeunits_declaration? description* Spacing EOF

description <-
module_declaration
/ udp_declaration
/ interface_declaration
/ program_declaration
/ package_declaration
/ attribute_instance* package_item
/ attribute_instance* bind_directive
/ config_declaration

module_declaration <-
module_ansi_header timeunits_declaration? non_port_module_item* ENDMODULE_K (COLON identifier)?
/ module_nonansi_header timeunits_declaration? module_item* ENDMODULE_K (COLON identifier)?
/ attribute_instance* module_keyword lifetime? identifier ( DOT_STAR ) SEMI 
	timeunits_declaration? module_item* ENDMODULE_K (COLON identifier)?
/ EXTERN_K module_nonansi_header
/ EXTERN_K module_ansi_header

module_nonansi_header <-
attribute_instance* module_keyword lifetime? identifier package_import_declaration* parameter_port_list? list_of_ports SEMI

module_ansi_header <-
attribute_instance* module_keyword lifetime? identifier package_import_declaration* parameter_port_list? 
	list_of_port_declarations? SEMI

module_keyword <- MODULE_K / MACROMODULE_K

interface_declaration <-
interface_ansi_header timeunits_declaration? non_port_interface_item* ENDINTERFACE_K (COLON identifier)?
/ interface_nonansi_header timeunits_declaration? interface_item* ENDINTERFACE_K (COLON identifier)?
/ attribute_instance* INTERFACE_K identifier ( DOT_STAR ) SEMI timeunits_declaration? interface_item* ENDINTERFACE_K 
	(COLON identifier)?
/ EXTERN_K interface_ansi_header
/ EXTERN_K interface_nonansi_header

interface_nonansi_header <-
attribute_instance* INTERFACE_K lifetime? identifier package_import_declaration* parameter_port_list? 
	list_of_ports SEMI

interface_ansi_header <-
attribute_instance* INTERFACE_K lifetime? identifier package_import_declaration* parameter_port_list? 
	list_of_port_declarations? SEMI

program_declaration <-
program_ansi_header timeunits_declaration? non_port_program_item* ENDPROGRAM_K (COLON identifier)?
/ program_nonansi_header timeunits_declaration? program_item* ENDPROGRAM_K (COLON identifier)?
/ attribute_instance* PROGRAM_K identifier ( DOT_STAR ) SEMI timeunits_declaration? program_item* ENDPROGRAM_K 
	(COLON identifier)?
/ EXTERN_K program_ansi_header
/ EXTERN_K program_nonansi_header

program_nonansi_header <-
attribute_instance* PROGRAM_K lifetime? identifier package_import_declaration* parameter_port_list? 
	list_of_ports SEMI

program_ansi_header <-
attribute_instance* PROGRAM_K lifetime? identifier package_import_declaration* parameter_port_list? 
	list_of_port_declarations? SEMI

checker_declaration <-
CHECKER_K identifier (LPAREN checker_port_list? RPAREN)? SEMI checker_or_generate_item* ENDCHECKER_K 
	(COLON identifier)?

class_declaration <-
VIRTUAL_K? CLASS_K lifetime? identifier parameter_port_list?  
	(EXTENDS_K class_type (LPAREN list_of_arguments RPAREN)? )? SEMI
	class_item*
	ENDCLASS_K (COLON identifier)?

package_declaration <-
attribute_instance* PACKAGE_K lifetime? identifier SEMI
	timeunits_declaration? (attribute_instance* package_item)*
	ENDPACKAGE_K (COLON identifier)?

timeunits_declaration <-
TIMEUNIT_K time_literal SEMI TIMEPRECISION_K time_literal SEMI
/ TIMEUNIT_K time_literal (DIV time_literal)? SEMI
/ TIMEPRECISION_K time_literal SEMI TIMEUNIT_K time_literal SEMI
/ TIMEPRECISION_K time_literal SEMI

parameter_port_list <-
POUND LPAREN list_of_param_assignments (COMMA parameter_port_declaration)* RPAREN
/ POUND LPAREN parameter_port_declaration (COMMA parameter_port_declaration)* RPAREN
/ POUND LPAREN RPAREN

parameter_port_declaration <-
local_parameter_declaration
/ data_type list_of_param_assignments
/ TYPE_K list_of_type_assignments
/ parameter_declaration

list_of_ports <- LPAREN port (COMMA port)* RPAREN

list_of_port_declarations <-
LPAREN ( attribute_instance* ansi_port_declaration (COMMA attribute_instance* ansi_port_declaration)* )? RPAREN

port_declaration <-
attribute_instance* interface_port_declaration
/ attribute_instance* inout_declaration
/ attribute_instance* input_declaration
/ attribute_instance* output_declaration
/ attribute_instance* ref_declaration

port <-
DOT identifier LPAREN port_expression? RPAREN
/ port_expression?

port_expression <-
LCURLY port_reference (COMMA port_reference)* RCURLY
/ port_reference

port_reference <-
identifier constant_select

port_direction <- INPUT_K / OUTPUT_K / INOUT_K / REF_K

net_port_header <- port_direction? net_port_type

variable_port_header <- port_direction? variable_port_type

interface_port_header <-
INTERFACE_K (DOT identifier)?
/ identifier (DOT identifier)?

ansi_port_declaration <-
//since we dont track types, first(net_port_header)==ident which also matches
//port_identifier.  Eeek, lots of ambiguities
port_direction? identifier unpacked_dimension* ( EQ constant_expression )?
/ (net_port_header / interface_port_header)? identifier unpacked_dimension* ( EQ constant_expression )?
/ variable_port_header? identifier variable_dimension* (EQ constant_expression )?
/ port_direction? DOT identifier LPAREN expression? RPAREN

elaboration_system_task <-
// $fatal $error $warning $info
DS_FATAL_K (LPAREN finish_number (COMMA list_of_arguments)? RPAREN)? SEMI
/ DS_ERROR_K (LPAREN list_of_arguments RPAREN)? SEMI
/ DS_WARNING_K (LPAREN list_of_arguments RPAREN)? SEMI
/ DS_INFO_K (LPAREN list_of_arguments RPAREN)? SEMI

finish_number <- [0-2]

module_common_item <-
initial_construct
/ always_construct
/ interface_instantiation
/ program_instantiation
/ assertion_item
/ bind_directive
/ continuous_assign
/ net_alias
/ final_construct
/ loop_generate_construct
/ conditional_generate_construct
/ elaboration_system_task
/ module_or_generate_item_declaration

module_item <-
port_declaration SEMI
/ non_port_module_item

module_or_generate_item <-
attribute_instance* module_instantiation
/ attribute_instance* gate_instantiation
/ attribute_instance* udp_instantiation
/ attribute_instance* module_common_item
/ attribute_instance* parameter_override

module_or_generate_item_declaration <-
package_or_generate_item_declaration
/ genvar_declaration
/ clocking_declaration
/ DEFAULT_K CLOCKING_K identifier SEMI
/ DEFAULT_K DISABLE_K IFF_K expression_or_dist SEMI

non_port_module_item <-
generate_region
/ module_or_generate_item
/ specify_block
/ attribute_instance* specparam_declaration
/ program_declaration
/ module_declaration
/ interface_declaration
/ timeunits_declaration

parameter_override <- DEFPARAM_K list_of_defparam_assignments SEMI

bind_directive <-
BIND_K bind_target_scope (COLON bind_target_instance_list)? bind_instantiation SEMI
/ BIND_K bind_target_instance bind_instantiation SEMI

bind_target_scope <-
identifier

bind_target_instance <-
hierarchical_identifier constant_bit_select

bind_target_instance_list <-
bind_target_instance (COMMA bind_target_instance)*

bind_instantiation <-
program_instantiation
/ module_instantiation
/ interface_instantiation
/ checker_instantiation


//A.1.5 Configuration source text
config_declaration <-
CONFIG_K identifier SEMI (local_parameter_declaration SEMI)* design_statement config_rule_statement*
	ENDCONFIG_K (COLON identifier)?

design_statement <- DESIGN_K ((identifier DOT)? identifier)* SEMI

config_rule_statement <-
default_clause liblist_clause SEMI
/ inst_clause liblist_clause SEMI
/ inst_clause use_clause SEMI
/ cell_clause liblist_clause SEMI
/ cell_clause use_clause SEMI

default_clause <- DEFAULT_K

inst_clause <- INSTANCE_K inst_name

inst_name <- identifier (DOT identifier)*

cell_clause <- CELL_K (identifier DOT)? identifier

liblist_clause <- LIBLIST_K identifier*

use_clause <- 
  USE_K (identifier DOT)? identifier named_parameter_assignment (COMMA named_parameter_assignment)* (COLON CONFIG_K)?
/ USE_K named_parameter_assignment (COMMA named_parameter_assignment)* (COLON CONFIG_K)?
/ USE_K (identifier DOT)? identifier (COLON CONFIG_K)?


//A.1.6 Interface items
interface_or_generate_item <-
attribute_instance* module_common_item
/ attribute_instance* modport_declaration
/ attribute_instance* extern_tf_declaration

//NOT USED: extern <-
//NOT USED: EXTERN_K method_prototype SEMI
//NOT USED: / EXTERN_K FORKJOIN_K task_prototype SEMI

interface_item <-
port_declaration SEMI
/ non_port_interface_item

non_port_interface_item <-
generate_region
/ interface_or_generate_item
/ program_declaration
/ interface_declaration
/ timeunits_declaration

//A.1.7 Program items
program_item <-
port_declaration SEMI
/ non_port_program_item

non_port_program_item <-
attribute_instance* continuous_assign
/ attribute_instance* module_or_generate_item_declaration
/ attribute_instance* initial_construct
/ attribute_instance* final_construct
/ attribute_instance* concurrent_assertion_item
/ attribute_instance* timeunits_declaration
/ program_generate_item

program_generate_item <-
loop_generate_construct
/ conditional_generate_construct
/ generate_region
/ elaboration_system_task

//A.1.8 Checker items
checker_port_list <- checker_port_item (COMMA checker_port_item)*

checker_port_item <-
attribute_instance* property_formal_type identifier variable_dimension* (EQ property_actual_arg)?

checker_or_generate_item <-
checker_or_generate_item_declaration
/ initial_construct
/ checker_always_construct
/ final_construct
/ assertion_item
/ checker_generate_item

checker_or_generate_item_declaration <-
RAND_K? data_declaration
/ function_declaration
/ assertion_item_declaration
/ covergroup_declaration
/ overload_declaration
/ genvar_declaration
/ clocking_declaration
/ DEFAULT_K CLOCKING_K identifier SEMI
/ DEFAULT_K DISABLE_K IFF_K expression_or_dist SEMI
/ SEMI

checker_generate_item <-
loop_generate_construct
/ conditional_generate_construct
/ generate_region
/ elaboration_system_task

checker_always_construct <- ALWAYS_K statement

//A.1.9 Class items
class_item <-
attribute_instance* class_property
/ attribute_instance* class_method
/ attribute_instance* class_constraint
/ attribute_instance* class_declaration
/ attribute_instance* covergroup_declaration
/ local_parameter_declaration SEMI
/ parameter_declaration SEMI
/ SEMI

class_property <-
CONST_K class_item_qualifier* data_type identifier (EQ constant_expression)? SEMI
/ property_qualifier* data_declaration

class_method <-
method_qualifier* task_declaration
/ method_qualifier* function_declaration
/ method_qualifier* class_constructor_declaration
/ EXTERN_K? method_qualifier* class_constructor_prototype
/ EXTERN_K? method_qualifier* method_prototype SEMI

class_constructor_prototype <-
FUNCTION_K NEW_K LPAREN tf_port_list? RPAREN SEMI

class_constraint <-
constraint_prototype
/ constraint_declaration

class_item_qualifier <-
STATIC_K
/ PROTECTED_K
/ LOCAL_K

property_qualifier <-
random_qualifier
/ class_item_qualifier

random_qualifier <-
RAND_K
/ RANDC_K

method_qualifier <-
PURE_K? VIRTUAL_K
/ class_item_qualifier

method_prototype <-
task_prototype
/ function_prototype

class_constructor_declaration <-
FUNCTION_K class_scope? NEW_K (LPAREN tf_port_list? RPAREN)? SEMI
	block_item_declaration*
	(SUPER_K DOT NEW_K (LPAREN list_of_arguments RPAREN)? SEMI )?
	function_statement_or_null*
	ENDFUNCTION_K (COLON NEW_K)?

//A.1.10 Constraints
constraint_declaration <- STATIC_K? CONSTRAINT_K identifier constraint_block

constraint_block <- LCURLY constraint_block_item* RCURLY

constraint_block_item <-
SOLVE_K solve_before_list BEFORE_K solve_before_list SEMI
/ constraint_expression

solve_before_list <- solve_before_primary (COMMA solve_before_primary)*

solve_before_primary <- (implicit_class_handle DOT / class_scope)? hierarchical_identifier select

constraint_expression <-
expression_or_dist SEMI
/ expression MINUS_GT constraint_set
/ IF_K LPAREN expression RPAREN constraint_set (ELSE_K constraint_set)?
/ FOREACH_K LPAREN ps_or_hierarchical_array_identifier LBRACK loop_variables RBRACK RPAREN constraint_set

constraint_set <-
constraint_expression
/ LCURLY constraint_expression* RCURLY

dist_list <- dist_item (COMMA dist_item)*

dist_item <- value_range dist_weight?

dist_weight <-
COLON_EQ expression
/ COLON_DIV expression

constraint_prototype <- constraint_prototype_qualifier? STATIC_K? CONSTRAINT_K identifier SEMI

constraint_prototype_qualifier <- EXTERN_K / PURE_K

extern_constraint_declaration <-
STATIC_K? CONSTRAINT_K class_scope identifier constraint_block

identifier_list <- identifier (COMMA identifier)*

//A.1.11 Package items
package_item <-
package_or_generate_item_declaration
/ anonymous_program
/ package_export_declaration
/ timeunits_declaration

package_or_generate_item_declaration <-
net_declaration
/ data_declaration
/ task_declaration
/ function_declaration
/ checker_declaration
/ dpi_import_export
/ extern_constraint_declaration
/ class_declaration
/ class_constructor_declaration
/ local_parameter_declaration SEMI
/ parameter_declaration SEMI
/ covergroup_declaration
/ overload_declaration
/ assertion_item_declaration
/ SEMI

anonymous_program <- PROGRAM_K SEMI anonymous_program_item* ENDPROGRAM_K

anonymous_program_item <-
task_declaration
/ function_declaration
/ class_declaration
/ covergroup_declaration
/ class_constructor_declaration
/ SEMI

//A.2 Declarations
//A.2.1 Declaration types
//A.2.1.1 Module parameter declarations
local_parameter_declaration <-
LOCALPARAM_K list_of_param_assignments
/ LOCALPARAM_K data_type_or_implicit list_of_param_assignments
/ LOCALPARAM_K TYPE_K list_of_type_assignments

parameter_declaration <-
  PARAMETER_K list_of_param_assignments
/ PARAMETER_K data_type_or_implicit list_of_param_assignments
/ PARAMETER_K TYPE_K list_of_type_assignments

specparam_declaration <-
SPECPARAM_K packed_dimension? list_of_specparam_assignments SEMI

//A.2.1.2 Port declarations
/*
 *NOTE: since net_port_type can be nil, check if match first
 */
inout_declaration <-
INOUT_K list_of_port_identifiers
/ INOUT_K net_type list_of_port_identifiers
/ INOUT_K net_port_type list_of_port_identifiers

input_declaration <-
INPUT_K list_of_port_identifiers
/ INPUT_K net_type list_of_port_identifiers
/ INPUT_K net_port_type list_of_port_identifiers
/ INPUT_K variable_port_type list_of_variable_identifiers

output_declaration <-
OUTPUT_K list_of_port_identifiers
/ OUTPUT_K net_type list_of_port_identifiers
/ OUTPUT_K net_port_type list_of_port_identifiers
/ OUTPUT_K variable_port_type list_of_variable_port_identifiers

interface_port_declaration <-
identifier list_of_interface_identifiers
/ identifier DOT identifier list_of_interface_identifiers

ref_declaration <- REF_K variable_port_type list_of_port_identifiers

//A.2.1.3 Type declarations
data_declaration <-
CONST_K? VAR_K? lifetime? data_type_or_implicit list_of_variable_decl_assignments SEMI
/ type_declaration
/ package_import_declaration
/ virtual_interface_declaration

package_import_declaration <-
IMPORT_K package_import_item (COMMA package_import_item)* SEMI

package_import_item <-
identifier COLON2 identifier
/ identifier COLON2 STAR

package_export_declaration <-
EXPORT_K STAR_COLON2_STAR SEMI
/ EXPORT_K package_import_item (COMMA package_import_item)* SEMI

genvar_declaration <- GENVAR_K list_of_genvar_identifiers SEMI

net_declaration <-
net_type (drive_strength / charge_strength)? (VECTORED_K / SCALARED_K)?  
	// Since 'ident' can be first(data_type_or_implicit) or
	// first(list_of_net_decl_assignments), we need to disambiguate.
	//ORIG: data_type_or_implicit delay3? list_of_net_decl_assignments 
	(	list_of_net_decl_assignments
	/	data_type_or_implicit delay3? list_of_net_decl_assignments
	)
	SEMI

type_declaration <-
  TYPEDEF_K identifier constant_bit_select DOT identifier identifier SEMI
/ TYPEDEF_K data_type identifier variable_dimension* SEMI
/ TYPEDEF_K (ENUM_K / STRUCT_K / UNION_K / CLASS_K)? identifier SEMI

lifetime <- STATIC_K / AUTOMATIC_K

//A.2.2 Declaration data types
//A.2.2.1 Net and variable types
//casting_type <- simple_type / constant_primary / signing / STRING_K / CONST_K

data_type <-
  integer_vector_type signing? packed_dimension*
/ integer_atom_type signing?
/ non_integer_type
/ struct_union (PACKED_K signing?)? LCURLY struct_union_member struct_union_member* RCURLY packed_dimension*
/ ENUM_K enum_base_type? LCURLY enum_name_declaration (COMMA enum_name_declaration)* RCURLY packed_dimension*
/ STRING_K
/ CHANDLE_K
/ VIRTUAL_K INTERFACE_K? identifier (DOT identifier)?
/ EVENT_K
/ type_reference
  //1st set: ident...
/ (package_scope / class_scope)? identifier packed_dimension*
  //1st set: ident...
/ class_type
  //1st set: ident...
/ ps_covergroup_identifier

/*
 *  NOTE: Since data_type 1st set has ident which could also match
 *  follow-set, get ambiguity: since we dont do semantic predicate
 *  (i.e., scope/type of ident --- which could be type).
 *  Perhaps add predicate here where it only matches 1st set ident
 *  if more follows.
 *  data_type <- &(ident ...) 
 */
data_type_or_implicit <-
data_type
/ implicit_data_type

implicit_data_type <- signing? packed_dimension*

enum_base_type <-
integer_atom_type signing?
/ integer_vector_type signing? packed_dimension?
/ identifier packed_dimension?

enum_name_declaration <- identifier (LBRACK integral_number (COLON integral_number)? RBRACK)? (EQ constant_expression)?

class_scope <- class_type COLON2
func_class_scope <- func_class_type COLON2

//TODO: need to rm ambiguity here on COLON2 identifier and punch through
//to ps_class_identifier
class_type <- ps_class_identifier parameter_value_assignment?  (COLON2 identifier parameter_value_assignment?)*
func_class_type <- func_ps_class_identifier parameter_value_assignment?  (COLON2 !function_body_declaration_follow identifier parameter_value_assignment?)*

integer_type <- integer_vector_type / integer_atom_type

integer_atom_type <- BYTE_K / SHORTINT_K / INT_K / LONGINT_K / INTEGER_K / TIME_K

integer_vector_type <- BIT_K / LOGIC_K / REG_K

non_integer_type <- SHORTREAL_K / REAL_K / REALTIME_K

net_type <- SUPPLY0_K / SUPPLY1_K / TRI_K / TRIAND_K / TRIOR_K / TRIREG_K/ TRI0_K / TRI1_K / UWIRE_K/ WIRE_K / WAND_K / WOR_K

net_port_type <- net_type? data_type_or_implicit

variable_port_type <- var_data_type

var_data_type <- data_type / VAR_K data_type_or_implicit

signing <- SIGNED_K / UNSIGNED_K

simple_type <- integer_type / non_integer_type / ps_type_identifier / ps_parameter_identifier

struct_union_member <- attribute_instance* random_qualifier? data_type_or_void list_of_variable_decl_assignments SEMI

data_type_or_void <- data_type / VOID_K

struct_union <- STRUCT_K / UNION_K TAGGED_K?

type_reference <-
TYPE_K LPAREN expression RPAREN
/ TYPE_K LPAREN data_type RPAREN

//A.2.2.2 Strengths
drive_strength <-
LPAREN strength0 COMMA strength1 RPAREN
/ LPAREN strength1 COMMA strength0 RPAREN
/ LPAREN strength0 COMMA HIGHZ1_K RPAREN
/ LPAREN strength1 COMMA HIGHZ0_K RPAREN
/ LPAREN HIGHZ0_K COMMA strength1 RPAREN
/ LPAREN HIGHZ1_K COMMA strength0 RPAREN

strength0 <- SUPPLY0_K / STRONG0_K / PULL0_K / WEAK0_K

strength1 <- SUPPLY1_K / STRONG1_K / PULL1_K / WEAK1_K

charge_strength <- LPAREN SMALL_K RPAREN / LPAREN MEDIUM_K RPAREN / LPAREN LARGE_K RPAREN

//A.2.2.3 Delays
delay3 <- 
  POUND LPAREN mintypmax_expression (COMMA mintypmax_expression (COMMA mintypmax_expression)? )? RPAREN
/ POUND delay_value 

delay2 <- 
  POUND LPAREN mintypmax_expression (COMMA mintypmax_expression)? RPAREN
/ POUND delay_value 

delay_value <-
  W1STEP_K //1step
/ real_number
/ unsigned_number
/ ps_identifier
/ time_literal

//A.2.3 Declaration lists
list_of_defparam_assignments <- defparam_assignment (COMMA defparam_assignment)*

list_of_genvar_identifiers <- identifier (COMMA identifier)*

list_of_interface_identifiers <- identifier param_assignment* (COMMA identifier param_assignment*)*
list_of_port_identifiers      <- identifier param_assignment* (COMMA identifier param_assignment*)*

list_of_net_decl_assignments <- net_decl_assignment (COMMA net_decl_assignment)*

list_of_param_assignments <- param_assignment (COMMA param_assignment)*

list_of_udp_port_identifiers <- identifier (COMMA identifier)*

list_of_specparam_assignments <- specparam_assignment (COMMA specparam_assignment)*

list_of_tf_variable_identifiers <- 
port_identifier variable_dimension* (EQ expression)?  (COMMA identifier variable_dimension* (EQ expression)?)*

list_of_type_assignments <- type_assignment (COMMA type_assignment)*

list_of_variable_decl_assignments <- variable_decl_assignment (COMMA variable_decl_assignment)*

list_of_variable_identifiers <- identifier variable_dimension* (COMMA identifier variable_dimension*)*

list_of_variable_port_identifiers <- 
identifier variable_dimension* (EQ constant_expression)?  (COMMA identifier variable_dimension* (EQ constant_expression)?)*

list_of_virtual_interface_decl <-
identifier (EQ identifier)?  (COMMA identifier (EQ identifier)?)*

//A.2.4 Declaration assignments
defparam_assignment <- hierarchical_identifier EQ constant_mintypmax_expression

net_decl_assignment <- identifier unpacked_dimension* (EQ expression)?

param_assignment <- identifier unpacked_dimension* (EQ constant_param_expression)?

specparam_assignment <-
identifier EQ constant_mintypmax_expression
/ pulse_control_specparam

type_assignment <-
identifier (EQ data_type)?

pulse_control_specparam <-
//PATHPULSE$
PATHPULSE_K EQ LPAREN reject_limit_value (COMMA error_limit_value)? RPAREN
//TODO<- what the heck is this? / PATHPULSE$specify_input_terminal_descriptor$specify_output_terminal_descriptor
//= ( reject_limit_value (COMMA error_limit_value)? )

error_limit_value <- limit_value

reject_limit_value <- limit_value

limit_value <- constant_mintypmax_expression

variable_decl_assignment <-
  identifier unsized_dimension variable_dimension?  (EQ dynamic_array_new)?
/ identifier variable_dimension? (EQ expression)?
/ identifier (EQ class_new)?

class_new <- NEW_K (LPAREN list_of_arguments RPAREN / expression)?

dynamic_array_new <- NEW_K expression? ( LPAREN expression RPAREN )?

//A.2.5 Declaration ranges
unpacked_dimension <-
LBRACK constant_range RBRACK
/ LBRACK constant_expression RBRACK

packed_dimension <-
LBRACK constant_range RBRACK
/ unsized_dimension

associative_dimension <-
LBRACK data_type RBRACK
/ LBRACK STAR RBRACK

variable_dimension <-
unsized_dimension
/ unpacked_dimension
/ associative_dimension
/ queue_dimension

queue_dimension <- LBRACK DOLLAR ( COLON constant_expression )? RBRACK

unsized_dimension <- LBRACK RBRACK

//A.2.6 Function declarations
function_data_type_or_implicit <-
data_type_or_void
/ implicit_data_type

function_declaration <- FUNCTION_K ( lifetime )? function_body_declaration

function_body_declaration_follow <- identifier (LPAREN / SEMI)

function_body_declaration <-
  function_data_type_or_implicit
	( identifier DOT / func_class_scope )? identifier LPAREN ( tf_port_list )? RPAREN SEMI
	( block_item_declaration )*
	( function_statement_or_null )*
	ENDFUNCTION_K ( COLON identifier )?
/ function_data_type_or_implicit
	( identifier DOT / func_class_scope )? identifier SEMI
	( tf_item_declaration )*
	( function_statement_or_null )*
	ENDFUNCTION_K ( COLON identifier )?

function_prototype <- FUNCTION_K data_type_or_void identifier LPAREN ( tf_port_list )? RPAREN

dpi_import_export <-
  IMPORT_K dpi_spec_string ( dpi_function_import_property )? ( c_identifier EQ )? dpi_function_proto SEMI
/ IMPORT_K dpi_spec_string ( dpi_task_import_property )? ( c_identifier EQ )? dpi_task_proto SEMI
/ EXPORT_K dpi_spec_string ( c_identifier EQ )? FUNCTION_K identifier SEMI
/ EXPORT_K dpi_spec_string ( c_identifier EQ )? TASK_K identifier SEMI

dpi_spec_string <- STRING //"DPI-C" / "DPI"

dpi_function_import_property <- CONTEXT_K / PURE_K

dpi_task_import_property <- CONTEXT_K

dpi_function_proto <- function_prototype

dpi_task_proto <- task_prototype

//A.2.7 Task declarations
task_declaration <- TASK_K ( lifetime )? task_body_declaration

task_body_declaration <-
  ( identifier DOT / class_scope )? identifier LPAREN ( tf_port_list )? RPAREN SEMI
	( block_item_declaration )*
	( statement_or_null )*
	ENDTASK_K ( COLON identifier )?
/ ( identifier DOT / class_scope )? identifier SEMI
	( tf_item_declaration )*
	( statement_or_null )*
	ENDTASK_K ( COLON identifier )?

tf_item_declaration <-
block_item_declaration
/ tf_port_declaration

tf_port_list <- tf_port_item ( COMMA tf_port_item )*

tf_port_item <- 
( attribute_instance )* ( tf_port_direction )? ( VAR_K )? data_type_or_implicit 
	( identifier ( variable_dimension )* ( EQ expression )? )?

tf_port_direction <- port_direction / CONST_K REF_K

tf_port_declaration <- ( attribute_instance )* tf_port_direction ( VAR_K )? data_type_or_implicit list_of_tf_variable_identifiers SEMI

task_prototype <- TASK_K identifier LPAREN ( tf_port_list )? RPAREN

//A.2.8 Block item declarations
block_item_declaration <-
  ( attribute_instance )* local_parameter_declaration SEMI
/ ( attribute_instance )* let_declaration
/ ( attribute_instance )* parameter_declaration SEMI
/ ( attribute_instance )* data_declaration
/ ( attribute_instance )* overload_declaration

overload_declaration <-
BIND_K overload_operator FUNCTION_K data_type identifier LPAREN overload_proto_formals RPAREN SEMI

overload_operator <- PLUS / PLUS2 / MINUS / MINUS2 / STAR / STAR2 / DIV / MOD / EQ2 / NOT_EQ / LT / LT_EQ / GT / GT_EQ / EQ

overload_proto_formals <- data_type (COMMA data_type)*

//A.2.9 Interface declarations
virtual_interface_declaration <-
VIRTUAL_K ( INTERFACE_K )? identifier ( parameter_value_assignment)? (DOT identifier)?
	list_of_virtual_interface_decl SEMI

modport_declaration <- MODPORT_K modport_item ( COMMA modport_item )* SEMI

modport_item <- identifier LPAREN modport_ports_declaration ( COMMA modport_ports_declaration )* RPAREN

modport_ports_declaration <-
( attribute_instance )* modport_simple_ports_declaration
/ ( attribute_instance )* modport_tf_ports_declaration
/ ( attribute_instance )* modport_clocking_declaration

modport_clocking_declaration <- CLOCKING_K identifier

modport_simple_ports_declaration <-
port_direction modport_simple_port ( COMMA modport_simple_port )*

modport_simple_port <-
  DOT identifier LPAREN ( expression )? RPAREN
/ identifier

modport_tf_ports_declaration <- import_export modport_tf_port ( COMMA modport_tf_port )*

modport_tf_port <-
method_prototype
/ identifier

import_export <- IMPORT_K / EXPORT_K

//A.2.10 Assertion declarations
concurrent_assertion_item <-
( identifier COLON )? concurrent_assertion_statement
/ checker_instantiation

concurrent_assertion_statement <-
assert_property_statement
/ assume_property_statement
/ cover_property_statement
/ cover_sequence_statement
/ restrict_property_statement

assert_property_statement<- ASSERT_K PROPERTY_K LPAREN property_spec RPAREN action_block

assume_property_statement<- ASSUME_K PROPERTY_K LPAREN property_spec RPAREN action_block

cover_property_statement<- COVER_K PROPERTY_K LPAREN property_spec RPAREN statement_or_null

expect_property_statement <- EXPECT_K LPAREN property_spec RPAREN action_block

cover_sequence_statement<-
COVER_K SEQUENCE_K LPAREN (clocking_event )? ( DISABLE_K IFF_K LPAREN expression_or_dist RPAREN )?
	sequence_expr RPAREN statement_or_null

restrict_property_statement<- RESTRICT_K PROPERTY_K LPAREN property_spec RPAREN SEMI

property_instance <- ps_or_hierarchical_property_identifier ( LPAREN ( property_list_of_arguments )? RPAREN )?

property_list_of_arguments <-
  DOT identifier LPAREN (property_actual_arg)? RPAREN ( COMMA DOT identifier LPAREN (property_actual_arg)? RPAREN )*
/ (property_actual_arg)? ( COMMA (property_actual_arg)? )* ( COMMA DOT identifier LPAREN (property_actual_arg)? RPAREN )*

property_actual_arg <-
property_expr
/ sequence_actual_arg

assertion_item_declaration <-
property_declaration
/ sequence_declaration
/ let_declaration

property_declaration <-
PROPERTY_K identifier ( LPAREN ( property_port_list )? RPAREN )? SEMI
	( assertion_variable_declaration )*
	property_statement_spec
	ENDPROPERTY_K ( COLON identifier )?

property_port_list <- property_port_item (COMMA property_port_item)*

property_port_item <-
( attribute_instance )* ( LOCAL_K ( property_lvar_port_direction )? )? property_formal_type
	identifier (variable_dimension)* ( EQ property_actual_arg )?

property_lvar_port_direction <- INPUT_K

property_formal_type <-
sequence_formal_type
/ PROPERTY_K

property_spec <- (clocking_event )? ( DISABLE_K IFF_K LPAREN expression_or_dist RPAREN )? property_expr

property_statement_spec <- ( clocking_event )? ( DISABLE_K IFF_K LPAREN expression_or_dist RPAREN )? property_statement

property_statement <-
  CASE_K LPAREN expression_or_dist RPAREN property_case_item ( property_case_item )* ENDCASE_K
/ IF_K LPAREN expression_or_dist RPAREN property_expr ( ELSE_K property_expr )?
/ property_expr SEMI

property_case_item<-
  DEFAULT_K ( COLON )? property_statement
/ expression_or_dist ( COMMA expression_or_dist )* COLON property_statement

property_expr <-
property_expr OR_K property_expr
/ property_expr UNTIL_K property_expr
/ property_expr S_UNTIL_K property_expr
/ property_expr UNTIL_WITH_K property_expr
/ property_expr S_UNTIL_WITH_K property_expr
/ property_expr IMPLIES_K property_expr
/ property_expr IFF_K property_expr
/ property_expr AND_K property_expr
//NOTE: causes left recursion.  Not clear where this is need.  / property_statement
/ sequence_expr BAR_MINUS_GT property_expr
/ sequence_expr BAR_EQ_GT property_expr
/ sequence_expr POUND_MINUS_POUND property_expr
/ sequence_expr POUND_EQ_POUND property_expr
/ sequence_expr
/ STRONG_K LPAREN sequence_expr RPAREN
/ WEAK_K LPAREN sequence_expr RPAREN
/ LPAREN property_expr RPAREN
/ NOT_K property_expr
/ NEXTTIME_K property_expr
/ NEXTTIME_K ( constant_expression )? property_expr
/ S_NEXTTIME_K property_expr
/ S_NEXTTIME_K ( constant_expression )? property_expr
/ ALWAYS_K property_expr
/ ALWAYS_K ( cycle_delay_const_range_expression )? property_expr
/ S_ALWAYS_K ( constant_range)? property_expr
/ S_EVENTUALLY_K property_expr
/ EVENTUALLY_K ( constant_range )? property_expr
/ S_EVENTUALLY_K ( cycle_delay_const_range_expression )? property_expr
/ ACCEPT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ REJECT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ SYNC_ACCEPT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ SYNC_REJECT_ON_K LPAREN expression_or_dist RPAREN property_expr
/ property_instance
/ clocking_event property_expr

sequence_declaration <-
SEQUENCE_K identifier ( LPAREN ( sequence_port_list )? RPAREN )? SEMI
	( assertion_variable_declaration )*
	sequence_expr SEMI
	ENDSEQUENCE_K ( COLON identifier )?

sequence_port_list <- sequence_port_item (COMMA sequence_port_item)*

sequence_port_item <-
( attribute_instance )* ( LOCAL_K ( sequence_lvar_port_direction )? )? sequence_formal_type
	identifier (variable_dimension)* ( EQ sequence_actual_arg )?

sequence_lvar_port_direction <- INPUT_K / INOUT_K / OUTPUT_K

sequence_formal_type <-
  SEQUENCE_K
/ EVENT_K
/ UNTYPED_K
/ data_type_or_implicit

sequence_expr <-
//NOTE: covered by right recursion: 
//sequence_expr cycle_delay_range sequence_expr ( cycle_delay_range sequence_expr )*
sequence_expr cycle_delay_range sequence_expr
/ sequence_expr AND_K sequence_expr
/ sequence_expr INTERSECT_K sequence_expr
/ sequence_expr OR_K sequence_expr
/ sequence_expr WITHIN_K sequence_expr
/ cycle_delay_range sequence_expr ( cycle_delay_range sequence_expr )*
/ expression_or_dist ( boolean_abbrev )?
/ sequence_instance ( sequence_abbrev )?
/ LPAREN sequence_expr (COMMA sequence_match_item )* RPAREN ( sequence_abbrev )?
/ FIRST_MATCH_K LPAREN sequence_expr (COMMA sequence_match_item)* RPAREN
/ expression_or_dist THROUGHOUT_K sequence_expr
/ clocking_event sequence_expr

cycle_delay_range <-
  POUND2 LBRACK cycle_delay_const_range_expression RBRACK
/ POUND2 LBRACK STAR RBRACK
/ POUND2 LBRACK PLUS RBRACK
/ POUND2 constant_primary

sequence_method_call <- sequence_instance DOT identifier

sequence_match_item <-
operator_assignment
/ inc_or_dec_expression
/ subroutine_call

sequence_instance <- ps_or_hierarchical_sequence_identifier ( LPAREN ( sequence_list_of_arguments )? RPAREN )?

sequence_list_of_arguments <-
  DOT identifier LPAREN (sequence_actual_arg)? RPAREN ( COMMA DOT identifier LPAREN (sequence_actual_arg)? RPAREN )*
/ (sequence_actual_arg)? ( COMMA (sequence_actual_arg)? )* ( COMMA DOT identifier LPAREN (sequence_actual_arg)? RPAREN )*

sequence_actual_arg <-
event_expression
/ sequence_expr

boolean_abbrev <-
consecutive_repetition
/ non_consecutive_repetition
/ goto_repetition

sequence_abbrev <- consecutive_repetition

consecutive_repetition <-
LBRACK STAR const_or_range_expression RBRACK
/ LBRACK STAR RBRACK
/ LBRACK PLUS RBRACK

non_consecutive_repetition <- LBRACK EQ const_or_range_expression RBRACK

goto_repetition <- LBRACK MINUS_GT const_or_range_expression RBRACK

const_or_range_expression <-
constant_expression
/ cycle_delay_const_range_expression

cycle_delay_const_range_expression <-
constant_expression COLON constant_expression
/ constant_expression COLON DOLLAR

expression_or_dist <- expression ( DIST_K LCURLY dist_list RCURLY )?

assertion_variable_declaration <- var_data_type list_of_variable_decl_assignments SEMI

let_declaration <- LET_K let_identifier ( LPAREN ( let_port_list )? RPAREN )? EQ expression SEMI

let_identifier <- identifier

let_port_list <- let_port_item (COMMA let_port_item)*

let_port_item <- ( attribute_instance )* let_formal_type identifier ( variable_dimension )* ( EQ expression )?

let_formal_type <- data_type_or_implicit

let_expression <- ( package_scope )? let_identifier ( LPAREN ( let_list_of_arguments )? RPAREN )?

let_list_of_arguments <-
  DOT identifier LPAREN ( let_actual_arg )? RPAREN ( COMMA DOT identifier LPAREN ( let_actual_arg )? RPAREN )*
/ ( let_actual_arg )? (COMMA ( let_actual_arg )? )* (COMMA DOT identifier LPAREN ( let_actual_arg )? RPAREN )*

let_actual_arg <- expression

//A.2.11 Covergroup declarations
covergroup_declaration <-
COVERGROUP_K identifier ( LPAREN ( tf_port_list )? RPAREN )? ( coverage_event )? SEMI
	( coverage_spec_or_option )*
	ENDGROUP_K ( COLON identifier )?

coverage_spec_or_option <-
  (attribute_instance)* coverage_option SEMI
/ (attribute_instance)* coverage_spec

coverage_option <-
//option
IDENT DOT identifier EQ expression
//option_type
/ IDENT DOT identifier EQ constant_expression

coverage_spec <-
cover_point
/ cover_cross

coverage_event <-
  WITH_K FUNCTION_K IDENT LPAREN ( tf_port_list )? RPAREN
/ AT2 LPAREN block_event_expression RPAREN
/ clocking_event	//IDENT ==> sample (but not a keyword)

block_event_expression <-
  block_event_expression OR_K block_event_expression
/ BEGIN_K hierarchical_btf_identifier
/ END_K hierarchical_btf_identifier

hierarchical_btf_identifier <-
  hierarchical_identifier ( class_scope )? identifier
/ hierarchical_identifier

cover_point <- ( identifier COLON )? COVERPOINT_K expression ( IFF_K LPAREN expression RPAREN )? bins_or_empty

bins_or_empty <-
LCURLY (attribute_instance)* ( bins_or_options SEMI )* RCURLY
/ SEMI

bins_or_options <-
coverage_option
/ bins_keyword identifier EQ DEFAULT_K SEQUENCE_K ( IFF_K LPAREN expression RPAREN )?
/ ( WILDCARD_K )? bins_keyword identifier ( LBRACK ( expression )? RBRACK )? EQ 
	LCURLY open_range_list RCURLY ( IFF_K LPAREN expression RPAREN )?
/ ( WILDCARD_K )? bins_keyword identifier ( RBRACK RBRACK )? EQ trans_list ( IFF_K LPAREN expression RPAREN )?
/ bins_keyword identifier ( LBRACK ( expression )? RBRACK )? EQ DEFAULT_K ( IFF_K LPAREN expression RPAREN )?

bins_keyword<- BINS_K / ILLEGAL_BINS_K / IGNORE_BINS_K

range_list <- value_range ( COMMA value_range )*

trans_list <- LPAREN trans_set RPAREN ( COMMA LPAREN trans_set RPAREN )*

trans_set <- trans_range_list ( EQ_GT trans_range_list )*

trans_range_list <-
  trans_item LBRACK STAR repeat_range RBRACK
/ trans_item LBRACK MINUS_GT repeat_range RBRACK
/ trans_item LBRACK EQ repeat_range RBRACK
/ trans_item

trans_item <- range_list

repeat_range <-
  expression COLON expression
/ expression

cover_cross <- ( identifier COLON )? CROSS_K list_of_coverpoints ( IFF_K LPAREN expression RPAREN )? select_bins_or_empty

list_of_coverpoints <- cross_item COMMA cross_item ( COMMA cross_item )*

cross_item <-
identifier

select_bins_or_empty <-
LCURLY ( bins_selection_or_option SEMI )* RCURLY
/ SEMI

bins_selection_or_option <-
( attribute_instance )* coverage_option
/ ( attribute_instance )* bins_selection

bins_selection <- bins_keyword identifier EQ select_expression ( IFF_K LPAREN expression RPAREN )?

select_expression <-
select_expression AND2 select_expression
/ select_expression OR2 select_expression
/ select_condition
/ NOT select_condition
/ LPAREN select_expression RPAREN

select_condition <- BINSOF_K LPAREN bins_expression RPAREN ( INTERSECT_K LCURLY open_range_list RCURLY )?

bins_expression <-
  identifier ( DOT identifier )?
/ identifier

open_range_list <- open_value_range ( COMMA open_value_range )*

open_value_range <- value_range

//A.3 Primitive instances
//A.3.1 Primitive instantiation and instances

//Greatly simplified this rather archaic/arcane detail
gate_instantiation <-
	(	cmos_switchtype / enable_gatetype / mos_switchtype / n_input_gatetype 
	/ 	n_output_gatetype / pass_en_switchtype / pass_switchtype
	/	PULLDOWN_K / PULLUP_K
	)
	(drive_strength)? (delay3)?
	gate_instance (COMMA gate_instance)* SEMI

gate_instance <-
	( name_of_instance )? LPAREN gate_terminal ( COMMA gate_terminal )* RPAREN

gate_terminal <-
  expression
/ net_lvalue

//A.3.2 Primitive strengths

//A.3.3 Primitive terminals
input_terminal <- expression

output_terminal <- net_lvalue

//A.3.4 Primitive gate and switch types
cmos_switchtype <- CMOS_K / RCMOS_K

enable_gatetype <- BUFIF0_K / BUFIF1_K / NOTIF0_K / NOTIF1_K

mos_switchtype <- NMOS_K / PMOS_K / RNMOS_K / RPMOS_K

n_input_gatetype <- AND_K / NAND_K / OR_K / NOR_K / XOR_K / XNOR_K

n_output_gatetype <- BUF_K / NOT_K

pass_en_switchtype <- TRANIF0_K / TRANIF1_K / RTRANIF1_K / RTRANIF0_K

pass_switchtype <- TRAN_K / RTRAN_K

//A.4 Instantiations
//A.4.1 Instantiation
//A.4.1.1 Module instantiation
module_instantiation <-
identifier ( parameter_value_assignment )? hierarchical_instance ( COMMA hierarchical_instance )* SEMI

parameter_value_assignment <- POUND LPAREN ( list_of_parameter_assignments )? RPAREN

list_of_parameter_assignments <-
  named_parameter_assignment ( COMMA named_parameter_assignment )*
/ ordered_parameter_assignment ( COMMA ordered_parameter_assignment )*

ordered_parameter_assignment <- param_expression

named_parameter_assignment <- DOT identifier LPAREN ( param_expression )? RPAREN

hierarchical_instance <- name_of_instance LPAREN ( list_of_port_connections )? RPAREN

name_of_instance <- identifier ( unpacked_dimension )*

list_of_port_connections <-
  named_port_connection ( COMMA named_port_connection )*
/ ordered_port_connection ( COMMA ordered_port_connection )*

ordered_port_connection <- ( attribute_instance )* ( expression )?

named_port_connection <-
( attribute_instance )* DOT identifier ( LPAREN ( expression )? RPAREN )?
/ ( attribute_instance )* DOT_STAR

//A.4.1.2 Interface instantiation
interface_instantiation <-
identifier ( parameter_value_assignment )? hierarchical_instance ( COMMA hierarchical_instance )* SEMI

//A.4.1.3 Program instantiation
program_instantiation <-
identifier ( parameter_value_assignment )? hierarchical_instance ( COMMA hierarchical_instance )* SEMI

//A.4.1.4 Checker instantiation
checker_instantiation <-
identifier name_of_instance LPAREN (list_of_checker_port_connections)? RPAREN SEMI

list_of_checker_port_connections <-
ordered_checker_port_connection ( COMMA ordered_checker_port_connection )*
/ named_checker_port_connection ( COMMA named_checker_port_connection )*

ordered_checker_port_connection <- ( attribute_instance )* ( property_actual_arg )?

named_checker_port_connection <-
( attribute_instance )* DOT identifier ( LPAREN ( property_actual_arg )? RPAREN )?
/ ( attribute_instance )* DOT_STAR

//A.4.2 Generated instantiation
generate_region <-
GENERATE_K ( generate_item )* ENDGENERATE_K

loop_generate_construct <-
FOR_K LPAREN genvar_initialization SEMI genvar_expression SEMI genvar_iteration RPAREN
generate_block

genvar_initialization <-
( GENVAR_K )? identifier EQ constant_expression

genvar_iteration <-
identifier assignment_operator genvar_expression
/ inc_or_dec_operator identifier
/ identifier inc_or_dec_operator

conditional_generate_construct <-
if_generate_construct
/ case_generate_construct

if_generate_construct <-
IF_K LPAREN constant_expression RPAREN generate_block ( ELSE_K generate_block )?

case_generate_construct <-
CASE_K LPAREN constant_expression RPAREN case_generate_item ( case_generate_item )* ENDCASE_K

case_generate_item <-
  DEFAULT_K ( COLON )? generate_block
/ constant_expression ( COMMA constant_expression )* COLON generate_block

generate_block <-
  ( identifier COLON )? BEGIN_K ( COLON identifier )?
	( generate_item )*
	END_K ( COLON identifier )?
/ generate_item

generate_item <-
module_or_generate_item
/ interface_or_generate_item
/ checker_or_generate_item

//A.5 UDP declaration and instantiation
//A.5.1 UDP declaration
udp_nonansi_declaration <- ( attribute_instance )* PRIMITIVE_K identifier LPAREN udp_port_list RPAREN SEMI

udp_ansi_declaration <- ( attribute_instance )* PRIMITIVE_K identifier LPAREN udp_declaration_port_list RPAREN SEMI

udp_declaration <-
  udp_ansi_declaration
	udp_body
	ENDPRIMITIVE_K ( COLON identifier )?
/ udp_nonansi_declaration udp_port_declaration ( udp_port_declaration )*
	udp_body
	ENDPRIMITIVE_K ( COLON identifier )?
/ EXTERN_K udp_ansi_declaration
/ EXTERN_K udp_nonansi_declaration
/ ( attribute_instance )* PRIMITIVE_K identifier LPAREN DOT_STAR RPAREN SEMI
	( udp_port_declaration )*
	udp_body
	ENDPRIMITIVE_K ( COLON identifier )?

//A.5.2 UDP ports
udp_port_list <- identifier COMMA identifier ( COMMA identifier )*

udp_declaration_port_list <- udp_output_declaration COMMA udp_input_declaration ( COMMA udp_input_declaration )*

udp_port_declaration <-
udp_output_declaration SEMI
/ udp_input_declaration SEMI
/ udp_reg_declaration SEMI

udp_output_declaration <-
  ( attribute_instance )* OUTPUT_K REG_K identifier ( EQ constant_expression )?
/ ( attribute_instance )* OUTPUT_K identifier

udp_input_declaration <- ( attribute_instance )* INPUT_K list_of_udp_port_identifiers

udp_reg_declaration <- ( attribute_instance )* REG_K identifier

//A.5.3 UDP body
udp_body <- combinational_body / sequential_body

combinational_body <- TABLE_K combinational_entry ( combinational_entry )* ENDTABLE_K

combinational_entry <- level_input_list COLON output_symbol SEMI

sequential_body <- ( udp_initial_statement )? TABLE_K sequential_entry ( sequential_entry )* ENDTABLE_K

udp_initial_statement <- INITIAL_K identifier EQ init_val SEMI

init_val <- ("1'" [bB] [01xX]) / [01]

sequential_entry <- seq_input_list COLON current_state COLON next_state SEMI

seq_input_list <- level_input_list / edge_input_list

level_input_list <- level_symbol ( level_symbol )*

edge_input_list <- ( level_symbol )* edge_indicator ( level_symbol )*

edge_indicator <- LPAREN level_symbol level_symbol RPAREN / edge_symbol

current_state <- level_symbol

next_state <- output_symbol / MINUS

output_symbol <- [01xX]

level_symbol <- [01xX?bB]

edge_symbol <- [rRfFpPnN*]

//A.5.4 UDP instantiation
udp_instantiation <- identifier ( drive_strength )? ( delay2 )? udp_instance ( COMMA udp_instance )* SEMI

udp_instance <- ( name_of_instance )? LPAREN output_terminal COMMA input_terminal ( COMMA input_terminal )* RPAREN

//A.6 Behavioral statements
//A.6.1 Continuous assignment and net alias statements
continuous_assign <-
ASSIGN_K ( drive_strength )? ( delay3 )? list_of_net_assignments SEMI
/ ASSIGN_K ( delay_control )? list_of_variable_assignments SEMI

list_of_net_assignments <- net_assignment ( COMMA net_assignment )*

list_of_variable_assignments <- variable_assignment ( COMMA variable_assignment )*

net_alias <- ALIAS_K net_lvalue EQ net_lvalue ( EQ net_lvalue )* SEMI

net_assignment <- net_lvalue EQ expression

//A.6.2 Procedural blocks and assignments
initial_construct <- INITIAL_K statement_or_null

always_construct <- always_keyword statement

always_keyword <- 
ALWAYS_COMB_K 
/ ALWAYS_LATCH_K 
/ ALWAYS_FF_K
/ ALWAYS_K 

final_construct <- FINAL_K function_statement

blocking_assignment <-
variable_lvalue EQ delay_or_event_control expression
/ ( implicit_class_handle DOT / package_scope / class_scope )? hierarchical_identifier select EQ class_new
/ nonrange_variable_lvalue EQ dynamic_array_new
/ operator_assignment

operator_assignment <- variable_lvalue assignment_operator expression

assignment_operator <-
EQ / PLUS_EQ / MINUS_EQ / STAR_EQ / DIV_EQ / MOD_EQ / AND_EQ / OR_EQ / XOR_EQ / LT2_EQ / GT2_EQ / LT3_EQ / GT3_EQ

nonblocking_assignment <-
variable_lvalue LT_EQ ( delay_or_event_control )? expression

procedural_continuous_assignment <-
ASSIGN_K variable_assignment
/ DEASSIGN_K variable_lvalue
/ FORCE_K variable_assignment
/ FORCE_K net_assignment
/ RELEASE_K variable_lvalue
/ RELEASE_K net_lvalue

variable_assignment <- variable_lvalue EQ expression

//A.6.3 Parallel and sequential blocks
action_block <-
  ( statement )? ELSE_K statement_or_null
/ statement_or_null

seq_block <-
BEGIN_K ( COLON identifier )? ( block_item_declaration )* ( statement_or_null )* END_K ( COLON identifier )?

par_block <-
FORK_K ( COLON identifier )? ( block_item_declaration )* ( statement_or_null )* join_keyword ( COLON identifier )?

join_keyword <- JOIN_K / JOIN_ANY_K / JOIN_NONE_K

//A.6.4 Statements
statement_or_null <-
statement
/ ( attribute_instance )* SEMI

statement <- ( identifier COLON )? ( attribute_instance )* statement_item

statement_item <-
blocking_assignment SEMI
/ nonblocking_assignment SEMI
/ procedural_continuous_assignment SEMI
/ case_statement
/ conditional_statement
/ inc_or_dec_expression SEMI
/ subroutine_call_statement
/ disable_statement
/ event_trigger
/ loop_statement
/ jump_statement
/ par_block
/ procedural_timing_control_statement
/ seq_block
/ wait_statement
/ procedural_assertion_statement
/ clocking_drive SEMI
/ randsequence_statement
/ randcase_statement
/ expect_property_statement

function_statement <- statement

function_statement_or_null <-
function_statement
/ ( attribute_instance )* SEMI

variable_identifier_list <- identifier ( COMMA identifier )*

//A.6.5 Timing control statements
procedural_timing_control_statement <- procedural_timing_control statement_or_null

delay_or_event_control <-
  REPEAT_K LPAREN expression RPAREN event_control
/ delay_control
/ event_control

delay_control <-
  POUND LPAREN mintypmax_expression RPAREN
/ POUND delay_value

event_control <-
  AT LPAREN event_expression RPAREN
/ AT_STAR
/ AT LPAREN STAR RPAREN
/ AT hierarchical_identifier
/ AT ps_or_hierarchical_sequence_identifier

event_expression <-
  event_expression OR_K event_expression
/ event_expression COMMA event_expression
/ LPAREN event_expression RPAREN
/ ( edge_identifier )? expression ( IFF_K expression )?
/ sequence_instance ( IFF_K expression )?

procedural_timing_control <-
delay_control
/ event_control
/ cycle_delay

jump_statement <-
RETURN_K ( expression )? SEMI
/ BREAK_K SEMI
/ CONTINUE_K SEMI

wait_statement <-
  WAIT_ORDER_K LPAREN hierarchical_identifier ( COMMA hierarchical_identifier )* RPAREN action_block
/ WAIT_K LPAREN expression RPAREN statement_or_null
/ WAIT_K FORK_K SEMI

event_trigger <-
  MINUS_GT2 ( delay_or_event_control )? hierarchical_identifier SEMI
/ MINUS_GT  hierarchical_identifier SEMI

disable_statement <-
  DISABLE_K FORK_K SEMI
/ DISABLE_K hierarchical_identifier SEMI

//A.6.6 Conditional statements
conditional_statement <-
( unique_priority )? IF_K LPAREN cond_predicate RPAREN statement_or_null
	( ELSE_K IF_K LPAREN cond_predicate RPAREN statement_or_null )*
	( ELSE_K statement_or_null )?

unique_priority <- UNIQUE_K / UNIQUE0_K/ PRIORITY_K

cond_predicate <- expression_or_cond_pattern ( AND3 expression_or_cond_pattern )*

// FIXED
// Error: cond_pattern: rule is indirect left-recursive: path 'cond_pattern->expression->conditional_expression->cond_predicate->expression_or_cond_pattern->cond_pattern'.  (LR-2)
// expression_or_cond_pattern <-
// expression / cond_pattern
// cond_pattern <- expression MATCHES_K pattern
expression_or_cond_pattern <- expression (MATCHES_K pattern)?
// / expression 

//A.6.7 Case statements
case_statement <-
  ( unique_priority )? case_keyword LPAREN case_expression RPAREN MATCHES_K case_pattern_item ( case_pattern_item )* ENDCASE_K
/ ( unique_priority )? CASE_K LPAREN case_expression RPAREN INSIDE_K case_inside_item ( case_inside_item )* ENDCASE_K
/ ( unique_priority )? case_keyword LPAREN case_expression RPAREN case_item ( case_item )* ENDCASE_K

case_keyword <- CASEZ_K / CASEX_K / CASE_K

case_expression <- expression

case_item <-
case_item_expression ( COMMA case_item_expression )* COLON statement_or_null
/ DEFAULT_K ( COLON )? statement_or_null

case_pattern_item <-
pattern ( AND3 expression )? COLON statement_or_null
/ DEFAULT_K ( COLON )? statement_or_null

case_inside_item <-
open_range_list COLON statement_or_null
/ DEFAULT_K ( COLON )? statement_or_null

case_item_expression <- expression

randcase_statement <- RANDCASE_K randcase_item ( randcase_item )* ENDCASE_K

randcase_item <- expression COLON statement_or_null

//A.6.7.1 Patterns
pattern <-
  DOT_STAR
/ TAGGED_K identifier ( pattern )?
/ SQUOTE LCURLY identifier COLON pattern ( COMMA identifier COLON pattern )* RCURLY
/ SQUOTE LCURLY pattern ( COMMA pattern )* RCURLY
/ DOT identifier
/ constant_expression

assignment_pattern <-
  SQUOTE LCURLY structure_pattern_key COLON expression ( COMMA structure_pattern_key COLON expression )* RCURLY
/ SQUOTE LCURLY array_pattern_key COLON expression ( COMMA array_pattern_key COLON expression )* RCURLY
/ SQUOTE LCURLY constant_expression LCURLY expression ( COMMA expression )* RCURLY RCURLY
/ SQUOTE LCURLY expression ( COMMA expression )* RCURLY

structure_pattern_key <- identifier / assignment_pattern_key

array_pattern_key <- constant_expression / assignment_pattern_key

assignment_pattern_key <- simple_type / DEFAULT_K

assignment_pattern_expression <- ( assignment_pattern_expression_type )? assignment_pattern

assignment_pattern_expression_type <-
ps_type_identifier
/ ps_parameter_identifier
/ integer_atom_type
/ type_reference

constant_assignment_pattern_expression <- assignment_pattern_expression

assignment_pattern_net_lvalue <- SQUOTE LCURLY net_lvalue (COMMA net_lvalue )* RCURLY

assignment_pattern_variable_lvalue <- SQUOTE LCURLY variable_lvalue (COMMA variable_lvalue )* RCURLY

//A.6.8 Looping statements
loop_statement <-
FOREVER_K statement_or_null
/ REPEAT_K LPAREN expression RPAREN statement_or_null
/ WHILE_K LPAREN expression RPAREN statement_or_null
/ FOR_K LPAREN for_initialization SEMI expression SEMI for_step RPAREN statement_or_null
/ DO_K statement_or_null WHILE_K LPAREN expression RPAREN SEMI
/ FOREACH_K LPAREN ps_or_hierarchical_array_identifier LBRACK loop_variables RBRACK RPAREN statement

for_initialization <-
list_of_variable_assignments
/ for_variable_declaration ( COMMA for_variable_declaration )*

for_variable_declaration <-
data_type identifier EQ expression ( COMMA identifier EQ expression )*

for_step <- for_step_assignment ( COMMA for_step_assignment )*

for_step_assignment <-
operator_assignment
/ inc_or_dec_expression
// / function_subroutine_call
/ subroutine_call

loop_variables <- ( identifier )? ( COMMA ( identifier )? )*

//A.6.9 Subroutine call statements
subroutine_call_statement <-
  VOID_K SQUOTE LPAREN 
	//function_subroutine_call 
	subroutine_call
	RPAREN SEMI
/ subroutine_call SEMI

//A.6.10 Assertion statements
assertion_item <-
concurrent_assertion_item
/ deferred_immediate_assertion_item

deferred_immediate_assertion_item <- ( identifier COLON )? deferred_immediate_assertion_statement

procedural_assertion_statement <-
concurrent_assertion_statement
/ immediate_assertion_statement
/ checker_instantiation

immediate_assertion_statement <-
simple_immediate_assertion_statement
/ deferred_immediate_assertion_statement

simple_immediate_assertion_statement <-
simple_immediate_assert_statement
/ simple_immediate_assume_statement
/ simple_immediate_cover_statement

simple_immediate_assert_statement <- ASSERT_K LPAREN expression RPAREN action_block

simple_immediate_assume_statement <- ASSUME_K LPAREN expression RPAREN action_block

simple_immediate_cover_statement <- COVER_K LPAREN expression RPAREN statement_or_null

deferred_immediate_assertion_statement <-
deferred_immediate_assert_statement
/ deferred_immediate_assume_statement
/ deferred_immediate_cover_statement

deferred_immediate_assert_statement <- ASSERT_K POUND DIGIT LPAREN expression RPAREN action_block

deferred_immediate_assume_statement <- ASSUME_K POUND DIGIT LPAREN expression RPAREN action_block

deferred_immediate_cover_statement <- COVER_K POUND DIGIT LPAREN expression RPAREN statement_or_null

//A.6.11 Clocking block
clocking_declaration <- 
  GLOBAL_K CLOCKING_K ( identifier )? clocking_event SEMI ENDCLOCKING_K ( COLON identifier )?
/ (DEFAULT_K)? CLOCKING_K ( identifier )? clocking_event SEMI ( clocking_item )* ENDCLOCKING_K ( COLON identifier )?

clocking_event <-
  AT LPAREN event_expression RPAREN
/ AT identifier

clocking_item <-
DEFAULT_K default_skew SEMI
/ clocking_direction list_of_clocking_decl_assign SEMI
/ ( attribute_instance )* assertion_item_declaration

default_skew <-
  INPUT_K clocking_skew OUTPUT_K clocking_skew
/ INPUT_K clocking_skew
/ OUTPUT_K clocking_skew

clocking_direction <-
  INPUT_K ( clocking_skew )? OUTPUT_K ( clocking_skew )?
/ INPUT_K ( clocking_skew )?
/ OUTPUT_K ( clocking_skew )?
/ INOUT_K

list_of_clocking_decl_assign <- clocking_decl_assign ( COMMA clocking_decl_assign )*

clocking_decl_assign <- identifier ( EQ expression )?

clocking_skew <-
edge_identifier ( delay_control )?
/ delay_control

clocking_drive <- clockvar_expression LT_EQ ( cycle_delay )? expression

cycle_delay <-
  POUND2 LPAREN expression RPAREN
/ POUND2 integral_number
/ POUND2 identifier

clockvar <- hierarchical_identifier

clockvar_expression <- clockvar select

//A.6.12 Randsequence
randsequence_statement <- RANDSEQUENCE_K LPAREN ( identifier )? RPAREN production ( production )* ENDSEQUENCE_K

production <- ( data_type_or_void )? identifier ( LPAREN tf_port_list RPAREN )? COLON rs_rule ( OR rs_rule )* SEMI

rs_rule <- rs_production_list ( COLON_EQ weight_specification ( rs_code_block )? )?

rs_production_list <-
  RAND_K JOIN_K ( LPAREN expression RPAREN )? production_item production_item ( production_item )*
/ rs_prod ( rs_prod )*

weight_specification <-
integral_number
/ ps_identifier
/ LPAREN expression RPAREN

rs_code_block <- LCURLY ( data_declaration )* ( statement_or_null )* RCURLY

rs_prod <-
  rs_code_block
/ rs_if_else
/ rs_repeat
/ rs_case
/ production_item

production_item <- identifier ( LPAREN list_of_arguments RPAREN )?

rs_if_else <- IF_K LPAREN expression RPAREN production_item ( ELSE_K production_item )?

rs_repeat <- REPEAT_K LPAREN expression RPAREN production_item

rs_case <- CASE_K LPAREN case_expression RPAREN rs_case_item ( rs_case_item )* ENDCASE_K

rs_case_item <-
  DEFAULT_K ( COLON )? production_item SEMI
/ case_item_expression ( COMMA case_item_expression )* COLON production_item SEMI

//A.7 Specify section
//A.7.1 Specify block declaration
specify_block <- SPECIFY_K ( specify_item )* ENDSPECIFY_K

specify_item <-
specparam_declaration
/ pulsestyle_declaration
/ showcancelled_declaration
/ path_declaration
/ system_timing_check

pulsestyle_declaration <-
PULSESTYLE_ONEVENT_K list_of_path_outputs SEMI
/ PULSESTYLE_ONDETECT_K list_of_path_outputs SEMI

showcancelled_declaration <-
SHOWCANCELLED_K list_of_path_outputs SEMI
/ NOSHOWCANCELLED_K list_of_path_outputs SEMI

//A.7.2 Specify path declarations
path_declaration <-
simple_path_declaration SEMI
/ edge_sensitive_path_declaration SEMI
/ state_dependent_path_declaration SEMI

simple_path_declaration <-
parallel_path_description EQ path_delay_value
/ full_path_description EQ path_delay_value

parallel_path_description <-
LPAREN specify_input_terminal_descriptor ( polarity_operator )? EQ_GT specify_output_terminal_descriptor RPAREN

full_path_description <- LPAREN list_of_path_inputs ( polarity_operator )? STAR_GT list_of_path_outputs RPAREN

list_of_path_inputs <- specify_input_terminal_descriptor ( COMMA specify_input_terminal_descriptor )*

list_of_path_outputs <- specify_output_terminal_descriptor ( COMMA specify_output_terminal_descriptor )*

//A.7.3 Specify block terminals
specify_input_terminal_descriptor <- input_identifier ( LBRACK constant_range_expression RBRACK )?

specify_output_terminal_descriptor <- output_identifier ( LBRACK constant_range_expression RBRACK )?

input_identifier <- 
  identifier (DOT identifier)?

output_identifier <- 
  identifier (DOT identifier)?

//A.7.4 Specify path delays
path_delay_value <-
  LPAREN list_of_path_delay_expressions RPAREN
/ list_of_path_delay_expressions

list_of_path_delay_expressions <-
  t01_path_delay_expression COMMA t10_path_delay_expression COMMA t0z_path_delay_expression COMMA
	tz1_path_delay_expression COMMA t1z_path_delay_expression COMMA tz0_path_delay_expression COMMA
	t0x_path_delay_expression COMMA tx1_path_delay_expression COMMA t1x_path_delay_expression COMMA
	tx0_path_delay_expression COMMA txz_path_delay_expression COMMA tzx_path_delay_expression
/ t01_path_delay_expression COMMA t10_path_delay_expression COMMA t0z_path_delay_expression COMMA
	tz1_path_delay_expression COMMA t1z_path_delay_expression COMMA tz0_path_delay_expression
/ trise_path_delay_expression COMMA tfall_path_delay_expression COMMA tz_path_delay_expression
/ trise_path_delay_expression COMMA tfall_path_delay_expression
/ t_path_delay_expression

t_path_delay_expression <- path_delay_expression

trise_path_delay_expression <- path_delay_expression

tfall_path_delay_expression <- path_delay_expression

tz_path_delay_expression <- path_delay_expression

t01_path_delay_expression <- path_delay_expression

t10_path_delay_expression <- path_delay_expression

t0z_path_delay_expression <- path_delay_expression

tz1_path_delay_expression <- path_delay_expression

t1z_path_delay_expression <- path_delay_expression

tz0_path_delay_expression <- path_delay_expression

t0x_path_delay_expression <- path_delay_expression

tx1_path_delay_expression <- path_delay_expression

t1x_path_delay_expression <- path_delay_expression

tx0_path_delay_expression <- path_delay_expression

txz_path_delay_expression <- path_delay_expression

tzx_path_delay_expression <- path_delay_expression

path_delay_expression <- constant_mintypmax_expression

edge_sensitive_path_declaration <-
parallel_edge_sensitive_path_description EQ path_delay_value
/ full_edge_sensitive_path_description EQ path_delay_value

parallel_edge_sensitive_path_description <-
LPAREN ( edge_identifier )? specify_input_terminal_descriptor ( polarity_operator )? EQ_GT
LPAREN specify_output_terminal_descriptor ( polarity_operator )? COLON data_source_expression RPAREN RPAREN

full_edge_sensitive_path_description <-
LPAREN ( edge_identifier )? list_of_path_inputs ( polarity_operator )? STAR_GT
	LPAREN list_of_path_outputs ( polarity_operator )? COLON data_source_expression RPAREN RPAREN

data_source_expression <- expression

edge_identifier <- POSEDGE_K / NEGEDGE_K / EDGE_K

state_dependent_path_declaration <-
  IF_K LPAREN module_path_expression RPAREN edge_sensitive_path_declaration
/ IF_K LPAREN module_path_expression RPAREN simple_path_declaration
/ IFNONE_K simple_path_declaration

polarity_operator <- PLUS / MINUS

//A.7.5 System timing checks
//A.7.5.1 System timing check commands
//NOTE<- rules starting w/ $ were changed to ds_  (dollar sign)
system_timing_check <-
ds_setup_timing_check
/ ds_hold_timing_check
/ ds_setuphold_timing_check
/ ds_recovery_timing_check
/ ds_removal_timing_check
/ ds_recrem_timing_check
/ ds_skew_timing_check
/ ds_timeskew_timing_check
/ ds_fullskew_timing_check
/ ds_period_timing_check
/ ds_width_timing_check
/ ds_nochange_timing_check

ds_setup_timing_check <-
DS_SETUP_K LPAREN data_event COMMA reference_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_hold_timing_check <-
DS_HOLD_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_setuphold_timing_check <-
DS_SETUPHOLD_K LPAREN reference_event COMMA data_event COMMA timing_check_limit COMMA timing_check_limit
	( COMMA ( notifier )? ( COMMA ( timestamp_condition )? ( COMMA ( timecheck_condition )?
	( COMMA ( delayed_reference )? ( COMMA ( delayed_data )? )? )? )? )? )? RPAREN SEMI

ds_recovery_timing_check <-
DS_RECOVERY_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_removal_timing_check <-
DS_REMOVAL_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_recrem_timing_check <-
DS_RECREM_K LPAREN reference_event COMMA data_event COMMA timing_check_limit COMMA timing_check_limit
	( COMMA ( notifier )? ( COMMA ( timestamp_condition )? ( COMMA ( timecheck_condition )?
	( COMMA ( delayed_reference )? ( COMMA ( delayed_data )? )? )? )? )? )? RPAREN SEMI

ds_skew_timing_check <- DS_SKEW_K LPAREN reference_event COMMA data_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_timeskew_timing_check <-
DS_TIMESKEW_K LPAREN reference_event COMMA data_event COMMA timing_check_limit
	( COMMA ( notifier )? ( COMMA ( event_based_flag )? ( COMMA ( remain_active_flag )? )? )? )? RPAREN SEMI

ds_fullskew_timing_check <-
DS_FULLSKEW_K LPAREN reference_event COMMA data_event COMMA timing_check_limit COMMA timing_check_limit
	( COMMA ( notifier )? ( COMMA ( event_based_flag )? ( COMMA ( remain_active_flag )? )? )? )? RPAREN SEMI

ds_period_timing_check <-
DS_PERIOD_K LPAREN controlled_reference_event COMMA timing_check_limit ( COMMA ( notifier )? )? RPAREN SEMI

ds_width_timing_check <-
DS_WIDTH_K LPAREN controlled_reference_event COMMA timing_check_limit COMMA threshold ( COMMA ( notifier )? )? RPAREN SEMI

ds_nochange_timing_check <-
DS_NOCHANGE_K LPAREN reference_event COMMA data_event COMMA start_edge_offset COMMA 
	end_edge_offset ( COMMA ( notifier )? )? RPAREN SEMI

//A.7.5.2 System timing check command arguments
timecheck_condition <- mintypmax_expression

controlled_reference_event <- controlled_timing_check_event

data_event <- timing_check_event

delayed_data <- identifier (LBRACK constant_mintypmax_expression RBRACK)? // / identifier

delayed_reference <- identifier (LBRACK constant_mintypmax_expression RBRACK)?  // / identifier

end_edge_offset <- mintypmax_expression

event_based_flag <- constant_expression

notifier <- identifier

reference_event <- timing_check_event

remain_active_flag <- constant_mintypmax_expression

timestamp_condition <- mintypmax_expression

start_edge_offset <- mintypmax_expression

threshold <- constant_expression

timing_check_limit <- expression

//A.7.5.3 System timing check event definitions
timing_check_event <- (timing_check_event_control)? specify_terminal_descriptor ( AND3 timing_check_condition )?

controlled_timing_check_event <- timing_check_event_control specify_terminal_descriptor ( AND3 timing_check_condition )?

timing_check_event_control <-
POSEDGE_K
/ NEGEDGE_K
/ EDGE_K
/ edge_control_specifier

specify_terminal_descriptor <-
specify_input_terminal_descriptor
/ specify_output_terminal_descriptor

edge_control_specifier <- EDGE_K LBRACK edge_descriptor ( COMMA edge_descriptor )* RBRACK

edge_descriptor <- "01" / "10" / [01][xX] / [xX][01]

timing_check_condition <-
  LPAREN scalar_timing_check_condition RPAREN
/ scalar_timing_check_condition

scalar_timing_check_condition <-
  expression EQ2 scalar_constant
/ expression EQ3 scalar_constant
/ expression NOT_EQ scalar_constant
/ expression NOT_EQ2 scalar_constant
/ TILDE? expression

scalar_constant <- ('1'? [bB])? [01]

//A.8 Expressions
//A.8.1 Concatenations
concatenation <-
LCURLY expression ( COMMA expression )* RCURLY

constant_concatenation <- LCURLY constant_expression ( COMMA constant_expression )* RCURLY

constant_multiple_concatenation <- LCURLY constant_expression constant_concatenation RCURLY

module_path_concatenation <- LCURLY module_path_expression ( COMMA module_path_expression )* RCURLY

module_path_multiple_concatenation <- LCURLY constant_expression module_path_concatenation RCURLY

multiple_concatenation <- LCURLY expression concatenation RCURLY

streaming_concatenation <- LCURLY stream_operator ( slice_size )? stream_concatenation RCURLY

stream_operator <- GT2 / LT2

slice_size <- simple_type / constant_expression

stream_concatenation <- LCURLY stream_expression ( COMMA stream_expression )* RCURLY

stream_expression <- expression ( WITH_K LBRACK array_range_expression RBRACK )?

array_range_expression <-
expression COLON expression
/ expression PLUS_COLON expression
/ expression MINUS_COLON expression
/ expression

empty_queue <- LCURLY RCURLY

//A.8.2 Subroutine calls
//NOTE: indirect left recursion.  inline.
//constant_function_call <- function_subroutine_call

tf_call <- ps_or_hierarchical_tf_identifier ( attribute_instance )* ( LPAREN list_of_arguments RPAREN )?

system_tf_call <-
system_tf_identifier LPAREN data_type ( COMMA expression )? RPAREN
/ system_tf_identifier ( LPAREN list_of_arguments RPAREN )?

subroutine_call <-
//{method_call
	(	//NOTE: causes ILR and seems incorrect to match so much
		//so replace{: primary 
		( package_scope / class_qualifier )? hierarchical_identifier select
		//}
	/ 	implicit_class_handle
	) DOT method_call_body
//}
/ system_tf_call
/ tf_call
//NOTE<- "std::"
/ (std_colon2)? randomize_call

//NOTE{ mitigate ILR
//method_call <- method_call_root DOT method_call_body
//method_call_root <- primary / implicit_class_handle
//}
//NOTE: inline above: method_call <- (primary / implicit_class_handle) DOT method_call_body

std_colon2<- IDENT COLON2

//ILR: inline: function_subroutine_call <- subroutine_call

list_of_arguments <-
  DOT identifier LPAREN ( expression )? RPAREN ( COMMA DOT identifier LPAREN ( expression )? RPAREN )*
/ ( expression )? ( COMMA ( expression )? )* ( COMMA DOT identifier LPAREN ( expression )? RPAREN )*

method_call_body <-
identifier ( attribute_instance )* ( LPAREN list_of_arguments RPAREN )?
/ built_in_method_call

built_in_method_call <-
array_manipulation_call
/ randomize_call

array_manipulation_call <-
array_method_name ( attribute_instance )* ( LPAREN list_of_arguments RPAREN )?  ( WITH_K LPAREN expression RPAREN )?

randomize_call <-
//NOTE<- "randomize" is not a keyword, so no RANDOMIZE_K
//I think that is a mistake.  should be keyword
RANDOMIZE_K ( attribute_instance )* ( LPAREN ( variable_identifier_list / NULL_K )? RPAREN )?
	( WITH_K ( LPAREN ( identifier_list )? RPAREN )? constraint_block )?

array_method_name <- identifier / UNIQUE_K / AND_K / OR_K / XOR_K

//A.8.3 Expressions
inc_or_dec_expression <-
inc_or_dec_operator ( attribute_instance )* variable_lvalue
/ variable_lvalue ( attribute_instance )* inc_or_dec_operator

//NOT USED: conditional_expression <- 
//NOT USED: //ILR{ cond_predicate 
//NOT USED: //ILR{ expression_or_cond_pattern 
//NOT USED: expression (MATCHES_K pattern)?
//NOT USED: //}
//NOT USED: //}
//NOT USED: 	( AND3 
//NOT USED: 		//ILR{ expression_or_cond_pattern 
//NOT USED: 		expression (MATCHES_K pattern)?
//NOT USED: 		//}
//NOT USED: 	)*
//NOT USED: 	QMARK ( attribute_instance )* expression COLON expression

constant_expression <-
  constant_expression QMARK ( attribute_instance )* constant_expression COLON constant_expression
/ constant_expression binary_operator ( attribute_instance )* constant_expression
/ unary_operator ( attribute_instance )* constant_primary
/ constant_primary

constant_mintypmax_expression <- constant_expression (COLON constant_expression COLON constant_expression)?

constant_param_expression <-
constant_mintypmax_expression / data_type / DOLLAR

param_expression <- mintypmax_expression / data_type

constant_range_expression <-
constant_expression
/ constant_part_select_range

constant_part_select_range <-
constant_range
/ constant_indexed_range

constant_range <- constant_expression COLON constant_expression

constant_indexed_range <-
constant_expression PLUS_COLON constant_expression
/ constant_expression MINUS_COLON constant_expression

expression <-
//ILR{ / conditional_expression
expression (MATCHES_K pattern)?  ( AND3 expression (MATCHES_K pattern)?)* QMARK ( attribute_instance )* expression COLON expression
//}
/ expression binary_operator ( attribute_instance )* expression
//ILR{ / inside_expression
/ expression INSIDE_K LCURLY open_range_list RCURLY
//}
/ unary_operator ( attribute_instance )* primary
/ inc_or_dec_expression
/ LPAREN operator_assignment RPAREN
/ tagged_union_expression
/ primary

tagged_union_expression <- TAGGED_K identifier ( expression )?

value_range <-
  LBRACK expression COLON expression RBRACK
/ expression

mintypmax_expression <-
  expression COLON expression COLON expression
/ expression

//module_path_conditional_expression <- 
//module_path_expression QMARK ( attribute_instance )* module_path_expression COLON module_path_expression

module_path_expression <-
//ILR{ / module_path_conditional_expression
  module_path_expression QMARK ( attribute_instance )* module_path_expression COLON module_path_expression
//}
/ module_path_expression binary_module_path_operator ( attribute_instance )*
/ unary_module_path_operator ( attribute_instance )* module_path_primary module_path_expression
/ module_path_primary

module_path_mintypmax_expression <-
  module_path_expression COLON module_path_expression COLON module_path_expression
/ module_path_expression

part_select_range <- constant_range / indexed_range

indexed_range <-
expression PLUS_COLON constant_expression
/ expression MINUS_COLON constant_expression

genvar_expression <- constant_expression

//constant_cast <-
//casting_type SQUOTE LPAREN constant_expression RPAREN
//casting_type <- simple_type / constant_primary / signing / STRING_K /CONST_K 

//A.8.4 Primaries
constant_primary <-
//NOTE replace to mitigate ILR{ / constant_cast
//ILR{ / casting_type 
constant_primary SQUOTE LPAREN constant_expression RPAREN
/ (simple_type / signing / STRING_K / CONST_K) SQUOTE LPAREN constant_expression RPAREN
//}
//}
/ constant_multiple_concatenation ( LBRACK constant_range_expression RBRACK )?
/ constant_concatenation ( LBRACK constant_range_expression RBRACK )?
/ constant_let_expression
/ LPAREN constant_mintypmax_expression RPAREN
//NOTE{ / constant_function_call
// / function_subroutine_call
/ subroutine_call
//}
/ identifier ( LBRACK constant_range_expression RBRACK )?
/ ps_parameter_identifier constant_select
/ identifier
/ ( package_scope / class_scope )? identifier
/ constant_assignment_pattern_expression
/ type_reference
/ primary_literal

module_path_primary <-
  LPAREN module_path_mintypmax_expression RPAREN
/ module_path_multiple_concatenation
/ module_path_concatenation
// / function_subroutine_call
/ subroutine_call
/ number
/ identifier

primary <-
  multiple_concatenation ( LBRACK range_expression RBRACK )?
/ concatenation ( LBRACK range_expression RBRACK )?
/ empty_queue
// / function_subroutine_call
/ subroutine_call
/ let_expression
/ LPAREN mintypmax_expression RPAREN
/ cast
/ assignment_pattern_expression
/ streaming_concatenation
/ sequence_method_call
/ THIS_K
/ DOLLAR
/ NULL_K
/ ( package_scope / class_qualifier )? hierarchical_identifier select
/ primary_literal

//LOCAL_COLON2<- local::
class_qualifier <- ( IDENT COLON2 )? ( implicit_class_handle DOT / class_scope )?

range_expression <-
expression
/ part_select_range

primary_literal <- number / time_literal / unbased_unsized_literal / string_literal

time_literal <-
unsigned_number time_unit
/ fixed_point_number time_unit

time_unit <- IDENT //s / ms / us / ns / ps / fs

implicit_class_handle <- THIS_K / SUPER_K / THIS_K DOT SUPER_K

bit_select <- ( LBRACK expression RBRACK )*

select <- ( ( DOT identifier bit_select )* DOT identifier )? bit_select ( LBRACK part_select_range RBRACK )?

nonrange_select <- ( ( DOT identifier bit_select )* DOT identifier )? bit_select

constant_bit_select <- ( LBRACK constant_expression RBRACK )*

constant_select <-
( ( DOT identifier constant_bit_select )* DOT identifier )? constant_bit_select
	( LBRACK constant_part_select_range RBRACK )?

// constant_cast <-
//casting_type SQUOTE LPAREN constant_expression RPAREN

constant_let_expression <- let_expression

cast <-
//ILR{ casting_type 
(simple_type / constant_primary / signing / STRING_K / CONST_K)
//}
	SQUOTE LPAREN expression RPAREN

//A.8.5 Expression left-side values
net_lvalue <-
  LCURLY net_lvalue ( COMMA net_lvalue )* RCURLY
/ ps_or_hierarchical_net_identifier constant_select
/ ( assignment_pattern_expression_type )? assignment_pattern_net_lvalue

variable_lvalue <-
  LCURLY variable_lvalue ( COMMA variable_lvalue )* RCURLY
/ ( implicit_class_handle DOT / package_scope )? hierarchical_identifier select
/ ( assignment_pattern_expression_type )? assignment_pattern_variable_lvalue
/ streaming_concatenation

nonrange_variable_lvalue <- ( implicit_class_handle DOT / package_scope )? hierarchical_identifier nonrange_select

//A.8.6 Operators
unary_operator <-
TILDE_AND 
/ TILDE_OR 
/ TILDE_XOR 
/ XOR_TILDE 
/ PLUS 
/ MINUS 
/ NOT 
/ TILDE 
/ AND 
/ OR 
/ XOR

binary_operator <-
LT_MINUS_GT
/ NOT_EQ_QMARK 
/ MINUS_GT 
/ GT3 
/ LT3
/ GT2 
/ LT2 
/ EQ3 
/ EQ2_QMARK 
/ EQ2 
/ NOT_EQ2 
/ NOT_EQ 
/ LT_EQ 
/ GT_EQ 
/ AND2 
/ OR2 
/ STAR2
/ XOR_TILDE 
/ TILDE_XOR 
/ PLUS 
/ MINUS 
/ STAR 
/ DIV 
/ MOD 
/ LT 
/ GT 
/ AND 
/ OR 
/ XOR 

inc_or_dec_operator <- PLUS2 / MINUS2

unary_module_path_operator <- 
TILDE_AND 
/ TILDE_OR 
/ TILDE_XOR 
/ XOR_TILDE
/ NOT 
/ TILDE 
/ AND 
/ OR 
/ XOR 

binary_module_path_operator <- 
EQ2 
/ NOT_EQ 
/ AND2 
/ OR2 
/ XOR_TILDE 
/ TILDE_XOR
/ AND 
/ OR 
/ XOR 

//A.8.7 Numbers
number <- Spacing (real_number / integral_number)

integral_number <-
octal_number
/ binary_number
/ hex_number
/ decimal_number

decimal_number <-
size? Space* decimal_base Space* unsigned_number
/ size? Space* decimal_base Space* [xX] '_'*
/ size? Space* decimal_base Space* [zZ?] '_'*
/ unsigned_number

binary_number <- size? Space* binary_base Space* binary_value

octal_number <- size? Space* octal_base Space* octal_value

hex_number <- size? Space* hex_base Space* hex_value

size <- non_zero_unsigned_number

//no spacing allowed in these begin{{
non_zero_unsigned_number <- [1-9] [_0-9]*
real_number <-
unsigned_number ('.' unsigned_number)? [eE] ('-'/'+')? unsigned_number
/ fixed_point_number
fixed_point_number <- unsigned_number '.' unsigned_number
unsigned_number <- [0-9] [_0-9]*
binary_value <- [01xXzZ?] [01xXzZ?_]* 
octal_value <- [0-7xXzZ?] [0-7xXzZ?_]*
hex_value <- [0-9a-fA-FxXzZ?] [0-9a-fA-FxXzZ?_]*
decimal_base <- "'" [sS]? [dD]
binary_base <- "'" [sS]? [bB]
octal_base <- "'" [sS]? [oO]
hex_base <- "'" [sS]? [hH]
//no spacing }}end

unbased_unsized_literal <- "'" [01xXzZ?]

//A.8.8 Strings
string_literal <- STRING //" ( Any_ASCII_Characters )* "

//A.9 General
//A.9.1 Attributes
attribute_instance <- LPAREN_STAR attr_spec ( COMMA attr_spec )* STAR_RPAREN

attr_spec <- attr_name ( EQ constant_expression )?

attr_name <- identifier


//A.9.3 Identifiers
c_identifier <- identifier //TODO<- ( a-zA-Z_ )? ( ( a-zA-Z0-9_ )? )*

escaped_identifier <- ESC_IDENT //TODO<- \ (any_ASCII_character_except_white_space)* white_space

hierarchical_identifier <- ( DS_ROOT_K DOT )? ( identifier constant_bit_select DOT )* identifier

identifier <-
simple_identifier
/ escaped_identifier

package_scope <-
identifier COLON2 !NEW_K
//UNIT_K: $unit
/ DS_UNIT_K COLON2

func_package_scope <-
identifier COLON2 !function_body_declaration_follow
/ DS_UNIT_K COLON2

ps_class_identifier <- ( package_scope )? identifier
func_ps_class_identifier <- ( func_package_scope )? identifier

ps_covergroup_identifier <- ( package_scope )? identifier

ps_identifier <- ( package_scope )? identifier

ps_or_hierarchical_array_identifier <-
( implicit_class_handle DOT / package_scope / class_scope )? hierarchical_identifier

ps_or_hierarchical_net_identifier <- ( package_scope )? identifier / hierarchical_identifier

ps_or_hierarchical_property_identifier <-
( package_scope )? identifier
/ hierarchical_identifier

ps_or_hierarchical_sequence_identifier <-
( package_scope )? identifier
/ hierarchical_identifier

ps_or_hierarchical_tf_identifier <- ( package_scope )? identifier / hierarchical_identifier

ps_parameter_identifier <-
  ( identifier ( LBRACK constant_expression RBRACK )? DOT )* identifier
/ ( package_scope / class_scope )? identifier

ps_type_identifier <- ( LOCAL_K / package_scope )? identifier

simple_identifier <- IDENT

system_tf_identifier <- SYSTEM_IDENT

extern_tf_declaration <- 
EXTERN_K method_prototype SEMI
/ EXTERN_K FORKJOIN_K task_prototype SEMI

// Define tail predicate to isolate keyword
kwrdTail <- ![a-zA-Z_0-9]

ACCEPT_ON_K  <- Spacing   "accept_on"  kwrdTail
ALIAS_K  <- Spacing   "alias"  kwrdTail
ALWAYS_COMB_K  <- Spacing   "always_comb"  kwrdTail
ALWAYS_FF_K  <- Spacing   "always_ff"  kwrdTail
ALWAYS_K  <- Spacing   "always"  kwrdTail
ALWAYS_LATCH_K  <- Spacing   "always_latch"  kwrdTail
AND_K  <- Spacing   "and"  kwrdTail
ASSERT_K  <- Spacing   "assert"  kwrdTail
ASSIGN_K  <- Spacing   "assign"  kwrdTail
ASSUME_K  <- Spacing   "assume"  kwrdTail
AUTOMATIC_K  <- Spacing   "automatic"  kwrdTail
BEFORE_K  <- Spacing   "before"  kwrdTail
BEGIN_K  <- Spacing   "begin"  kwrdTail
BIND_K  <- Spacing   "bind"  kwrdTail
BINSOF_K  <- Spacing   "binsof"  kwrdTail
BINS_K  <- Spacing   "bins"  kwrdTail
BIT_K  <- Spacing   "bit"  kwrdTail
BREAK_K  <- Spacing   "break"  kwrdTail
BUFIF0_K  <- Spacing   "bufif0"  kwrdTail
BUFIF1_K  <- Spacing   "bufif1"  kwrdTail
BUF_K  <- Spacing   "buf"  kwrdTail
BYTE_K  <- Spacing   "byte"  kwrdTail
CASEX_K  <- Spacing   "casex"  kwrdTail
CASEZ_K  <- Spacing   "casez"  kwrdTail
CASE_K  <- Spacing   "case"  kwrdTail
CELL_K  <- Spacing   "cell"  kwrdTail
CHANDLE_K  <- Spacing   "chandle"  kwrdTail
CHECKER_K  <- Spacing   "checker"  kwrdTail
CLASS_K  <- Spacing   "class"  kwrdTail
CLOCKING_K  <- Spacing   "clocking"  kwrdTail
CMOS_K  <- Spacing   "cmos"  kwrdTail
CONFIG_K  <- Spacing   "config"  kwrdTail
CONSTRAINT_K  <- Spacing   "constraint"  kwrdTail
CONST_K  <- Spacing   "const"  kwrdTail
CONTEXT_K  <- Spacing   "context"  kwrdTail
CONTINUE_K  <- Spacing   "continue"  kwrdTail
COVERGROUP_K  <- Spacing   "covergroup"  kwrdTail
COVERPOINT_K  <- Spacing   "coverpoint"  kwrdTail
COVER_K  <- Spacing   "cover"  kwrdTail
CROSS_K  <- Spacing   "cross"  kwrdTail
DEASSIGN_K  <- Spacing   "deassign"  kwrdTail
DEFAULT_K  <- Spacing   "default"  kwrdTail
DEFPARAM_K  <- Spacing   "defparam"  kwrdTail
DESIGN_K  <- Spacing   "design"  kwrdTail
DISABLE_K  <- Spacing   "disable"  kwrdTail
DIST_K  <- Spacing   "dist"  kwrdTail
DO_K  <- Spacing   "do"  kwrdTail
EDGE_K  <- Spacing   "edge"  kwrdTail
ELSE_K  <- Spacing   "else"  kwrdTail
ENDCASE_K  <- Spacing   "endcase"  kwrdTail
ENDCHECKER_K  <- Spacing   "endchecker"  kwrdTail
ENDCLASS_K  <- Spacing   "endclass"  kwrdTail
ENDCLOCKING_K  <- Spacing   "endclocking"  kwrdTail
ENDCONFIG_K  <- Spacing   "endconfig"  kwrdTail
ENDFUNCTION_K  <- Spacing   "endfunction"  kwrdTail
ENDGENERATE_K  <- Spacing   "endgenerate"  kwrdTail
ENDGROUP_K  <- Spacing   "endgroup"  kwrdTail
ENDINTERFACE_K  <- Spacing   "endinterface"  kwrdTail
ENDMODULE_K  <- Spacing   "endmodule"  kwrdTail
ENDPACKAGE_K  <- Spacing   "endpackage"  kwrdTail
ENDPRIMITIVE_K  <- Spacing   "endprimitive"  kwrdTail
ENDPROGRAM_K  <- Spacing   "endprogram"  kwrdTail
ENDPROPERTY_K  <- Spacing   "endproperty"  kwrdTail
ENDSEQUENCE_K  <- Spacing   "endsequence"  kwrdTail
ENDSPECIFY_K  <- Spacing   "endspecify"  kwrdTail
ENDTABLE_K  <- Spacing   "endtable"  kwrdTail
ENDTASK_K  <- Spacing   "endtask"  kwrdTail
END_K  <- Spacing   "end"  kwrdTail
ENUM_K  <- Spacing   "enum"  kwrdTail
EVENTUALLY_K  <- Spacing   "eventually"  kwrdTail
EVENT_K  <- Spacing   "event"  kwrdTail
EXPECT_K  <- Spacing   "expect"  kwrdTail
EXPORT_K  <- Spacing   "export"  kwrdTail
EXTENDS_K  <- Spacing   "extends"  kwrdTail
EXTERN_K  <- Spacing   "extern"  kwrdTail
FINAL_K  <- Spacing   "final"  kwrdTail
FIRST_MATCH_K  <- Spacing   "first_match"  kwrdTail
FORCE_K  <- Spacing   "force"  kwrdTail
FOREACH_K  <- Spacing   "foreach"  kwrdTail
FOREVER_K  <- Spacing   "forever"  kwrdTail
FORKJOIN_K  <- Spacing   "forkjoin"  kwrdTail
FORK_K  <- Spacing   "fork"  kwrdTail
FOR_K  <- Spacing   "for"  kwrdTail
FUNCTION_K  <- Spacing   "function"  kwrdTail
GENERATE_K  <- Spacing   "generate"  kwrdTail
GENVAR_K  <- Spacing   "genvar"  kwrdTail
GLOBAL_K  <- Spacing   "global"  kwrdTail
HIGHZ0_K  <- Spacing   "highz0"  kwrdTail
HIGHZ1_K  <- Spacing   "highz1"  kwrdTail
IFF_K  <- Spacing   "iff"  kwrdTail
IFNONE_K  <- Spacing   "ifnone"  kwrdTail
IF_K  <- Spacing   "if"  kwrdTail
IGNORE_BINS_K  <- Spacing   "ignore_bins"  kwrdTail
ILLEGAL_BINS_K  <- Spacing   "illegal_bins"  kwrdTail
IMPLIES_K  <- Spacing   "implies"  kwrdTail
IMPORT_K  <- Spacing   "import"  kwrdTail
INCDIR_K  <- Spacing   "incdir"  kwrdTail
INCLUDE_K  <- Spacing   "include"  kwrdTail
INITIAL_K  <- Spacing   "initial"  kwrdTail
INOUT_K  <- Spacing   "inout"  kwrdTail
INPUT_K  <- Spacing   "input"  kwrdTail
INSIDE_K  <- Spacing   "inside"  kwrdTail
INSTANCE_K  <- Spacing   "instance"  kwrdTail
INTEGER_K  <- Spacing   "integer"  kwrdTail
INTERFACE_K  <- Spacing   "interface"  kwrdTail
INTERSECT_K  <- Spacing   "intersect"  kwrdTail
INT_K  <- Spacing   "int"  kwrdTail
JOIN_ANY_K  <- Spacing   "join_any"  kwrdTail
JOIN_K  <- Spacing   "join"  kwrdTail
JOIN_NONE_K  <- Spacing   "join_none"  kwrdTail
LARGE_K  <- Spacing   "large"  kwrdTail
LET_K  <- Spacing   "let"  kwrdTail
LIBLIST_K  <- Spacing   "liblist"  kwrdTail
LIBRARY_K  <- Spacing   "library"  kwrdTail
LOCALPARAM_K  <- Spacing   "localparam"  kwrdTail
LOCAL_K  <- Spacing   "local"  kwrdTail
LOGIC_K  <- Spacing   "logic"  kwrdTail
LONGINT_K  <- Spacing   "longint"  kwrdTail
MACROMODULE_K  <- Spacing   "macromodule"  kwrdTail
MATCHES_K  <- Spacing   "matches"  kwrdTail
MEDIUM_K  <- Spacing   "medium"  kwrdTail
MODPORT_K  <- Spacing   "modport"  kwrdTail
MODULE_K  <- Spacing   "module"  kwrdTail
NAND_K  <- Spacing   "nand"  kwrdTail
NEGEDGE_K  <- Spacing   "negedge"  kwrdTail
NEW_K  <- Spacing   "new"  kwrdTail
NEXTTIME_K  <- Spacing   "nexttime"  kwrdTail
NMOS_K  <- Spacing   "nmos"  kwrdTail
NOR_K  <- Spacing   "nor"  kwrdTail
NOSHOWCANCELLED_K  <- Spacing   "noshowcancelled"  kwrdTail
NOTIF0_K  <- Spacing   "notif0"  kwrdTail
NOTIF1_K  <- Spacing   "notif1"  kwrdTail
NOT_K  <- Spacing   "not"  kwrdTail
NULL_K  <- Spacing   "null"  kwrdTail
OR_K  <- Spacing   "or"  kwrdTail
OUTPUT_K  <- Spacing   "output"  kwrdTail
PACKAGE_K  <- Spacing   "package"  kwrdTail
PACKED_K  <- Spacing   "packed"  kwrdTail
PARAMETER_K  <- Spacing   "parameter"  kwrdTail
PMOS_K  <- Spacing   "pmos"  kwrdTail
POSEDGE_K  <- Spacing   "posedge"  kwrdTail
PRIMITIVE_K  <- Spacing   "primitive"  kwrdTail
PRIORITY_K  <- Spacing   "priority"  kwrdTail
PROGRAM_K  <- Spacing   "program"  kwrdTail
PROPERTY_K  <- Spacing   "property"  kwrdTail
PROTECTED_K  <- Spacing   "protected"  kwrdTail
PULL0_K  <- Spacing   "pull0"  kwrdTail
PULL1_K  <- Spacing   "pull1"  kwrdTail
PULLDOWN_K  <- Spacing   "pulldown"  kwrdTail
PULLUP_K  <- Spacing   "pullup"  kwrdTail
PULSESTYLE_ONDETECT_K  <- Spacing   "pulsestyle_ondetect"  kwrdTail
PULSESTYLE_ONEVENT_K  <- Spacing   "pulsestyle_onevent"  kwrdTail
PURE_K  <- Spacing   "pure"  kwrdTail
RANDCASE_K  <- Spacing   "randcase"  kwrdTail
RANDC_K  <- Spacing   "randc"  kwrdTail
RANDSEQUENCE_K  <- Spacing   "randsequence"  kwrdTail
RAND_K  <- Spacing   "rand"  kwrdTail
RANDOMIZE_K  <- Spacing   "randomize"  kwrdTail
RCMOS_K  <- Spacing   "rcmos"  kwrdTail
REALTIME_K  <- Spacing   "realtime"  kwrdTail
REAL_K  <- Spacing   "real"  kwrdTail
REF_K  <- Spacing   "ref"  kwrdTail
REG_K  <- Spacing   "reg"  kwrdTail
REJECT_ON_K  <- Spacing   "reject_on"  kwrdTail
RELEASE_K  <- Spacing   "release"  kwrdTail
REPEAT_K  <- Spacing   "repeat"  kwrdTail
RESTRICT_K  <- Spacing   "restrict"  kwrdTail
RETURN_K  <- Spacing   "return"  kwrdTail
RNMOS_K  <- Spacing   "rnmos"  kwrdTail
RPMOS_K  <- Spacing   "rpmos"  kwrdTail
RTRANIF0_K  <- Spacing   "rtranif0"  kwrdTail
RTRANIF1_K  <- Spacing   "rtranif1"  kwrdTail
RTRAN_K  <- Spacing   "rtran"  kwrdTail
SCALARED_K  <- Spacing   "scalared"  kwrdTail
SEQUENCE_K  <- Spacing   "sequence"  kwrdTail
SHORTINT_K  <- Spacing   "shortint"  kwrdTail
SHORTREAL_K  <- Spacing   "shortreal"  kwrdTail
SHOWCANCELLED_K  <- Spacing   "showcancelled"  kwrdTail
SIGNED_K  <- Spacing   "signed"  kwrdTail
SMALL_K  <- Spacing   "small"  kwrdTail
SOLVE_K  <- Spacing   "solve"  kwrdTail
SPECIFY_K  <- Spacing   "specify"  kwrdTail
SPECPARAM_K  <- Spacing   "specparam"  kwrdTail
STATIC_K  <- Spacing   "static"  kwrdTail
STRING_K  <- Spacing   "string"  kwrdTail
STRONG0_K  <- Spacing   "strong0"  kwrdTail
STRONG1_K  <- Spacing   "strong1"  kwrdTail
STRONG_K  <- Spacing   "strong"  kwrdTail
STRUCT_K  <- Spacing   "struct"  kwrdTail
SUPER_K  <- Spacing   "super"  kwrdTail
SUPPLY0_K  <- Spacing   "supply0"  kwrdTail
SUPPLY1_K  <- Spacing   "supply1"  kwrdTail
SYNC_ACCEPT_ON_K  <- Spacing   "sync_accept_on"  kwrdTail
SYNC_REJECT_ON_K  <- Spacing   "sync_reject_on"  kwrdTail
S_ALWAYS_K  <- Spacing   "s_always"  kwrdTail
S_EVENTUALLY_K  <- Spacing   "s_eventually"  kwrdTail
S_NEXTTIME_K  <- Spacing   "s_nexttime"  kwrdTail
S_UNTIL_K  <- Spacing   "s_until"  kwrdTail
S_UNTIL_WITH_K  <- Spacing   "s_until_with"  kwrdTail
TABLE_K  <- Spacing   "table"  kwrdTail
TAGGED_K  <- Spacing   "tagged"  kwrdTail
TASK_K  <- Spacing   "task"  kwrdTail
THIS_K  <- Spacing   "this"  kwrdTail
THROUGHOUT_K  <- Spacing   "throughout"  kwrdTail
TIMEPRECISION_K  <- Spacing   "timeprecision"  kwrdTail
TIMEUNIT_K  <- Spacing   "timeunit"  kwrdTail
TIME_K  <- Spacing   "time"  kwrdTail
TRANIF0_K  <- Spacing   "tranif0"  kwrdTail
TRANIF1_K  <- Spacing   "tranif1"  kwrdTail
TRAN_K  <- Spacing   "tran"  kwrdTail
TRI0_K  <- Spacing   "tri0"  kwrdTail
TRI1_K  <- Spacing   "tri1"  kwrdTail
TRIAND_K  <- Spacing   "triand"  kwrdTail
TRIOR_K  <- Spacing   "trior"  kwrdTail
TRIREG_K  <- Spacing   "trireg"  kwrdTail
TRI_K  <- Spacing   "tri"  kwrdTail
TYPEDEF_K  <- Spacing   "typedef"  kwrdTail
TYPE_K  <- Spacing   "type"  kwrdTail
UNION_K  <- Spacing   "union"  kwrdTail
UNIQUE0_K  <- Spacing   "unique0"  kwrdTail
UNIQUE_K  <- Spacing   "unique"  kwrdTail
UNSIGNED_K  <- Spacing   "unsigned"  kwrdTail
UNTIL_K  <- Spacing   "until"  kwrdTail
UNTIL_WITH_K  <- Spacing   "until_with"  kwrdTail
UNTYPED_K  <- Spacing   "untyped"  kwrdTail
USE_K  <- Spacing   "use"  kwrdTail
UWIRE_K  <- Spacing   "uwire"  kwrdTail
VAR_K  <- Spacing   "var"  kwrdTail
VECTORED_K  <- Spacing   "vectored"  kwrdTail
VIRTUAL_K  <- Spacing   "virtual"  kwrdTail
VOID_K  <- Spacing   "void"  kwrdTail
WAIT_K  <- Spacing   "wait"  kwrdTail
WAIT_ORDER_K  <- Spacing   "wait_order"  kwrdTail
WAND_K  <- Spacing   "wand"  kwrdTail
WEAK0_K  <- Spacing   "weak0"  kwrdTail
WEAK1_K  <- Spacing   "weak1"  kwrdTail
WEAK_K  <- Spacing   "weak"  kwrdTail
WHILE_K  <- Spacing   "while"  kwrdTail
WILDCARD_K  <- Spacing   "wildcard"  kwrdTail
WIRE_K  <- Spacing   "wire"  kwrdTail
WITHIN_K  <- Spacing   "within"  kwrdTail
WITH_K  <- Spacing   "with"  kwrdTail
WOR_K  <- Spacing   "wor"  kwrdTail
XNOR_K  <- Spacing   "xnor"  kwrdTail
XOR_K  <- Spacing   "xor"  kwrdTail
W1STEP_K  <- Spacing   "1step" kwrdTail	//NOTE: actually not a keyword in LRM

//Token definitions

AND <- Spacing  				'&'		
AND2 <- Spacing  				"&&"	
AND3 <- Spacing  				"&&&"	
AND_EQ <- Spacing  				"&="	
AT <- Spacing  					'@'		
AT2 <- Spacing  				"@@"	
AT_STAR <- Spacing  			"@*"	
BAR_EQ_GT <- Spacing  			"|=>"	
BAR_MINUS_GT <- Spacing  		"|->"	
COLON2 <- Spacing  				"::" 	
COLON <- Spacing  				':'		
COLON_DIV <- Spacing  			":/"	
COLON_EQ <- Spacing  			":="	
COMMA <- Spacing  				','		
//changed to NUMBER <- Spacing   DIGIT_012:			'0'..'2'
DIV <- Spacing  				'/'		
DIV_EQ <- Spacing  				"/="	
DOLLAR <- Spacing  				'$'		
DOT <- Spacing  				'.'		
DOT_STAR <- Spacing  			".*"	
EQ2 <- Spacing  				"=="	 
EQ2_QMARK <- Spacing  			"==?"	
EQ3 <- Spacing  				"==="	
EQ <- Spacing  					'='		
EQ_GT <- Spacing  				"=>"	
GT2 <- Spacing  				">>"	
GT2_EQ <- Spacing  				">>="	
GT3_EQ <- Spacing  				">>>="	
GT <- Spacing  					'>'		 
GT3 <- Spacing  				">>>"	
GT_EQ <- Spacing  				">="	 
LBRACK <- Spacing  				'['		
LCURLY <- Spacing  				'{'		
LPAREN <- Spacing  				'('		
LPAREN_STAR <- Spacing  		"(*"	
LT2 <- Spacing  				"<<"	
LT2_EQ <- Spacing  				"<<="	
LT3_EQ <- Spacing  				"<<<="	
LT <- Spacing  					'<'		 
LT3 <- Spacing  				"<<<"	
LT_EQ <- Spacing  				"<="	 
LT_MINUS_GT <- Spacing  		"<->"	
MINUS2 <- Spacing  				"--"	 
MINUS <- Spacing  				'-'		
MINUS_COLON <- Spacing  		"-:"	
MINUS_EQ <- Spacing  			"-="	
MINUS_GT2 <- Spacing  			"->>"	
MINUS_GT <- Spacing  			"->"	
MOD <- Spacing  				'%'		 
MOD_EQ <- Spacing  				"%="	
NOT <- Spacing  				'!'		
NOT_EQ2 <- Spacing  			"!=="	
NOT_EQ <- Spacing  				"!="	 
NOT_EQ_QMARK <- Spacing  		"!=?"	
OR2 <- Spacing  				"||"	
OR <- Spacing  					'|'		
OR_EQ <- Spacing  				"|="	
PLUS2 <- Spacing  				"++"	 
PLUS <- Spacing  				'+'		 
PLUS_COLON <- Spacing  			"+:"	
PLUS_EQ <- Spacing  			"+="	
POUND2 <- Spacing  				"##"	
POUND <- Spacing  				'#'		
POUND_EQ_POUND <- Spacing  		"#=#"	
POUND_MINUS_POUND <- Spacing  	"#-#"	
QMARK <- Spacing  				'?'		
RBRACK <- Spacing  				']'		
RCURLY <- Spacing  				'}'		
RPAREN <- Spacing  				')'		
SEMI <- Spacing  				';'		
STAR2 <- Spacing  				"**"	 
STAR <- Spacing  				'*'		
STAR_COLON2_STAR <- Spacing  	"*::*"	
STAR_EQ <- Spacing  			"*="	
STAR_GT <- Spacing  			"*>"	
STAR_RPAREN <- Spacing  		"*)"	
TILDE <- Spacing  				'~'		
TILDE_AND <- Spacing  			"~&"	
TILDE_OR <- Spacing  			"~|"	
TILDE_XOR <- Spacing  			"~^"	
XOR <- Spacing  				'^'		
XOR_EQ <- Spacing  				"^="	
XOR_TILDE <- Spacing  			"^~"	

SQUOTE <- Spacing  				"'"		

PATHPULSE_K <- Spacing  	"PATHPULSE$" kwrdTail
DS_SETUP_K <- Spacing  		"$setup" kwrdTail
DS_REMOVAL_K <- Spacing   	"$removal" kwrdTail
DS_PERIOD_K <- Spacing  		"$period" kwrdTail
DS_RECREM_K <- Spacing  		"$recrem" kwrdTail
DS_SETUPHOLD_K <- Spacing  	"$setuphold" kwrdTail
DS_RECOVERY_K <- Spacing  	"$recovery" kwrdTail
DS_HOLD_K <- Spacing  		"$hold" kwrdTail
DS_WIDTH_K <- Spacing  		"$width" kwrdTail
DS_SKEW_K <- Spacing  		"$skew" kwrdTail
DS_FULLSKEW_K <- Spacing  	"$fullskew" kwrdTail
DS_TIMESKEW_K <- Spacing  	"$timeskew" kwrdTail
DS_NOCHANGE_K <- Spacing  	"$nochange" kwrdTail
DS_FATAL_K <- Spacing  		"$fatal" kwrdTail
DS_ERROR_K <- Spacing  		"$error" kwrdTail
DS_WARNING_K <- Spacing  		"$warning" kwrdTail
DS_INFO_K <- Spacing  		"$info" kwrdTail
DS_UNIT_K <- Spacing  		"$unit" kwrdTail
DS_ROOT_K <- Spacing  		"$root" kwrdTail

ESC_IDENT  <- Spacing '\\' (!(' ' / '\r' / '\t' / EOL) .)+
        
/**Need to match keywords (*_K) or IDENT
IDENT <- Spacing IdentStart IdentCont*
**/
IDENT << MyIDENT
IdentStart <- [a-zA-Z_]
IdentCont <- IdentStart / [0-9] //TODO: where is this used: / '$'

STRING <- Spacing '"' ('"' / (!'"' .)+ '"')

SYSTEM_IDENT <- Spacing '$' IdentStart IdentCont*
DIGIT <- Spacing [0-9]

/** Improve performance dramatically
Spacing <- (Space / Comment / TicLine / TimeScale)*
**/
Spacing << MySpacing
Comment <- SL_COMMENT / ML_COMMENT
SL_COMMENT  <- "//" (!(EOL / EOF) .)* (EOL / EOF)
ML_COMMENT  <- "/*" (!("*/" / EOF) .)* "*/"

Space <- ' ' / '\t' / EOL

TicLine <- "`line" Space+ [0-9]+ Space+ STRING Space+ [0-2]

TimeScale <- "`timescale" Space+ TimeValue Space* '/' Space* TimeValue
TimeValue <- [0-9]+ Space* ("s" / "ms" / "us" / "ns" / "ps" / "fs")
